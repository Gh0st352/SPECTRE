<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>S.P.E.C.T.R.E.</h1>


<ul>
  <li><a href="../manual.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="nowrap">
  <li><a href="../source/ai.lua.html">ai.lua</a></li>
  <li><strong>dynamic_spawner.lua</strong></li>
  <li><a href="../source/fileio.lua.html">fileio.lua</a></li>
  <li><a href="../source/object.lua.html">object.lua</a></li>
  <li><a href="../source/player_manager.lua.html">player_manager.lua</a></li>
  <li><a href="../source/point_manager.lua.html">point_manager.lua</a></li>
  <li><a href="../source/poly.lua.html">poly.lua</a></li>
  <li><a href="../source/spectre.lua.html">spectre.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/world.lua.html">world.lua</a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/AI.html">AI</a></li>
  <li><a href="../modules/DYNAMIC_SPAWNER.html">DYNAMIC_SPAWNER</a></li>
  <li><a href="../modules/FileIO.html">FileIO</a></li>
  <li><a href="../modules/OBJECT.html">OBJECT</a></li>
  <li><a href="../modules/PLAYER_MANAGER.html">PLAYER_MANAGER</a></li>
  <li><a href="../modules/POINT_MANAGER.html">POINT_MANAGER</a></li>
  <li><a href="../modules/POLY.html">POLY</a></li>
  <li><a href="../modules/SPECTRE.html">SPECTRE</a></li>
  <li><a href="../modules/Utils.html">Utils</a></li>
  <li><a href="../modules/WORLD.html">WORLD</a></li>
</ul>
<h2>Topics</h2>
<ul class="">
  <li><a href="../topics/readme.md.html">readme</a></li>
</ul>

</div>

<div id="content">

    <h2>dynamic_spawner.lua</h2>
<pre>
<span class="comment">--- **SPECTRE.DYNAMIC_SPAWNER**
</span><span class="comment">--
</span><span class="comment">-- Automated Spawning.
</span><span class="comment">--
</span><span class="comment">--  ***Dynamic Spawner for SPECTRE.***
</span><span class="comment">--
</span><span class="comment">--   * The DYNAMIC_SPAWNER Class.
</span><span class="comment">--
</span><span class="comment">--   * All aspects of the DYNAMIC_SPAWNER are accessed via this class.
</span><span class="comment">--
</span><span class="comment">--     -- Dynamic Spawning of DCS Units.
</span><span class="comment">--     -- Accounts for existing ground &amp; sea buildings, units, objects, scenery
</span><span class="comment">--     -- Works utilizing (tunable) coroutines (multithreading)
</span><span class="comment">--     -- Prevents the extension from interferring with/stalling the main game thread.
</span><span class="comment">--     -- Provide generation parameters via a config table.
</span><span class="comment">--
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">--      <a href="../modules/SPECTRE.html#">SPECTRE</a> ---&gt; ???
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- @module DYNAMIC_SPAWNER
</span><span class="comment">-- @extends SPECTRE
</span>

env.info(<span class="string">" *** LOAD S.P.E.C.T.R.E. - DYNAMIC_SPAWNER *** "</span>)

<span class="comment">---DYNAMIC_SPAWNER.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- All Functions associated with the DYNAMIC_SPAWNER class.
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">--  ***Dynamic Spawner for SPECTRE.***
</span><span class="comment">--
</span><span class="comment">--   * The DYNAMIC_SPAWNER Class.
</span><span class="comment">--
</span><span class="comment">--   * All aspects of the DYNAMIC_SPAWNER are accessed via this class.
</span><span class="comment">--
</span><span class="comment">--          -- Dynamic Spawning of DCS Units.
</span><span class="comment">--          -- Accounts for existing ground &amp; sea buildings, units, objects, scenery
</span><span class="comment">--          -- Works utilizing (tunable) coroutines (multithreading)
</span><span class="comment">--          -- Prevents the extension from interferring with/stalling the main game thread.
</span><span class="comment">--          -- Provide generation parameters via a config table.
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section DYNAMIC_SPAWNER
</span>
<span class="comment">--- ###DYNAMIC_SPAWNER
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">--      Dynamic Generation, Placement, and Spawning of Units.
</span><span class="comment">--
</span><span class="comment">-- * Dynamic Spawner for SPECTRE
</span><span class="comment">--
</span><span class="comment">-- * Utilizes coroutines for async generation, preventing interruption of main game thread.
</span><span class="comment">--
</span><span class="comment">-- * Houses all aspects dealing with dynamic unit spawning.
</span><span class="comment">--
</span><span class="comment">-- @field #DYNAMIC_SPAWNER
</span><span class="comment">-- @field ClassName SPECTRE.OBJECT.DYNAMIC_SPAWNER
</span><a id="64"></a><span class="comment">-- @field ClassID The ID number of the class.
</span>SPECTRE.DYNAMIC_SPAWNER = {
  ClassName = <span class="string">"DYNAMIC_SPAWNER"</span>,
  ClassID = <span class="number">0</span>,
  COUNTER = <span class="number">1</span>,
}

<span class="comment">--- Creates new DYNAMIC_SPAWNER Object.
</span><span class="comment">--
</span><span class="comment">-- Everything is called from the DYNAMIC_SPAWNER Object.
</span><span class="comment">--
</span><span class="comment">-- @param self
</span><span class="comment">-- @return #DYNAMIC_SPAWNER
</span><span class="comment">-- @usage
</span><span class="comment">-- local self = SPECTRE.DYNAMIC_SPAWNER:New()
</span><span class="comment">-- -- self is DYNAMIC_SPAWNER Object with defaults configured
</span><span class="comment">-- -- self is now set as below
</span><span class="comment">-- self = {
</span><span class="comment">--           OBJECT = SPECTRE.OBJECT.DYNAMIC_SPAWNER,
</span><span class="comment">--           DebugEnabled                  = 0,
</span><span class="comment">--           DebugMessages                 = 0,
</span><span class="comment">--           DebugLog = {},
</span><span class="comment">--           Config = {
</span><span class="comment">--                       UnitsMin          = 30,
</span><span class="comment">--                       UnitsMax          = 50,
</span><span class="comment">--                       operationLimit    = 200,
</span><span class="comment">--                       operationInterval = 3,
</span><span class="comment">--                       NumGroupsMin      = 9,  --non functional
</span><span class="comment">--                       NumGroupsMax      = 12, -- non functional
</span><span class="comment">--                       numExtraTypes     = 0,
</span><span class="comment">--                       numExtraUnits     = 0,
</span><span class="comment">--                       LimitedSpawnStrings = {},
</span><span class="comment">--                       Types = {},
</span><span class="comment">--                       GroupSpacingSettings = {
</span><span class="comment">--                         General = {
</span><span class="comment">--                                    minSeparation_Groups  = 30, --meters, minimum distance between groups
</span><span class="comment">--                                    minSeperation         = 15, --meters, min distance between units in group
</span><span class="comment">--                                    maxSeperation         = 30, --meters, max distance between units in group
</span><span class="comment">--                                    DistanceFromBuildings = 20,
</span><span class="comment">--                         },
</span><span class="comment">--                         [1] = {
</span><span class="comment">--                                    minSeparation_Groups  = 5, --meters, distance space between groups
</span><span class="comment">--                                    minSeperation         = 2, --meters, min distance between units in group
</span><span class="comment">--                                    maxSeperation         = 3, --meters, max distance between units in group
</span><span class="comment">--                         },
</span><span class="comment">--                         [2] = {
</span><span class="comment">--                                    minSeparation_Groups  = 25, --meters, distance space between groups
</span><span class="comment">--                                    minSeperation         = 10, --meters, min distance between units in group
</span><span class="comment">--                                    maxSeperation         = 35, --meters, max distance between units in group
</span><span class="comment">--                         },
</span><span class="comment">--                         [3] = {
</span><span class="comment">--                                    minSeparation_Groups  = 30, --meters, distance space between groups
</span><span class="comment">--                                    minSeperation         = 15, --meters, min distance between units in group
</span><span class="comment">--                                    maxSeperation         = 35, --meters, max distance between units in group
</span><span class="comment">--                         },
</span><span class="comment">--                         [4] = {
</span><span class="comment">--                                    minSeparation_Groups  = 35, --meters, distance space between groups
</span><span class="comment">--                                    minSeperation         = 15, --meters, min distance between units in group
</span><span class="comment">--                                    maxSeperation         = 40, --meters, max distance between units in group
</span><span class="comment">--                         },
</span><span class="comment">--
</span><span class="comment">--                       },
</span><span class="comment">--                       GroupSizes = { --Priority of group sizes made
</span><span class="comment">--                                      [1] = 4,
</span><span class="comment">--                                      [2] = 3,
</span><span class="comment">--                                      [3] = 2,
</span><span class="comment">--                                      [4] = 1,
</span><span class="comment">--                       }, --Priority of group sizes made
</span><span class="comment">--                       GroupSizesMainZone = { --Priority of group sizes made
</span><span class="comment">--                                               [1] = 3,
</span><span class="comment">--                                               [2] = 2,
</span><span class="comment">--                                               [3] = 1,
</span><span class="comment">--                                            }, --Priority of group sizes made
</span><span class="comment">--                     },
</span><span class="comment">--        Zones = {
</span><span class="comment">--                   Main = {},
</span><span class="comment">--                   Sub = {},
</span><span class="comment">--                   Restricted = {},
</span><span class="comment">--                },
</span><span class="comment">--        GenerationComplete = false,
</span><span class="comment">--        GenerationInProgress = false
</span><a id="145"></a><span class="comment">--        }
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:New()
  <span class="keyword">local</span> self=BASE:Inherit(self, BASE:New())
  self.OBJECT = SPECTRE.OBJECT.DYNAMIC_SPAWNER
  self.DebugEnabled = <span class="number">0</span>
  self.DebugMessages = <span class="number">0</span>
  self.DebugMenuPlayer = <span class="number">0</span>
  self.DebugLog = {}
  self.NoGoSurface = {
    <span class="comment">--   "LAND",--1,--
</span>    <span class="comment">--   "SHALLOW_WATER",--2,
</span>    <span class="string">"WATER"</span>,<span class="comment">--3,
</span>    <span class="comment">--   "ROAD",--4,
</span>    <span class="string">"RUNWAY"</span>,<span class="comment">--5,
</span>    <span class="string">"nil"</span>,
  }
  self.AllTypes = {}
  self.Co_Counter = <span class="number">0</span>
  self.Config = {
    UnitsMin          = <span class="number">30</span>,
    UnitsMax          = <span class="number">50</span>,
    operationLimit = <span class="number">200</span>,
    operationInterval = <span class="number">3</span>,
    NumGroupsMin = <span class="number">9</span>,  <span class="comment">--non functional
</span>    NumGroupsMax = <span class="number">12</span>, <span class="comment">-- non functional
</span>    numExtraTypes = <span class="number">0</span>,
    numExtraUnits = <span class="number">0</span>,
    LimitedSpawnStrings = {},
    Types = {},
    GroupSpacingSettings = {
      General = {
        minSeparation_Groups = <span class="number">30</span>, <span class="comment">--meters, minimum space between groups
</span>        minSeperation = <span class="number">15</span>, <span class="comment">--meters, minimum space between units in group
</span>        maxSeperation = <span class="number">30</span>, <span class="comment">--meters, maximum space between units in group
</span>        DistanceFromBuildings = <span class="number">20</span>,
      },
      [<span class="number">1</span>] = {
        minSeparation_Groups = <span class="number">5</span>, <span class="comment">--meters, minimum space between groups
</span>        minSeperation = <span class="number">2</span>, <span class="comment">--meters, minimum space between units in group
</span>        maxSeperation = <span class="number">3</span>, <span class="comment">--meters, maximum space between units in group
</span>      },
      [<span class="number">2</span>] = {
        minSeparation_Groups = <span class="number">25</span>, <span class="comment">--meters, minimum space between groups
</span>        minSeperation = <span class="number">10</span>, <span class="comment">--meters, minimum space between units in group
</span>        maxSeperation = <span class="number">35</span>, <span class="comment">--meters, maximum space between units in group
</span>      },
      [<span class="number">3</span>] = {
        minSeparation_Groups = <span class="number">30</span>, <span class="comment">--meters, minimum space between groups
</span>        minSeperation = <span class="number">15</span>, <span class="comment">--meters, minimum space between units in group
</span>        maxSeperation = <span class="number">35</span>, <span class="comment">--meters, maximum space between units in group
</span>      },
      [<span class="number">4</span>] = {
        minSeparation_Groups = <span class="number">35</span>, <span class="comment">--meters, minimum space between groups
</span>        minSeperation = <span class="number">15</span>, <span class="comment">--meters, minimum space between units in group
</span>        maxSeperation = <span class="number">40</span>, <span class="comment">--meters, maximum space between units in group
</span>      },

    },
    GroupSizes = { <span class="comment">--Priority of group sizes made
</span>      [<span class="number">1</span>] = <span class="number">4</span>,
      [<span class="number">2</span>] = <span class="number">3</span>,
      [<span class="number">3</span>] = <span class="number">2</span>,
      [<span class="number">4</span>] = <span class="number">1</span>,
    }, <span class="comment">--Priority of group sizes made
</span>    GroupSizesMainZone = { <span class="comment">--Priority of group sizes made
</span>      [<span class="number">1</span>] = <span class="number">3</span>,
      [<span class="number">2</span>] = <span class="number">2</span>,
      [<span class="number">3</span>] = <span class="number">1</span>,
    }, <span class="comment">--Priority of group sizes made
</span>  }
  self.Zones = {
    Main = {},
    Sub = {},
    Restricted = {},
  }
  self.GenerationComplete = <span class="keyword">false</span>
  self.GenerationInProgress = <span class="keyword">false</span>
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - New() - self"</span>)
    BASE:E(self)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">---Basic Use.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with basic use of the DYNAMIC_SPAWNER class.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- **Basic Use**
</span><span class="comment">--
</span><span class="comment">--     Use with 4 steps:
</span><span class="comment">--     1 --- Create your configuration parameters for the Dynamic Spawner.
</span><span class="comment">--     2 --- Create a new SPECTRE.DYNAMIC_SPAWNER Object
</span><span class="comment">--     3 --- Import your config to the Dynamic Spawner.
</span><span class="comment">--     4 --- Spawn your units!
</span><span class="comment">-- .
</span><span class="comment">--     --- Process:
</span><span class="comment">--
</span><span class="comment">--     1 --- Create your configuration parameters for the Dynamic Spawner.
</span><span class="comment">--     --
</span><span class="comment">--     --    See "Configuration" section below for more information.
</span><span class="comment">--     --             At the bottom is a full example spawnerConfig.
</span><span class="comment">--
</span><span class="comment">--           local spawnerConfig = {
</span><span class="comment">--                                    MissionEditorZoneNames = {...},
</span><span class="comment">--                                    Config                 = {...},
</span><span class="comment">--                                    TypeTemplates          = {...},
</span><span class="comment">--                                    ExtraTypes             = {...},
</span><span class="comment">--                                 }
</span><span class="comment">--
</span><span class="comment">--     2 --- Create a new SPECTRE.DYNAMIC_SPAWNER Object
</span><span class="comment">--
</span><span class="comment">--           local spawnerObject = SPECTRE.DYNAMIC_SPAWNER:New()
</span><span class="comment">--
</span><span class="comment">--     3 --- Import your config to the Dynamic Spawner.
</span><span class="comment">--     --
</span><span class="comment">--     --    @see SPECTRE.DYNAMIC_SPAWNER:ConfigImport()
</span><span class="comment">--
</span><span class="comment">--           spawnerObject:ConfigImport(
</span><span class="comment">--                                        spawnerConfig.MissionEditorZoneNames,
</span><span class="comment">--                                        spawnerConfig.Config,
</span><span class="comment">--                                        spawnerConfig.TypeTemplates,
</span><span class="comment">--                                        spawnerConfig.ExtraTypes
</span><span class="comment">--                                      )
</span><span class="comment">--
</span><span class="comment">--     4 --- Spawn your units!
</span><span class="comment">--     --
</span><span class="comment">--     --    @see SPECTRE.DYNAMIC_SPAWNER:Generate()
</span><span class="comment">--
</span><span class="comment">--           spawnerObject:Generate()
</span><span class="comment">--
</span><span class="comment">--     --- All Done! Ezpz.
</span><span class="comment">--     ---------------------------------------------------------------------------------
</span><span class="comment">--
</span><span class="comment">--     ---Bonus: You can chain functions.
</span><span class="comment">--
</span><span class="comment">--     local spawnerConfig = {...}
</span><span class="comment">--     local spawnerObject =SPECTRE.DYNAMIC_SPAWNER:New()
</span><span class="comment">--           :ConfigImport(
</span><span class="comment">--                          spawnerConfig.MissionEditorZoneNames,
</span><span class="comment">--                          spawnerConfig.Config,
</span><span class="comment">--                          spawnerConfig.TypeTemplates,
</span><span class="comment">--                          spawnerConfig.ExtraTypes
</span><span class="comment">--                        )
</span><span class="comment">--           :Generate()
</span><span class="comment">--
</span><span class="comment">--     or
</span><span class="comment">--
</span><span class="comment">--     local spawnerConfig = {...}
</span><span class="comment">--     local spawnerObject = SPECTRE.DYNAMIC_SPAWNER:New():ConfigImport(spawnerConfig.MissionEditorZoneNames, spawnerConfig.Config, spawnerConfig.TypeTemplates, spawnerConfig.ExtraTypes):Generate()
</span><span class="comment">--  ===
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section Basic Use
</span>
<span class="comment">--- Imports Pre-made config tables for the SPECTRE.DYNAMIC_SPAWNER.
</span><span class="comment">--
</span><span class="comment">-- Shortcut to limit code length in main scripts.
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">--
</span><span class="comment">-- **The function takes 4 arguments, each a table.**
</span><span class="comment">--
</span><span class="comment">--     ZoneNames = {...},
</span><span class="comment">--     Config = {...},
</span><span class="comment">--     TypeTemplates  = {...},
</span><span class="comment">--     ExtraTypes   = {...},
</span><span class="comment">--
</span><span class="comment">-- *where*
</span><span class="comment">--
</span><span class="comment">-- **ZoneNames**
</span><span class="comment">--
</span><span class="comment">--   *Contains all zone names for the spawner to work with (Main, Sub, and Restricted).*
</span><span class="comment">--
</span><span class="comment">--      --- Restricted.Main = #string
</span><span class="comment">--      --            *The main zone of the dynamic spawner.
</span><span class="comment">--      --            *All other zones are contained within it.
</span><span class="comment">--                      ex. Main = "Zone_Main",
</span><span class="comment">--
</span><span class="comment">--      --- Restricted.Sub = #table
</span><span class="comment">--      --            *All sub zones of the dynamic spawner
</span><span class="comment">--      --            *Used for weighting location probability of type group clusters.
</span><span class="comment">--                      ex. Sub = {"Zone_Sub-1",
</span><span class="comment">--                                 "Zone_Sub-2",
</span><span class="comment">--                                 "Zone_Sub-3",},
</span><span class="comment">--
</span><span class="comment">--      --- Restricted.Restricted = #table
</span><span class="comment">--      --            *All restricted zones of the dynamic spawner.
</span><span class="comment">--      --            *Prevents spawning of any Type within any restricted zone.
</span><span class="comment">--                      ex. Restricted = {"Zone_Restricted-1",
</span><span class="comment">--                                        "Zone_Restricted-2",
</span><span class="comment">--                                        "Zone_Restricted-3",},
</span><span class="comment">--      --         Can be = {} or nil
</span><span class="comment">--                      ex. Restricted = {}
</span><span class="comment">--                      ex. Restricted = nil
</span><span class="comment">--     ---------------------------------------------------------------------------------
</span><span class="comment">--      ZoneNames = {
</span><span class="comment">--                    Main = "Zone_Main",
</span><span class="comment">--                    Sub = {"Zone_Sub-1", "Zone_Sub-2", "Zone_Sub-3",},
</span><span class="comment">--                    Restricted = {
</span><span class="comment">--                                   "Zone_Restricted-1",
</span><span class="comment">--                                   "Zone_Restricted-2",
</span><span class="comment">--                                   "Zone_Restricted-3",
</span><span class="comment">--                                 },
</span><span class="comment">--                  }
</span><span class="comment">--
</span><span class="comment">-- **TypeTemplates**
</span><span class="comment">--
</span><span class="comment">--   *Contains the Types the dynamic spawner will have access to, and their corresponding Mission Editor Template Group Names.*
</span><span class="comment">--
</span><span class="comment">--          --- Type: The defined term for the 'type' of unit you are spawning.
</span><span class="comment">--          --      In these examples, Types are grouped by the 'type' of object.
</span><span class="comment">--                      eg. Type = APC, IFV, MBT, Supply
</span><span class="comment">--          --          These can be anything you want.
</span><span class="comment">--                      eg. Type = Type1, Yellow, Train, Cow
</span><span class="comment">--          --      In TypeTemplates below, Type can be seen as:
</span><span class="comment">--                          TypeTemmplates.Type   = {...}
</span><span class="comment">--
</span><span class="comment">--                          TypeTemmplates.APC    = {...}
</span><span class="comment">--                          TypeTemmplates.IFV    = {...}
</span><span class="comment">--                          TypeTemmplates.MBT    = {...}
</span><span class="comment">--                          TypeTemmplates.Supply = {...}
</span><span class="comment">--
</span><span class="comment">--          --- Templates: The defined group name for the 'template' of type you are spawning.
</span><span class="comment">--          --       These must match a group name in the mission editor, late activated.
</span><span class="comment">--          --       The groups can be any number of units, but will only count as 1 'Type'.
</span><span class="comment">--
</span><span class="comment">--          --          eg. 2 groups in the mission editor with:
</span><span class="comment">--                                 groupname1 = "exGroupName1"
</span><span class="comment">--                                 1 Unit in group
</span><span class="comment">--                                 groupname2 = "exGroupName2"
</span><span class="comment">--                                 3 Units in group
</span><span class="comment">--
</span><span class="comment">--          --       Even though each group has a different number of units,
</span><span class="comment">--          --       each group only counts as 1 'Type' to the Dynamic Spawner.
</span><span class="comment">--          --
</span><span class="comment">--          --       So if UnitsMin = 5, that means the spawner will spawn 5 types minimum.
</span><span class="comment">--          --
</span><span class="comment">--          --       Because the above example 'groupname1' is 1 units per 'Type'
</span><span class="comment">--          --       the spawner would place 5 units minimum.
</span><span class="comment">--          --       While because the above example 'groupname2' is 3 units per 'Type'
</span><span class="comment">--          --       the spawner would place 15 units minimum.
</span><span class="comment">--          --
</span><span class="comment">--          --  In these examples:
</span><span class="comment">--          --     Templates are 1 placed unit per group in the Mission editor.
</span><span class="comment">--          --     The Template ME group name matches below 'Templates'.
</span><span class="comment">--          --
</span><span class="comment">--          --     Templates are grouped by the 'type' of object.
</span><span class="comment">--                   eg. Type = Template
</span><span class="comment">--                   eg. TypeTemmplates.IFV = {"Template_IFV_Bradley","Template_IFV_Warrior",}
</span><span class="comment">--
</span><span class="comment">--          --     In TypeTemplates below, Templates can be seen as:
</span><span class="comment">--                       TypeTemmplates.Type  = Templates
</span><span class="comment">--                       TypeTemmplates.IFV    = {
</span><span class="comment">--                                                 "Template_IFV_Bradley",
</span><span class="comment">--                                                  "Template_IFV_Warrior",
</span><span class="comment">--                                               }
</span><span class="comment">--     ---------------------------------------------------------------------------------
</span><span class="comment">--          TypeTemplates = {
</span><span class="comment">--                            APC  = {
</span><span class="comment">--                                     "Template_APC_BTR80",
</span><span class="comment">--                                     "Template_APC_MTLB",
</span><span class="comment">--                                     "Template_APC_BTRRD",
</span><span class="comment">--                                   },
</span><span class="comment">--                            IFV  = {
</span><span class="comment">--                                     "Template_IFV_Bradley",
</span><span class="comment">--                                     "Template_IFV_Warrior",
</span><span class="comment">--                                   },
</span><span class="comment">--                            MBT  = {
</span><span class="comment">--                                     "Template_MBT_T72B",
</span><span class="comment">--                                     "Template_MBT_T72B3",
</span><span class="comment">--                                   },
</span><span class="comment">--                            Supply  = {
</span><span class="comment">--                                     "Template_Supply_Kamaz",
</span><span class="comment">--                                     "Template_Supply_KrAZ",
</span><span class="comment">--                                     "Template_Supply_ZIL135",
</span><span class="comment">--                                   },
</span><span class="comment">--                          }
</span><span class="comment">--
</span><span class="comment">-- **Config**
</span><span class="comment">--
</span><span class="comment">--   *Contains general spawn configuration information for the dynamic spawner.*
</span><span class="comment">--
</span><span class="comment">--                   --- Config.UnitsMin = #integer,
</span><span class="comment">--                   --       *The minimum amount of Types the Dynamic Spawner is allowed to place.
</span><span class="comment">--                              ex. UnitsMin          = 30,
</span><span class="comment">--
</span><span class="comment">--                   --- Config.UnitsMax = #integer,
</span><span class="comment">--                   --       *The maximum amount of Types the Dynamic Spawner is allowed to place.
</span><span class="comment">--                              ex. UnitsMax          = 50,
</span><span class="comment">--
</span><span class="comment">--                   --- Config.LimitedSpawnStrings = #table
</span><span class="comment">--                   --       *These strings are searched for within the Type names of the Spawner.
</span><span class="comment">--                   --       *If a Type name contains any of these strings:
</span><span class="comment">--                   --           -The Dynamic Spawner will NEVER spawn more than the min specified
</span><span class="comment">--                   --           -@see SPECTRE.DYNAMIC_SPAWNER:AddLimitedSpawn()
</span><span class="comment">--                   --           -Useful for Types that can *drastically* change gameplay,
</span><span class="comment">--                   --                  *Eg. SAMS, AAA, MANPADS, SPAAA, etc.
</span><span class="comment">--                             ex. LimitedSpawnStrings = {"SAM_","AAA","MBT",},
</span><span class="comment">--
</span><span class="comment">--                   --- Config.TypeAmounts = #table
</span><span class="comment">--                   --       *The min and max of each Type allowed to be spawned.
</span><span class="comment">--                            ex. TypeAmounts.Type = {min = 5, max = 0}
</span><span class="comment">--                            ex. TypeAmounts.APC = {min = 5, max = 0}
</span><span class="comment">--     ---------------------------------------------------------------------------------
</span><span class="comment">--                   Config = {
</span><span class="comment">--                            UnitsMin          = 30,
</span><span class="comment">--                            UnitsMax          = 50,
</span><span class="comment">--                            LimitedSpawnStrings = {"SAM_","AAA","MBT",},
</span><span class="comment">--                            TypeAmounts = {
</span><span class="comment">--                                             APC             = {min = 5, max = 0},
</span><span class="comment">--                                             IFV             = {min = 3, max = 0},
</span><span class="comment">--                                             MBT             = {min = 3, max = 7},
</span><span class="comment">--                                             Supply          = {min = 3, max = 0},
</span><span class="comment">--                                           },
</span><span class="comment">--                         }
</span><span class="comment">--
</span><span class="comment">-- **ExtraTypes**
</span><span class="comment">--
</span><span class="comment">--   *Contains extra Types that the spawner must add to every generated group, and the amount of each type.*
</span><span class="comment">--
</span><span class="comment">--             --- Config.ExtraTypes = #table
</span><span class="comment">--             --       *The extra types and amount of each that the spawner adds to each group.
</span><span class="comment">--                           ex. ExtraTypes = {
</span><span class="comment">--                                              [1] = {
</span><span class="comment">--                                                      type = "Supply",
</span><span class="comment">--                                                      numtype = 2,
</span><span class="comment">--                                                    },
</span><span class="comment">--                                              [...] = {...},
</span><span class="comment">--                                              [n] = {
</span><span class="comment">--                                                      type = Type,
</span><span class="comment">--                                                      numtype = 1,
</span><span class="comment">--                                                    },
</span><span class="comment">--                                            }
</span><span class="comment">--
</span><span class="comment">--             --         Can be = {} or nil
</span><span class="comment">--                           ex. ExtraTypes = {}
</span><span class="comment">--                           ex. ExtraTypes = nil
</span><span class="comment">--
</span><span class="comment">--     ---------------------------------------------------------------------------------
</span><span class="comment">--                   ExtraTypes = {
</span><span class="comment">--                                  [1] = {
</span><span class="comment">--                                          type = "Supply",
</span><span class="comment">--                                          numtype = 2
</span><span class="comment">--                                        },
</span><span class="comment">--                                 }
</span><span class="comment">--
</span><span class="comment">--
</span><span class="comment">-- **Example spawnerConfig**
</span><span class="comment">--
</span><span class="comment">--   *An example that adds together all aspects shown above.*
</span><span class="comment">--
</span><span class="comment">--     spawnerConfig = {
</span><span class="comment">--                       ZoneNames = {
</span><span class="comment">--                                    Main = "Zone_Main",
</span><span class="comment">--                                    Sub = {"Zone_Sub-1", "Zone_Sub-2", "Zone_Sub-3",},
</span><span class="comment">--                                    Restricted = {
</span><span class="comment">--                                                   "Zone_Restricted-1",
</span><span class="comment">--                                                   "Zone_Restricted-2",
</span><span class="comment">--                                                   "Zone_Restricted-3",
</span><span class="comment">--                                                  },
</span><span class="comment">--                                    },
</span><span class="comment">--                       Config    = {
</span><span class="comment">--                                      UnitsMin                = 30,
</span><span class="comment">--                                      UnitsMax                = 50,
</span><span class="comment">--                                      LimitedSpawnStrings     = {"SAM_","AAA","MBT",},
</span><span class="comment">--                                      TypeAmounts = {
</span><span class="comment">--                                                      APC     = {min = 5, max = 0},
</span><span class="comment">--                                                      IFV     = {min = 3, max = 0},
</span><span class="comment">--                                                      MBT     = {min = 3, max = 7},
</span><span class="comment">--                                                      Supply  = {min = 3, max = 0},
</span><span class="comment">--                                                    },
</span><span class="comment">--                                    },
</span><span class="comment">--                       TypeTemplates = {
</span><span class="comment">--                                          APC     = {
</span><span class="comment">--                                                      "Template_APC_BTR80",
</span><span class="comment">--                                                      "Template_APC_MTLB",
</span><span class="comment">--                                                      "Template_APC_BTRRD",
</span><span class="comment">--                                                    },
</span><span class="comment">--                                          IFV     = {
</span><span class="comment">--                                                      "Template_IFV_Bradley",
</span><span class="comment">--                                                      "Template_IFV_Warrior",
</span><span class="comment">--                                                    },
</span><span class="comment">--                                          MBT     = {
</span><span class="comment">--                                                      "Template_MBT_T72B",
</span><span class="comment">--                                                      "Template_MBT_T72B3",
</span><span class="comment">--                                                    },
</span><span class="comment">--                                          Supply  = {
</span><span class="comment">--                                                      "Template_Supply_Kamaz",
</span><span class="comment">--                                                      "Template_Supply_KrAZ",
</span><span class="comment">--                                                      "Template_Supply_ZIL135",
</span><span class="comment">--                                                    },
</span><span class="comment">--                                      },
</span><span class="comment">--                       ExtraTypes   = {
</span><span class="comment">--                                         [1] = {
</span><span class="comment">--                                                 type = "Supply",
</span><span class="comment">--                                                 numtype = 2
</span><span class="comment">--                                               },
</span><span class="comment">--                                      },
</span><span class="comment">--                      }
</span><span class="comment">--
</span><span class="comment">--
</span><span class="comment">--  ===
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param ZoneNames : Table of Zone Names; for Main, Sub, and Restricted Zones. ex:
</span><span class="comment">--
</span><span class="comment">--     ZoneNames = {
</span><span class="comment">--                   Main = "Zone_Sukhumi",
</span><span class="comment">--                   Sub = {"Sukhumi-1", "Sukhumi-2", .., n,},
</span><span class="comment">--                   Restricted = { "Sukhumi_NG-1", "Sukhumi_NG-2", .., n,},
</span><span class="comment">--                 }
</span><span class="comment">--
</span><span class="comment">--       Main =      #string | Name of main ZONE_RADIUS containing all other zones.
</span><span class="comment">--       Sub =        #table | Table of strings. Names of all sub-ZONE_RADIUS used for spawn weighting.
</span><span class="comment">--       Restricted = #table | Table of strings. Names of all zones where units should NOT be spawned.
</span><span class="comment">--               ---&gt; "Restricted" REQUIRES A QUAD POINT ZONE DEFINED IN THE MISSION EDITOR
</span><span class="comment">--
</span><span class="comment">-- @param Config : Pre-Made Config Table. ex:
</span><span class="comment">--
</span><span class="comment">--     Config = {
</span><span class="comment">--               UnitsMin          = 30,
</span><span class="comment">--               UnitsMax          = 50,
</span><span class="comment">--               LimitedSpawnStrings = {"SAM_","AAA","MANPAD",},
</span><span class="comment">--               TypeAmounts = {
</span><span class="comment">--                               APC                = {min = 5, max = 0},
</span><span class="comment">--                               IFV                = {min = 3, max = 0},
</span><span class="comment">--                               Supply             = {min = 3, max = 0},
</span><span class="comment">--                               AAA                = {min = 2, max = 0},
</span><span class="comment">--                               SPAAA              = {min = 0, max = 0},
</span><span class="comment">--                               MANPAD             = {min = 0, max = 0},
</span><span class="comment">--                               SAM_Radar_Singles  = {min = 0, max = 0},
</span><span class="comment">--                             },
</span><span class="comment">--              }
</span><span class="comment">--
</span><span class="comment">--      UnitsMin = minimum number of types generated by the spawner
</span><span class="comment">--      UnitsMax = maximum number of types generated by the spawner
</span><span class="comment">--      LimitedSpawnStrings = table of strings to check if types contain. See function SPECTRE.DYNAMIC_SPAWNER:AddLimitedSpawn(string).
</span><span class="comment">--      TypeAmounts = Table of Min and Max amounts of each possible Type. Type name must match those provided in "Types" variable of this function. ex:
</span><span class="comment">--      TypeAmounts = {
</span><span class="comment">--                      ["TYPENAME"] = {min = 5, max = 0},
</span><span class="comment">--                       ..,
</span><span class="comment">--                       n,
</span><span class="comment">--                    }
</span><span class="comment">-- @param TypeTemplates : Table of Types to be used for the spawner. where the key is the Type Name. Ex:
</span><span class="comment">--
</span><span class="comment">--     TypeTemplates = {
</span><span class="comment">--               APC  = {"Template_APC_BTR80","Template_APC_MTLB",},
</span><span class="comment">--               IFV  = {"Template_IFV_BMD1",},
</span><span class="comment">--             }
</span><span class="comment">-- @param ExtraTypes :
</span><span class="comment">--
</span><span class="comment">--   *Contains extra Types that the spawner must add to every generated group, and the amount of each type.*
</span><span class="comment">--
</span><span class="comment">--             --- Config.ExtraTypes = #table
</span><span class="comment">--             --       *The extra types and amount of each that the spawner adds to each group.
</span><span class="comment">--                           ex. ExtraTypes = {
</span><span class="comment">--                                              [1] = {
</span><span class="comment">--                                                      type = "Supply",
</span><span class="comment">--                                                      numtype = 2,
</span><span class="comment">--                                                    },
</span><span class="comment">--                                              [...] = {...},
</span><span class="comment">--                                              [n] = {
</span><span class="comment">--                                                      type = Type,
</span><span class="comment">--                                                      numtype = 1,
</span><span class="comment">--                                                    },
</span><span class="comment">--                                            }
</span><span class="comment">--
</span><span class="comment">--             --         Can be = {} or nil
</span><span class="comment">--                           ex. ExtraTypes = {}
</span><span class="comment">--                           ex. ExtraTypes = nil
</span><span class="comment">--
</span><span class="comment">--     ---------------------------------------------------------------------------------
</span><span class="comment">--                   ExtraTypes = {
</span><span class="comment">--                                  [1] = {
</span><span class="comment">--                                          type = "Supply",
</span><span class="comment">--                                          numtype = 2
</span><span class="comment">--                                        },
</span><span class="comment">--                                 }
</span><span class="comment">--
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : self with config tables added from
</span><span class="comment">--
</span><span class="comment">--     self:ZoneAdd()
</span><span class="comment">--     self:AddType()
</span><span class="comment">--     self:SetTypeAmount()
</span><span class="comment">--     self:SetUnitAmounts()
</span><a id="635"></a><span class="comment">--     self:AddLimitedSpawn()
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:ConfigImport(ZoneNames, Config, TypeTemplates, ExtraTypes)
  <span class="comment">--local self=BASE:Inherit(self, BASE:New())
</span> <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>  <span class="keyword">for</span> _i = <span class="number">1</span>, #ZoneNames.Main, <span class="number">1</span> <span class="keyword">do</span>
    self:ZoneAdd(ZoneNames.Main, <span class="string">"main"</span>)
  <span class="keyword">end</span>
  <span class="keyword">for</span> _i = <span class="number">1</span>, #ZoneNames.Sub, <span class="number">1</span> <span class="keyword">do</span>
    self:ZoneAdd(ZoneNames.Sub[_i], <span class="string">"sub"</span>)
  <span class="keyword">end</span>
  <span class="keyword">for</span> _i = <span class="number">1</span>, #ZoneNames.Restricted, <span class="number">1</span> <span class="keyword">do</span>
    self:ZoneAdd(ZoneNames.Restricted[_i], <span class="string">"restricted"</span>)
  <span class="keyword">end</span>
  <span class="keyword">for</span> _k, _v <span class="keyword">in</span> <span class="global">pairs</span>(TypeTemplates) <span class="keyword">do</span>
    self:AddType(_k, TypeTemplates[_k])
  <span class="keyword">end</span>
  <span class="keyword">for</span> _k, _v <span class="keyword">in</span> <span class="global">pairs</span>(Config.TypeAmounts) <span class="keyword">do</span>
    self:SetTypeAmount(_k, Config.TypeAmounts[_k].min, Config.TypeAmounts[_k].max)
  <span class="keyword">end</span>
  self:SetUnitAmounts(Config.UnitsMin, Config.UnitsMax)
  <span class="keyword">for</span> _i = <span class="number">1</span>, #Config.LimitedSpawnStrings, <span class="number">1</span> <span class="keyword">do</span>
    self:AddLimitedSpawn(Config.LimitedSpawnStrings[_i])
  <span class="keyword">end</span>
  self:AddExtraTypesToGroups(ExtraTypes)
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - ConfigImport() - self"</span>)
    BASE:E(self)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Triggers the Generation of the Dynamic Spawner.
</span><span class="comment">--
</span><span class="comment">--      Sets up "multithreading" (co-routines) for operation,
</span><span class="comment">--      schedulers related to the coroutine,
</span><span class="comment">--      then starts the SPECTRE.DYNAMIC_SPAWNER.GenerationProcess
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : if generation completes, returns self with:
</span><span class="comment">--
</span><span class="comment">--      self.Co_MultiGenerate = nil
</span><span class="comment">--      self.GenerationComplete = true
</span><span class="comment">-- Otherwise,
</span><span class="comment">--
</span><span class="comment">--      self.Co_MultiGenerate = the coroutine
</span><a id="679"></a><span class="comment">--      self.GenerationComplete = false
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:Generate()
 <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.Generate = {
      Time = {},
    }
    self.DebugLog.Generate.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>
  self.GenerationComplete = <span class="keyword">false</span>
  self.GenerationInProgress = <span class="keyword">true</span>
  self:GenerationProcess()
  self.GenerationComplete = <span class="keyword">true</span>
  self.GenerationInProgress = <span class="keyword">false</span>
  <span class="comment">--  if self.Co_MultiGenerate == nil then
</span>  <span class="comment">--    self.Co_MultiGenerate = coroutine.create(self.GenerationProcess)--SPECTRE.DYNAMIC_SPAWNER.GenerationProcess)
</span>  <span class="comment">--  elseif coroutine.status(self.Co_MultiGenerate) == "dead" then
</span>  <span class="comment">--    self.GenerationComplete = true
</span>  <span class="comment">--  end
</span>  <span class="comment">--  self.Co_MultiGenerate_Scheduler = SCHEDULER:New(nil, function(self)
</span>  <span class="comment">--    if self.DebugEnabled == 1 then
</span>  <span class="comment">--      BASE:E("SPECTRE|DYNAMIC_SPAWNER - Generate() - self.Co_MultiGenerate_Scheduler")
</span>  <span class="comment">--      BASE:E(self.Co_MultiGenerate_Scheduler)
</span>  <span class="comment">--    end
</span>  <span class="comment">--    if coroutine.status(self.Co_MultiGenerate) == "suspended" then
</span>  <span class="comment">--      coroutine.resume(self.Co_MultiGenerate, self)
</span>  <span class="comment">--    end
</span>  <span class="comment">--    if coroutine.status(self.Co_MultiGenerate) == "dead" then
</span>  <span class="comment">--      self.GenerationComplete = true
</span>  <span class="comment">--      self.Co_MultiGenerate_Scheduler:Stop()
</span>  <span class="comment">--      self.Co_MultiGenerate_Scheduler = nil
</span>  <span class="comment">--    end
</span>  <span class="comment">--    if self.GenerationComplete == true then
</span>  <span class="comment">--      if self.DebugEnabled == 1 then
</span>  <span class="comment">--        self.DebugLog.Generate.Time.stop = os.clock()
</span>  <span class="comment">--        BASE:E("SPECTRE|DYNAMIC_SPAWNER - Generate Complete - Time: ".. self.DebugLog.Generate.Time.stop - self.DebugLog.Generate.Time.start)
</span>  <span class="comment">--      end
</span>  <span class="comment">--      self.Co_MultiGenerate = nil
</span>  <span class="comment">--      self.GenerationComplete = true
</span>  <span class="comment">--      self.GenerationInProgress = false
</span>  <span class="comment">--      return self
</span>  <span class="comment">--    end
</span>  <span class="comment">--  end, {self}, 1, self.Config.operationInterval)
</span>  <span class="keyword">return</span> self
<span class="keyword">end</span>
<span class="comment">--function SPECTRE.DYNAMIC_SPAWNER:Generate()
</span><span class="comment">-- -- local DEBUG = false or self.DebugEnabled
</span><span class="comment">--  if self.DebugEnabled == 1 then
</span><span class="comment">--    self.DebugLog.Generate = {
</span><span class="comment">--      Time = {},
</span><span class="comment">--    }
</span><span class="comment">--    self.DebugLog.Generate.Time.start = os.clock()
</span><span class="comment">--  end
</span><span class="comment">--  self.GenerationComplete = false
</span><span class="comment">--  self.GenerationInProgress = true
</span><span class="comment">--  if self.Co_MultiGenerate == nil then
</span><span class="comment">--    self.Co_MultiGenerate = coroutine.create(self.GenerationProcess)--SPECTRE.DYNAMIC_SPAWNER.GenerationProcess)
</span><span class="comment">--  elseif coroutine.status(self.Co_MultiGenerate) == "dead" then
</span><span class="comment">--    self.GenerationComplete = true
</span><span class="comment">--  end
</span><span class="comment">--  self.Co_MultiGenerate_Scheduler = SCHEDULER:New(nil, function(self)
</span><span class="comment">--    if self.DebugEnabled == 1 then
</span><span class="comment">--      BASE:E("SPECTRE|DYNAMIC_SPAWNER - Generate() - self.Co_MultiGenerate_Scheduler")
</span><span class="comment">--      BASE:E(self.Co_MultiGenerate_Scheduler)
</span><span class="comment">--    end
</span><span class="comment">--    if coroutine.status(self.Co_MultiGenerate) == "suspended" then
</span><span class="comment">--      coroutine.resume(self.Co_MultiGenerate, self)
</span><span class="comment">--    end
</span><span class="comment">--    if coroutine.status(self.Co_MultiGenerate) == "dead" then
</span><span class="comment">--      self.GenerationComplete = true
</span><span class="comment">--      self.Co_MultiGenerate_Scheduler:Stop()
</span><span class="comment">--      self.Co_MultiGenerate_Scheduler = nil
</span><span class="comment">--    end
</span><span class="comment">--    if self.GenerationComplete == true then
</span><span class="comment">--      if self.DebugEnabled == 1 then
</span><span class="comment">--        self.DebugLog.Generate.Time.stop = os.clock()
</span><span class="comment">--        BASE:E("SPECTRE|DYNAMIC_SPAWNER - Generate Complete - Time: ".. self.DebugLog.Generate.Time.stop - self.DebugLog.Generate.Time.start)
</span><span class="comment">--      end
</span><span class="comment">--      self.Co_MultiGenerate = nil
</span><span class="comment">--      self.GenerationComplete = true
</span><span class="comment">--      self.GenerationInProgress = false
</span><span class="comment">--      return self
</span><span class="comment">--    end
</span><span class="comment">--  end, {self}, 1, self.Config.operationInterval)
</span><span class="comment">--  return self
</span><span class="comment">--end
</span>
<span class="comment">---Configuration.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with configuration of the DYNAMIC_SPAWNER class.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">--  **DYNAMIC_SPAWNER Configuration Template**
</span><span class="comment">--
</span><span class="comment">--  As seen in the above "*Basic Use*" example, the DYNAMIC_SPAWNER Config was the table ***spawnerConfig***,
</span><span class="comment">--
</span><span class="comment">--     local spawnerConfig = {
</span><span class="comment">--                             ZoneNames     = {...},
</span><span class="comment">--                             Config        = {...},
</span><span class="comment">--                             TypeTemplates = {...},
</span><span class="comment">--                             ExtraTypes    = {...},
</span><span class="comment">--                            }
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- **The table 'spawnerConfig' has 4 sub-tables:**
</span><span class="comment">--
</span><span class="comment">--     ZoneNames     = {...},
</span><span class="comment">--     Config        = {...},
</span><span class="comment">--     TypeTemplates = {...},
</span><span class="comment">--     ExtraTypes    = {...},
</span><span class="comment">--
</span><span class="comment">-- *where*
</span><span class="comment">--
</span><span class="comment">-- **ZoneNames**
</span><span class="comment">--
</span><span class="comment">--   *Contains all zone names for the spawner to work with (Main, Sub, and Restricted).*
</span><span class="comment">--
</span><span class="comment">--      --- Restricted.Main = #string
</span><span class="comment">--      --            *The main zone of the dynamic spawner.
</span><span class="comment">--      --            *All other zones are contained within it.
</span><span class="comment">--                      ex. Main = "Zone_Main",
</span><span class="comment">--
</span><span class="comment">--      --- Restricted.Sub = #table
</span><span class="comment">--      --            *All sub zones of the dynamic spawner
</span><span class="comment">--      --            *Used for weighting location probability of type group clusters.
</span><span class="comment">--                      ex. Sub = {"Zone_Sub-1",
</span><span class="comment">--                                 "Zone_Sub-2",
</span><span class="comment">--                                 "Zone_Sub-3",},
</span><span class="comment">--
</span><span class="comment">--      --- Restricted.Restricted = #table
</span><span class="comment">--      --            *All restricted zones of the dynamic spawner.
</span><span class="comment">--      --            *Prevents spawning of any Type within any restricted zone.
</span><span class="comment">--                      ex. Restricted = {"Zone_Restricted-1",
</span><span class="comment">--                                        "Zone_Restricted-2",
</span><span class="comment">--                                        "Zone_Restricted-3",},
</span><span class="comment">--      --         Can be = {} or nil
</span><span class="comment">--                      ex. Restricted = {}
</span><span class="comment">--                      ex. Restricted = nil
</span><span class="comment">--     ---------------------------------------------------------------------------------
</span><span class="comment">--      ZoneNames = {
</span><span class="comment">--                    Main = "Zone_Main",
</span><span class="comment">--                    Sub = {"Zone_Sub-1", "Zone_Sub-2", "Zone_Sub-3",},
</span><span class="comment">--                    Restricted = {
</span><span class="comment">--                                   "Zone_Restricted-1",
</span><span class="comment">--                                   "Zone_Restricted-2",
</span><span class="comment">--                                   "Zone_Restricted-3",
</span><span class="comment">--                                 },
</span><span class="comment">--                  }
</span><span class="comment">--
</span><span class="comment">-- **TypeTemplates**
</span><span class="comment">--
</span><span class="comment">--   *Contains the Types the dynamic spawner will have access to, and their corresponding Mission Editor Template Group Names.*
</span><span class="comment">--
</span><span class="comment">--      --- Type: The defined term for the 'type' of unit you are spawning.
</span><span class="comment">--      --      In these examples, Types are grouped by the 'type' of object.
</span><span class="comment">--                  eg. Type = APC, IFV, MBT, Supply
</span><span class="comment">--      --      These can be anything you want.
</span><span class="comment">--                  eg. Type = Type1, Yellow, Train, Cow
</span><span class="comment">--      --      In TypeTemplates below, Type can be seen as:
</span><span class="comment">--                      TypeTemmplates.Type   = {...}
</span><span class="comment">--
</span><span class="comment">--                      TypeTemmplates.APC    = {...}
</span><span class="comment">--                      TypeTemmplates.IFV    = {...}
</span><span class="comment">--                      TypeTemmplates.MBT    = {...}
</span><span class="comment">--                      TypeTemmplates.Supply = {...}
</span><span class="comment">--
</span><span class="comment">--      --- Templates: The defined group name for the 'template' of type you are spawning.
</span><span class="comment">--      --       These must match a group name in the mission editor, late activated.
</span><span class="comment">--      --       The groups can be any number of units, but will only count as 1 'Type'.
</span><span class="comment">--
</span><span class="comment">--      --      eg. 2 groups in the mission editor with:
</span><span class="comment">--                             groupname1 = "exGroupName1"
</span><span class="comment">--                             1 Unit in group
</span><span class="comment">--                             groupname2 = "exGroupName2"
</span><span class="comment">--                             3 Units in group
</span><span class="comment">--
</span><span class="comment">--      --       Even though each group has a different number of units,
</span><span class="comment">--      --       each group only counts as 1 'Type' to the Dynamic Spawner.
</span><span class="comment">--      --
</span><span class="comment">--      --       So if UnitsMin = 5, that means the spawner will spawn 5 types minimum.
</span><span class="comment">--      --
</span><span class="comment">--      --       Because the above example 'groupname1' is 1 units per 'Type'
</span><span class="comment">--      --       the spawner would place 5 units minimum.
</span><span class="comment">--      --       While because the above example 'groupname2' is 3 units per 'Type'
</span><span class="comment">--      --       the spawner would place 15 units minimum.
</span><span class="comment">--      --
</span><span class="comment">--      --  In these examples:
</span><span class="comment">--      --     Templates are 1 placed unit per group in the Mission editor.
</span><span class="comment">--      --     The Template ME group name matches below 'Templates'.
</span><span class="comment">--      --
</span><span class="comment">--      --     Templates are grouped by the 'type' of object.
</span><span class="comment">--               eg. Type = Template
</span><span class="comment">--               eg. TypeTemmplates.IFV = {"Template_IFV_Bradley","Template_IFV_Warrior",}
</span><span class="comment">--
</span><span class="comment">--      --     In TypeTemplates below, Templates can be seen as:
</span><span class="comment">--                   TypeTemmplates.Type  = Templates
</span><span class="comment">--                   TypeTemmplates.IFV    = {
</span><span class="comment">--                                             "Template_IFV_Bradley",
</span><span class="comment">--                                              "Template_IFV_Warrior",
</span><span class="comment">--                                           }
</span><span class="comment">--     ---------------------------------------------------------------------------------
</span><span class="comment">--      TypeTemplates = {
</span><span class="comment">--                        APC  = {
</span><span class="comment">--                                 "Template_APC_BTR80",
</span><span class="comment">--                                 "Template_APC_MTLB",
</span><span class="comment">--                                 "Template_APC_BTRRD",
</span><span class="comment">--                               },
</span><span class="comment">--                        IFV  = {
</span><span class="comment">--                                 "Template_IFV_Bradley",
</span><span class="comment">--                                 "Template_IFV_Warrior",
</span><span class="comment">--                               },
</span><span class="comment">--                        MBT  = {
</span><span class="comment">--                                 "Template_MBT_T72B",
</span><span class="comment">--                                 "Template_MBT_T72B3",
</span><span class="comment">--                               },
</span><span class="comment">--                        Supply  = {
</span><span class="comment">--                                 "Template_Supply_Kamaz",
</span><span class="comment">--                                 "Template_Supply_KrAZ",
</span><span class="comment">--                                 "Template_Supply_ZIL135",
</span><span class="comment">--                               },
</span><span class="comment">--                      }
</span><span class="comment">--
</span><span class="comment">-- **Config**
</span><span class="comment">--
</span><span class="comment">--   *Contains general spawn configuration information for the dynamic spawner.*
</span><span class="comment">--
</span><span class="comment">--      --- Config.UnitsMin = #integer,
</span><span class="comment">--      --       *The minimum amount of Types the Dynamic Spawner is allowed to place.
</span><span class="comment">--                 ex. UnitsMin          = 30,
</span><span class="comment">--
</span><span class="comment">--      --- Config.UnitsMax = #integer,
</span><span class="comment">--      --       *The maximum amount of Types the Dynamic Spawner is allowed to place.
</span><span class="comment">--                 ex. UnitsMax          = 50,
</span><span class="comment">--
</span><span class="comment">--      --- Config.LimitedSpawnStrings = #table
</span><span class="comment">--      --       *These strings are searched for within the Type names of the Spawner.
</span><span class="comment">--      --       *If a Type name contains any of these strings:
</span><span class="comment">--      --       -The Dynamic Spawner will NEVER spawn more than the min specified
</span><span class="comment">--      --       -@see SPECTRE.DYNAMIC_SPAWNER:AddLimitedSpawn()
</span><span class="comment">--      --       -Useful for Types that can *drastically* change gameplay,
</span><span class="comment">--      --              *Eg. SAMS, AAA, MANPADS, SPAAA, etc.
</span><span class="comment">--                ex. LimitedSpawnStrings = {"SAM_","AAA","MBT",},
</span><span class="comment">--
</span><span class="comment">--      --- Config.TypeAmounts = #table
</span><span class="comment">--      --       *The min and max of each Type allowed to be spawned.
</span><span class="comment">--               ex. TypeAmounts.Type = {min = 5, max = 0}
</span><span class="comment">--               ex. TypeAmounts.APC  = {min = 5, max = 0}
</span><span class="comment">--     ---------------------------------------------------------------------------------
</span><span class="comment">--      Config = {
</span><span class="comment">--               UnitsMin            = 30,
</span><span class="comment">--               UnitsMax            = 50,
</span><span class="comment">--               LimitedSpawnStrings = {"SAM_","AAA","MBT",},
</span><span class="comment">--               TypeAmounts = {
</span><span class="comment">--                                APC             = {min = 5, max = 0},
</span><span class="comment">--                                IFV             = {min = 3, max = 0},
</span><span class="comment">--                                MBT             = {min = 3, max = 7},
</span><span class="comment">--                                Supply          = {min = 3, max = 0},
</span><span class="comment">--                              },
</span><span class="comment">--            }
</span><span class="comment">--
</span><span class="comment">-- **ExtraTypes**
</span><span class="comment">--
</span><span class="comment">--   *Contains extra Types that the spawner must add to every generated group, and the amount of each type.*
</span><span class="comment">--
</span><span class="comment">--         --- Config.ExtraTypes = #table
</span><span class="comment">--         --       *The extra types and amount of each that the spawner adds to each group.
</span><span class="comment">--                       ex. ExtraTypes = {
</span><span class="comment">--                                          [1] = {
</span><span class="comment">--                                                  type = "Supply",
</span><span class="comment">--                                                  numtype = 2,
</span><span class="comment">--                                                },
</span><span class="comment">--                                          [...] = {...},
</span><span class="comment">--                                          [n] = {
</span><span class="comment">--                                                  type = Type,
</span><span class="comment">--                                                  numtype = 1,
</span><span class="comment">--                                                },
</span><span class="comment">--                                        }
</span><span class="comment">--
</span><span class="comment">--         --         Can be = {} or nil
</span><span class="comment">--                       ex. ExtraTypes = {}
</span><span class="comment">--                       ex. ExtraTypes = nil
</span><span class="comment">--
</span><span class="comment">--     ---------------------------------------------------------------------------------
</span><span class="comment">--               ExtraTypes = {
</span><span class="comment">--                              [1] = {
</span><span class="comment">--                                      type = "Supply",
</span><span class="comment">--                                      numtype = 2
</span><span class="comment">--                                    },
</span><span class="comment">--                             }
</span><span class="comment">--
</span><span class="comment">--
</span><span class="comment">-- **Example spawnerConfig**
</span><span class="comment">--
</span><span class="comment">--   *An example that adds together all aspects shown above.*
</span><span class="comment">--
</span><span class="comment">--     spawnerConfig = {
</span><span class="comment">--                       ZoneNames = {
</span><span class="comment">--                                    Main = "Zone_Main",
</span><span class="comment">--                                    Sub = {"Zone_Sub-1", "Zone_Sub-2", "Zone_Sub-3",},
</span><span class="comment">--                                    Restricted = {
</span><span class="comment">--                                                   "Zone_Restricted-1",
</span><span class="comment">--                                                   "Zone_Restricted-2",
</span><span class="comment">--                                                   "Zone_Restricted-3",
</span><span class="comment">--                                                  },
</span><span class="comment">--                                    },
</span><span class="comment">--                       Config    = {
</span><span class="comment">--                                      UnitsMin                = 30,
</span><span class="comment">--                                      UnitsMax                = 50,
</span><span class="comment">--                                      LimitedSpawnStrings     = {"SAM_","AAA","MBT",},
</span><span class="comment">--                                      TypeAmounts = {
</span><span class="comment">--                                                      APC     = {min = 5, max = 0},
</span><span class="comment">--                                                      IFV     = {min = 3, max = 0},
</span><span class="comment">--                                                      MBT     = {min = 3, max = 7},
</span><span class="comment">--                                                      Supply  = {min = 3, max = 0},
</span><span class="comment">--                                                    },
</span><span class="comment">--                                    },
</span><span class="comment">--                       TypeTemplates = {
</span><span class="comment">--                                          APC     = {
</span><span class="comment">--                                                      "Template_APC_BTR80",
</span><span class="comment">--                                                      "Template_APC_MTLB",
</span><span class="comment">--                                                      "Template_APC_BTRRD",
</span><span class="comment">--                                                    },
</span><span class="comment">--                                          IFV     = {
</span><span class="comment">--                                                      "Template_IFV_Bradley",
</span><span class="comment">--                                                      "Template_IFV_Warrior",
</span><span class="comment">--                                                    },
</span><span class="comment">--                                          MBT     = {
</span><span class="comment">--                                                      "Template_MBT_T72B",
</span><span class="comment">--                                                      "Template_MBT_T72B3",
</span><span class="comment">--                                                    },
</span><span class="comment">--                                          Supply  = {
</span><span class="comment">--                                                      "Template_Supply_Kamaz",
</span><span class="comment">--                                                      "Template_Supply_KrAZ",
</span><span class="comment">--                                                      "Template_Supply_ZIL135",
</span><span class="comment">--                                                    },
</span><span class="comment">--                                      },
</span><span class="comment">--                       ExtraTypes   = {
</span><span class="comment">--                                         [1] = {
</span><span class="comment">--                                                 type = "Supply",
</span><span class="comment">--                                                 numtype = 2
</span><span class="comment">--                                               },
</span><span class="comment">--                                      },
</span><span class="comment">--                      }
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section Configuration
</span>
<span class="comment">--- Parses imported configs for the SPECTRE.DYNAMIC_SPAWNER.
</span><span class="comment">--
</span><span class="comment">-- Allows config to be used by the spawner.
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self
</span><span class="comment">--
</span><span class="comment">--     self with added tables:
</span><span class="comment">--
</span><span class="comment">--     self.ParsedTypes = Usable final step. Contains relevant LimitedTypes &amp; UnLimitedTypes in a single entry.
</span><span class="comment">--          not passed to self --&gt;    LimitedTypes = Types that have a limit associated with amount spawned
</span><span class="comment">--          not passed to self --&gt;    UnLimitedTypes = Types that DO NOT have a limit associated with amount spawned
</span><span class="comment">--     self.ParsedTypes.limited = 0 or 1
</span><span class="comment">--     All above types have a ".limited" value associated with them.
</span><span class="comment">--     0 = unlimited spawn
</span><a id="1043"></a><span class="comment">--     1 = has a limit associated with the amount spawned
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:ConfigParse()
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.ConfigParse = {Time = {}}
    self.DebugLog.ConfigParse.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>
  <span class="keyword">local</span> configParsedTypes = {}
  <span class="keyword">local</span> configTypes = self.Config.Types
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - ConfigParse - configTypes"</span>)
    BASE:E(configTypes)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - ConfigParse - self"</span>)
    BASE:E(self)
  <span class="keyword">end</span>
  <span class="keyword">for</span> typeName, typeData <span class="keyword">in</span> <span class="global">pairs</span>(configTypes) <span class="keyword">do</span>
    <span class="keyword">if</span> typeData.amounts.min ~= <span class="number">0</span> <span class="keyword">then</span>
      <span class="keyword">local</span> isLimited = <span class="keyword">false</span>
      <span class="keyword">for</span> i = <span class="number">1</span>, #self.Config.LimitedSpawnStrings <span class="keyword">do</span>
        <span class="keyword">if</span> <span class="global">string</span>.find(typeName, self.Config.LimitedSpawnStrings[i]) <span class="keyword">then</span>
          isLimited = <span class="keyword">true</span>
          <span class="keyword">break</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span>
      typeData.limited = isLimited <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">0</span>
      configParsedTypes[typeName] = typeData
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  self.ParsedTypes = configParsedTypes

  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.ConfigParse.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER: ConfigParse - Time: "</span> .. self.DebugLog.ConfigParse.Time.stop - self.DebugLog.ConfigParse.Time.start)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - ConfigParse - self.LimitedTypes"</span>)
    BASE:E(self.LimitedTypes)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - ConfigParse - self.UnLimitedTypes"</span>)
    BASE:E(self.UnLimitedTypes)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - ConfigParse - self.ParsedTypes"</span>)
    BASE:E(self.ParsedTypes)
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Adds a Type to the SPECTRE.DYNAMIC_SPAWNER Object.
</span><span class="comment">--
</span><span class="comment">-- Also adds a namesList for all Type related Templates.
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param typeName The name of the spawner Type to be added. Ex:
</span><span class="comment">--
</span><span class="comment">--      typeName = "LBT"
</span><span class="comment">-- @param namesList List of all groupnames defined in Mission Editor for the specified Type. Ex:
</span><span class="comment">--
</span><span class="comment">--      namesList = { "Template_LBT_PT76","Template_LBT_Sherman","Template_LBT_Pz4",}
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self
</span><span class="comment">--
</span><span class="comment">-- DYNAMIC_SPAWNER Object with new table:
</span><span class="comment">--
</span><span class="comment">--     self.Config.Types[typeName]
</span><span class="comment">-- @usage
</span><span class="comment">-- local typeName = "LBT"
</span><span class="comment">-- local namesList = { "Template_LBT_PT76","Template_LBT_Sherman","Template_LBT_Pz4",}
</span><span class="comment">-- local spawnerObject = SPECTRE.DYNAMIC_SPAWNER:New()
</span><span class="comment">-- spawnerObject:AddType(typeName, namesList)
</span><span class="comment">-- -- results in:
</span><span class="comment">-- spawnerObject.Config.Types[typeName] = {
</span><span class="comment">--                                           names = namesList,
</span><span class="comment">--                                           amounts = {min = 0, max = 0},
</span><a id="1112"></a><span class="comment">--                                         }
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:AddType(typeName, namesList)
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.AddType = {Time = {}}
    self.DebugLog.AddType.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>
  self.Config.Types[typeName] = {
    names = namesList,
    amounts = { min = <span class="number">0</span>, max = <span class="number">0</span> }
  }
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.AddType.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - AddType - Time: "</span> .. self.DebugLog.AddType.Time.stop - self.DebugLog.AddType.Time.start)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - AddType - self.Config.Types[typeName]"</span>)
    BASE:E(self.Config.Types[typeName])
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Force adds the specified extra types to  all spawned groups.
</span><span class="comment">--
</span><span class="comment">-- Keep in mind that this in ADDED to normal generation totals.
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param nTypes : Config Table for types that are going to be force added to each group.
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self
</span><span class="comment">--
</span><span class="comment">-- DYNAMIC_SPAWNER Object with new tables:
</span><span class="comment">--
</span><span class="comment">--     self.ExtraTypesToGroups = nTypes
</span><span class="comment">--     self.Config.numExtraTypes =  total number of extra spawner type categories to force add to groups
</span><span class="comment">--     self.Config.numExtraUnits = Total number of individual types to be added summed from all types categories.
</span><span class="comment">-- @usage
</span><span class="comment">-- nTypes = {
</span><span class="comment">--            [1] = {
</span><span class="comment">--                     type = "Supply",
</span><span class="comment">--                     numtype = 2
</span><span class="comment">--                   },
</span><span class="comment">--                .. = ..,
</span><span class="comment">--            [n] = {
</span><span class="comment">--                     type = "TypeName",
</span><span class="comment">--                     numtype = number
</span><span class="comment">--                  },
</span><span class="comment">--           }
</span><span class="comment">--    where
</span><span class="comment">-- type = "TypeName" : #string : name of the spawner type.
</span><span class="comment">-- numtype = number : #integer : How many of the type to force add to each generated group.
</span><span class="comment">--
</span><span class="comment">-- DYNAMIC_SPAWNER_OBJECT:AddExtraTypesToGroups(nTypes)
</span><span class="comment">-- returns self
</span><span class="comment">--     DYNAMIC_SPAWNER_OBJECT.ExtraTypesToGroups = nTypes
</span><span class="comment">--     DYNAMIC_SPAWNER_OBJECT.Config.numExtraTypes =  total number of extra spawner type categories to force add to groups
</span><a id="1164"></a><span class="comment">--     DYNAMIC_SPAWNER_OBJECT.Config.numExtraUnits = Total number of individual types to be added summed from all types categories.
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:AddExtraTypesToGroups(nTypes)
  self.ExtraTypesToGroups = nTypes
  <span class="keyword">if</span> self.ExtraTypesToGroups ~= <span class="keyword">nil</span> <span class="keyword">then</span>
    self.Config.numExtraTypes = #self.ExtraTypesToGroups
    self.Config.numExtraUnits = <span class="number">0</span>
    <span class="keyword">for</span> i = <span class="number">1</span>, self.Config.numExtraTypes <span class="keyword">do</span>
      self.Config.numExtraUnits = self.Config.numExtraUnits + self.ExtraTypesToGroups[i].numtype
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Adds the given string to the list of limited spawn types.
</span><span class="comment">--
</span><span class="comment">-- Limited Spawn Type = a spawner Type that is not allowed to be used for blanket fill.
</span><span class="comment">--
</span><span class="comment">-- When the desired min number of the type spawned is reached, it will remove the type from any future chosen type.
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param string : string to be added to the limited types.
</span><span class="comment">--
</span><span class="comment">-- CAUTION : GOOD NAMING CONVENTION
</span><span class="comment">--
</span><span class="comment">-- All type names will be searched for the given string. eg:
</span><span class="comment">--
</span><span class="comment">--     if string == "AAA" and there are 3 types:
</span><span class="comment">--     {"AAA", "SPAAA", "Supply"}, then,
</span><span class="comment">--     because types 1 &amp; 2 contain string "AAA",
</span><span class="comment">--     they will be limited to the minimum specified amount
</span><span class="comment">--
</span><span class="comment">-- @return DYNAMIC_SPAWNER self, new tables added:
</span><span class="comment">--
</span><a id="1197"></a><span class="comment">--     self.Config.LimitedSpawnStrings[#self.Config.LimitedSpawnStrings + 1] = string
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:AddLimitedSpawn(str)
  <span class="global">table</span>.insert(self.Config.LimitedSpawnStrings, str)
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - AddLimitedSpawn - self.Config.LimitedSpawnStrings"</span>)
    BASE:E(self.Config.LimitedSpawnStrings)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Adds a zone to the Dynamic Spawner.
</span><span class="comment">--
</span><span class="comment">-- Main, Sub, or Restricted.
</span><span class="comment">--
</span><span class="comment">--@param #DYNAMIC_SPAWNER self
</span><span class="comment">--@param ZoneName : #string, name of the zone
</span><span class="comment">--@param Type : #string, type of zone. Options are:
</span><span class="comment">--
</span><span class="comment">--      "main" -------- overall encompassing zone
</span><span class="comment">--                    - ZONE_RADIUS
</span><span class="comment">--      "sub"  -------- sub-zones within the main zone.
</span><span class="comment">--                    - ZONE_RADIUS
</span><span class="comment">--      "restricted" -- zones where Types are not allowed to be spawned
</span><span class="comment">--                    - QUAD POINT ZONE
</span><span class="comment">--                    - Defined in Mission Editor
</span><span class="comment">--
</span><span class="comment">--@return #DYNAMIC_SPAWNER self : self with tables added for
</span><span class="comment">--
</span><span class="comment">--         self.Zones.Main
</span><span class="comment">--         self.Zones.Sub[#]
</span><span class="comment">--         self.Zones.Restricted[#]
</span><span class="comment">-- where for .Main and .Sub[#]
</span><span class="comment">--
</span><span class="comment">--         self.Zones.Main   = {
</span><span class="comment">--           or
</span><span class="comment">--         self.Zones.Sub[#] = {
</span><span class="comment">--                                name = ZoneName
</span><span class="comment">--                                DistanceFromBuildings = self.Config.GroupSpacingSettings.General.DistanceFromBuildings
</span><span class="comment">--                              }
</span><span class="comment">-- and
</span><span class="comment">--
</span><a id="1238"></a><span class="comment">--        self.Zones.Restricted[#] = ZoneName
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:ZoneAdd(ZoneName, Type)
  <span class="keyword">if</span> Type == <span class="string">"main"</span> <span class="keyword">then</span>
    self.Zones.Main = {
      name = ZoneName,
      DistanceFromBuildings = self.Config.GroupSpacingSettings.General.DistanceFromBuildings,
    }
  <span class="keyword">elseif</span> Type == <span class="string">"sub"</span> <span class="keyword">then</span>
    <span class="global">table</span>.insert(self.Zones.Sub, {
      name = ZoneName,
      DistanceFromBuildings = self.Config.GroupSpacingSettings.General.DistanceFromBuildings,
    })
  <span class="keyword">elseif</span> Type == <span class="string">"restricted"</span> <span class="keyword">then</span>
    <span class="global">table</span>.insert(self.Zones.Restricted, ZoneName)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">---Sets the limits for amounts of units (Template Types).
</span><span class="comment">--
</span><span class="comment">-- Totals, Max and Min for possible spawned types.
</span><span class="comment">--
</span><span class="comment">--@param #DYNAMIC_SPAWNER self
</span><span class="comment">--@param min : minimum amount of Template Types (units)
</span><span class="comment">--@param max : maximum amount of Template Types (units)
</span><span class="comment">--@return #DYNAMIC_SPAWNER self : self with tables added for .UnitsMin, .UnitsMax
</span><span class="comment">--
</span><span class="comment">--        self.Config.UnitsMin = min
</span><a id="1266"></a><span class="comment">--        self.Config.UnitsMax = max
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:SetUnitAmounts(min, max)
  max = max <span class="keyword">or</span> <span class="number">0</span>
  self.Config.UnitsMin = min
  self.Config.UnitsMax = max
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">---Sets the amounts for each type.
</span><span class="comment">--
</span><span class="comment">-- Sets min and max for specific type.
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param typeName : Name of the Type to set amounts for:
</span><span class="comment">--
</span><span class="comment">--       typeName = "Supply"
</span><span class="comment">-- @param min : Minimum amount of the Type allowed:
</span><span class="comment">-- @param max : Maximum amount of the Type allowed:
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : self with added tables for
</span><span class="comment">--
</span><span class="comment">--        self.Config.Types[typeName].amounts.min = min
</span><span class="comment">--        self.Config.Types[typeName].amounts.max = max
</span><a id="1288"></a><span class="comment">--        self.Config.Types[typeName].amounts.numUsed = 0
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:SetTypeAmount(typeName, min, max)
  max = max <span class="keyword">or</span> <span class="number">0</span>
  self.Config.Types[typeName].amounts.min = min
  self.Config.Types[typeName].amounts.max = max
  self.Config.Types[typeName].amounts.numUsed = <span class="number">0</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">---Advanced Use.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with advanced use of the DYNAMIC_SPAWNER class.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section Advanced Use
</span>
<span class="comment">---Enables outputting Debug information for all functions to the DCS.log.
</span><span class="comment">--
</span><span class="comment">--      Simply calling :EnableDebugLog() enables the debug log.
</span><span class="comment">--      To disable, call :EnableDebugLog(false)
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param value : argument: nil, true, false
</span><span class="comment">--
</span><span class="comment">--      If provided with false, disables Debug log.
</span><span class="comment">--            ex: :EnableDebugLog(false)
</span><span class="comment">--      If provided with true or ommitted, enables Debug log.
</span><span class="comment">--            ex: :EnableDebugLog(true)
</span><span class="comment">--            ex: :EnableDebugLog()
</span><a id="1318"></a><span class="comment">-- @return #DYNAMIC_SPAWNER self : self with self.DebugEnabled = 0 or 1
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:EnableDebugLog(value)
  value = value <span class="keyword">or</span> <span class="keyword">true</span>
  <span class="keyword">if</span> value == <span class="keyword">true</span> <span class="keyword">then</span>
    self.DebugEnabled = <span class="number">1</span>
  <span class="keyword">elseif</span> value == <span class="keyword">false</span> <span class="keyword">then</span>
    self.DebugEnabled = <span class="number">0</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - EnableDebugLog - "</span> .. self.DebugEnabled)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">---Enables outputting Debug information for key functions to the game messages.
</span><span class="comment">--
</span><span class="comment">--         Simply calling :EnableDebugMessages() enables the debug messages.
</span><span class="comment">--
</span><span class="comment">--         To disable, call :EnableDebugMessages(false)
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param value : argument: nil, true, false
</span><span class="comment">--
</span><span class="comment">--      If provided with false, disables Debug log.
</span><span class="comment">--            ex: :EnableDebugMessages(false)
</span><span class="comment">--      If provided with true or ommitted, enables Debug log.
</span><span class="comment">--             ex: :EnableDebugMessages(true)
</span><span class="comment">--             ex: :EnableDebugMessages()
</span><span class="comment">-- @param summaryOnly : argument: nil, true, false
</span><span class="comment">--
</span><span class="comment">--      If provided with false or ommitted, full Debug Message is sent.
</span><span class="comment">--             ex: :EnableDebugMessages(true,false)
</span><span class="comment">--             ex: :EnableDebugMessages(true)
</span><span class="comment">--      If provided with true, only a shorter summary Debug Message is sent.
</span><span class="comment">--             ex: :EnableDebugMessages(true,true)
</span><a id="1353"></a><span class="comment">-- @return #DYNAMIC_SPAWNER self : self with self.DebugMessages = 0 or 1
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:EnableDebugMessages(value, summaryOnly)
  <span class="keyword">if</span> value == <span class="keyword">true</span> <span class="keyword">then</span>
    self.DebugMessages = <span class="number">1</span>
  <span class="keyword">elseif</span> value == <span class="keyword">false</span> <span class="keyword">then</span>
    self.DebugMessages = <span class="number">0</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> summaryOnly == <span class="keyword">true</span> <span class="keyword">then</span>
    self.DebugSummaryOnly = <span class="number">1</span>
  <span class="keyword">elseif</span> summaryOnly == <span class="keyword">false</span> <span class="keyword">then</span>
    self.DebugSummaryOnly = <span class="number">0</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - EnableDebugMessages - "</span> .. self.DebugMessages )
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">---Toggles current Debug Messages state.
</span><span class="comment">--
</span><span class="comment">--         Simply calling :ToggleDebugMessages() toggles the debug message state.
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><a id="1376"></a><span class="comment">-- @return #DYNAMIC_SPAWNER self : self with self.DebugMessages toggled = 0 or 1
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:ToggleDebugMessages()
  <span class="keyword">if</span> self.DebugMessages == <span class="number">0</span> <span class="keyword">then</span>
    self.DebugMessages = <span class="number">1</span>
    trigger.action.outText(<span class="string">"Debug Messages Started"</span>,<span class="number">5</span>, <span class="keyword">false</span>)
  <span class="keyword">elseif</span> self.DebugMessages == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugMessages = <span class="number">0</span>
    trigger.action.outText(<span class="string">"Debug Messages Stopped"</span>,<span class="number">5</span>, <span class="keyword">false</span>)
  <span class="keyword">end</span>
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - ToggleDebugMessages - State: "</span> .. self.DebugMessages )
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Dumps up to 3 levels of the self table (Keys+values, Parent+Children) to the DCS log.
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><a id="1393"></a><span class="comment">-- @return #DYNAMIC_SPAWNER self
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:DEBUG_PRINT_self()
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - DEBUG_PRINT_self()"</span>)
    self:PrintTable(self, <span class="number">0</span>, <span class="number">3</span>)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:PrintTable(tbl, level, maxLevel)
  <span class="keyword">if</span> level &gt; maxLevel <span class="keyword">then</span>
    <span class="keyword">return</span>
  <span class="keyword">end</span>
  <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="global">pairs</span>(tbl) <span class="keyword">do</span>
    BASE:E(<span class="global">string</span>.rep(<span class="string">"  "</span>, level) .. key)
    <span class="keyword">if</span> <span class="global">type</span>(value) == <span class="string">"table"</span> <span class="keyword">then</span>
      self:PrintTable(value, level + <span class="number">1</span>, maxLevel)
    <span class="keyword">else</span>
      BASE:E(<span class="global">string</span>.rep(<span class="string">"  "</span>, level + <span class="number">1</span>) .. value)
    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="comment">--- Sets the limiter for coroutine ("multithreading") operations.
</span><span class="comment">--
</span><span class="comment">--      The coroutine will execute "limit" number of operations
</span><span class="comment">--      before yielding back to main thread.
</span><span class="comment">--
</span><span class="comment">-- ***CAUTION:***
</span><span class="comment">--
</span><span class="comment">--        Increasing this value too high can result in server hangs
</span><span class="comment">--        Decreasing this value too low can result in long generation times
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param limit : The Operational Limit, integer.
</span><span class="comment">--
</span><span class="comment">--        self.Config.operationLimit = limit
</span><span class="comment">--        Default limit value = 200
</span><a id="1432"></a><span class="comment">-- @return #DYNAMIC_SPAWNER self
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:SetCoRoutineLimit(limit)
  limit = limit <span class="keyword">or</span> self.Config.operationLimit
  self.Config.operationLimit = limit
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Sets the interval for coroutine ("multithreading") operations.
</span><span class="comment">--
</span><span class="comment">--      The coroutine will yield for the interval number (in seconds)
</span><span class="comment">--      before resuming the operation when the operationLimit is hit.
</span><span class="comment">--
</span><span class="comment">-- ***CAUTION:***
</span><span class="comment">--
</span><span class="comment">--        Increasing this value too high can result in long generation times
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param interval : The Operational interval, integer.
</span><span class="comment">--
</span><span class="comment">--        self.Config.operationInterval = interval
</span><span class="comment">--        Default interval value = 3
</span><a id="1453"></a><span class="comment">-- @return #DYNAMIC_SPAWNER self
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:SetCoRoutineInterval(interval)
  interval = interval <span class="keyword">or</span> self.Config.operationInterval
  self.Config.operationInterval = interval
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">---Internal Functions.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with the Internal Functions of the DYNAMIC_SPAWNER class.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">--      Automatically used by the extension as needed.
</span><span class="comment">--
</span><span class="comment">--      Use these at your own risk during Dynamic Spawner operations.
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section Internal Functions
</span>
<span class="comment">---Weights and analyzes all zones for spawner generation process.
</span><span class="comment">--@param #DYNAMIC_SPAWNER self
</span><span class="comment">--@return #DYNAMIC_SPAWNER self : self with tables added for
</span><span class="comment">--
</span><span class="comment">--        .zone
</span><span class="comment">--        .radius
</span><span class="comment">--        .area
</span><span class="comment">--        .weight
</span><span class="comment">-- where
</span><span class="comment">--
</span><span class="comment">--         self.Zones.Main.zone = ZONE:FindByName(self.Zones.Main.name)
</span><span class="comment">--         self.Zones.Main.radius = self.Zones.Main.zone:GetRadius()
</span><span class="comment">--         self.Zones.Main.area = math.pi * (self.Zones.Main.radius)^2
</span><span class="comment">--         self.Zones.Main.weight = 1 - sum of all sub zone weights
</span><span class="comment">--         and
</span><span class="comment">--         self.Zones.Sub[_i].zone = ZONE:FindByName(self.Zones.Sub[_i].name)
</span><span class="comment">--         self.Zones.Sub[_i].radius = self.Zones.Sub[_i].zone:GetRadius()
</span><span class="comment">--         self.Zones.Sub[_i].area = math.pi * (self.Zones.Sub[_i].radius)^2
</span><span class="comment">--         self.Zones.Sub[_i].weight = self.Zones.Sub[_i].area / self.Zones.Main.area
</span><span class="comment">-- where
</span><span class="comment">--
</span><a id="1494"></a><span class="comment">--         _i = Number of the self.Zone.Sub table
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:WeightZones()
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.WeightZones = {Time = {},}
    self.DebugLog.WeightZones.Time.start = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - WeightZones()"</span>)
  <span class="keyword">end</span>
  self:CalculateZone(self.Zones.Main)
  <span class="keyword">local</span> totalWeight = <span class="number">0</span>
  <span class="keyword">for</span> i = <span class="number">1</span>, #self.Zones.Sub <span class="keyword">do</span>
    self:CalculateZone(self.Zones.Sub[i])
    totalWeight = totalWeight + self.Zones.Sub[i].weight
    <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - WeightZones() - self.Zones.Sub["</span> .. i .. <span class="string">"]"</span>)
      BASE:E(self.Zones.Sub[i])
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  self.Zones.Main.weight = <span class="number">1</span> - totalWeight
  self.Zones.Main.weight = <span class="global">math</span>.max(<span class="number">0</span>, <span class="global">math</span>.min(<span class="number">1</span>, self.Zones.Main.weight))
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.WeightZones.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - WeightZones() - Time: "</span> .. self.DebugLog.WeightZones.Time.stop - self.DebugLog.WeightZones.Time.start)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - WeightZones() - self.Zones.Main"</span>)
    BASE:E(self.Zones.Main)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:CalculateZone(zone)
  zone.zone = ZONE:FindByName(zone.name)
  zone.radius = zone.zone:GetRadius()
  zone.area = <span class="global">math</span>.pi * (zone.radius)^<span class="number">2</span>
  zone.weight = zone.area / self.Zones.Main.area
<span class="keyword">end</span>

<span class="comment">--- Determines the number of Types to be assigned to each zone.
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : Returns self with an added .numUnits value for each zone:
</span><span class="comment">--
</span><span class="comment">--       self.Zones.Main.numUnits
</span><span class="comment">--       self.Zones.Sub[_i].numUnits
</span><span class="comment">-- where
</span><span class="comment">--       _i = Number of the self.Zone.Sub table
</span><a id="1537"></a><span class="comment">--       .numUnits = the number of Types to be assigned to the zone
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:SetNumTypesPerZone()
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.SetNumTypesPerZone = {Time = {},}
    self.DebugLog.SetNumTypesPerZone.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>
  <span class="keyword">local</span> unitsMax  = self.Config.UnitsMax
  <span class="keyword">local</span> unitsMin  = self.Config.UnitsMin
  <span class="keyword">local</span> ActualUnits  = <span class="global">math</span>.random(unitsMin, unitsMax)
  <span class="keyword">local</span> tally = <span class="number">0</span>
  self.Zones.Main.numUnits = <span class="global">math</span>.ceil(self.Zones.Main.weight * ActualUnits)
  <span class="keyword">for</span> _i = <span class="number">1</span>, #self.Zones.Sub, <span class="number">1</span> <span class="keyword">do</span>
    self.Zones.Sub[_i].numUnits = <span class="global">math</span>.ceil(self.Zones.Sub[_i].weight * ActualUnits)
    tally = tally + self.Zones.Sub[_i].numUnits
  <span class="keyword">end</span>
  <span class="keyword">if</span> tally &gt; ActualUnits <span class="keyword">then</span>
    self.Zones.Main.numUnits = self.Zones.Main.numUnits - (tally - ActualUnits)
  <span class="keyword">end</span>
  <span class="keyword">if</span> (tally + self.Zones.Main.numUnits) &gt; ActualUnits <span class="keyword">then</span>
    self.Zones.Main.numUnits = self.Zones.Main.numUnits - ((tally + self.Zones.Main.numUnits) - ActualUnits  )
  <span class="keyword">end</span>
  <span class="keyword">if</span> self.Zones.Main.numUnits &lt; <span class="number">0</span> <span class="keyword">then</span>
    self.Zones.Main.numUnits = <span class="number">0</span>
  <span class="keyword">end</span>
  <span class="keyword">repeat</span>
    <span class="keyword">if</span> self.Zones.Main.numUnits &gt;= #self.Zones.Sub <span class="keyword">then</span>
      self.Zones.Main.numUnits = self.Zones.Main.numUnits - #self.Zones.Sub
      <span class="keyword">for</span> _i = <span class="number">1</span>, #self.Zones.Sub, <span class="number">1</span> <span class="keyword">do</span>
        self.Zones.Sub[_i].numUnits = self.Zones.Sub[_i].numUnits + <span class="number">1</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">until</span>(self.Zones.Main.numUnits &lt;= #self.Zones.Sub)
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.SetNumTypesPerZone.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetNumTypesPerZone() - Time: "</span> .. self.DebugLog.SetNumTypesPerZone.Time.stop - self.DebugLog.SetNumTypesPerZone.Time.start)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetNumTypesPerZone()"</span>)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetNumTypesPerZone() - ActualUnits"</span>)
    BASE:E(ActualUnits)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetNumTypesPerZone() - self.Zones.Main.name"</span>)
    BASE:E(self.Zones.Main.name)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetNumTypesPerZone() - self.Zones.Main.numUnits"</span>)
    BASE:E(self.Zones.Main.numUnits)
    <span class="keyword">for</span> _i = <span class="number">1</span>, #self.Zones.Sub, <span class="number">1</span> <span class="keyword">do</span>
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetNumTypesPerZone() - self.Zones.Sub[_i].name"</span>)
      BASE:E(self.Zones.Sub[_i].name)
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetNumTypesPerZone() - self.Zones.Sub[_i].numUnits"</span>)
      BASE:E(self.Zones.Sub[_i].numUnits)
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">---Sets up the groups per zone based on provided configs, settings, and generation.
</span><span class="comment">--@param #DYNAMIC_SPAWNER self
</span><span class="comment">--@return #DYNAMIC_SPAWNER self : self with added tables for .GroupSettings :
</span><span class="comment">--
</span><span class="comment">--      self.Zones.Main.GroupSettings
</span><span class="comment">--      self.Zones.Sub[_j].GroupSettings
</span><span class="comment">-- where
</span><span class="comment">--
</span><span class="comment">--      _j = Number of the self.Zone.Sub table
</span><span class="comment">--      .GroupSettings[#] = {
</span><span class="comment">--                           GroupSize = GroupSizesMainZone[_i],
</span><span class="comment">--                           NumberGroups = numGroupSize,
</span><span class="comment">--                           minSeparation_Groups = _GroupSpacingSettings[GroupSizesMainZone[_i]].minSeparation_Groups or _GroupSpacingSettings.General.minSeparation_Groups,
</span><span class="comment">--                           minSeperation = _GroupSpacingSettings[GroupSizesMainZone[_i]].minSeperation or _GroupSpacingSettings.General.minSeperation,
</span><span class="comment">--                           maxSeperation = _GroupSpacingSettings[GroupSizesMainZone[_i]].maxSeperation or _GroupSpacingSettings.General.maxSeperation,
</span><span class="comment">--                         }
</span><span class="comment">-- where
</span><span class="comment">--
</span><a id="1607"></a><span class="comment">--      _i = Number of the #self.Config.GroupSizesMainZone or #self.Config.GroupSizes table
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:SetGroupsPerZone()
 <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.SetGroupsPerZone = {Time = {},}
    self.DebugLog.SetGroupsPerZone.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>
  <span class="keyword">local</span> GroupSizesSubZone = self.Config.GroupSizes
  <span class="keyword">local</span> GroupSizesMainZone = self.Config.GroupSizesMainZone
  <span class="keyword">local</span> _GroupSpacingSettings = self.Config.GroupSpacingSettings

  self.Zones.Main.GroupSettings = {}
  <span class="keyword">local</span> Units_MainZone = self.Zones.Main.numUnits

  <span class="keyword">for</span> i = <span class="number">1</span>, #GroupSizesMainZone <span class="keyword">do</span>
    <span class="keyword">local</span> numGroupSize = <span class="global">math</span>.floor(Units_MainZone / GroupSizesMainZone[i])
    <span class="keyword">if</span> numGroupSize ~= <span class="number">0</span> <span class="keyword">then</span>
      Units_MainZone = Units_MainZone - (numGroupSize * GroupSizesMainZone[i])
      self.Zones.Main.GroupSettings[#self.Zones.Main.GroupSettings + <span class="number">1</span>] = self:CreateGroupSettings(GroupSizesMainZone[i], numGroupSize)
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupsPerZone() - self.Zones.Main"</span>)
    BASE:E(self.Zones.Main)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupsPerZone() - self.Zones.Main.GroupSettings"</span>)
    BASE:E(self.Zones.Main.GroupSettings)
  <span class="keyword">end</span>

  <span class="keyword">for</span> j = <span class="number">1</span>, #self.Zones.Sub <span class="keyword">do</span>
    self.Zones.Sub[j].GroupSettings = {}
    <span class="keyword">local</span> Units_SubZone = self.Zones.Sub[j].numUnits

    <span class="keyword">for</span> i = <span class="number">1</span>, #GroupSizesSubZone <span class="keyword">do</span>
      <span class="keyword">local</span> numGroupSize = <span class="global">math</span>.floor(Units_SubZone / GroupSizesSubZone[i])
      <span class="keyword">if</span> numGroupSize ~= <span class="number">0</span> <span class="keyword">then</span>
        Units_SubZone = Units_SubZone - (numGroupSize * GroupSizesSubZone[i])
        self.Zones.Sub[j].GroupSettings[#self.Zones.Sub[j].GroupSettings + <span class="number">1</span>] = self:CreateGroupSettings(GroupSizesSubZone[i], numGroupSize)
      <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupsPerZone() - self.Zones.Sub["</span> .. j .. <span class="string">"]"</span>)
      BASE:E(self.Zones.Sub[j])
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupsPerZone() - self.Zones.Sub["</span> .. j .. <span class="string">"].GroupSettings"</span>)
      BASE:E(self.Zones.Sub[j].GroupSettings)
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.SetGroupsPerZone.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER: SetGroupsPerZone - Time: "</span> .. self.DebugLog.SetGroupsPerZone.Time.stop - self.DebugLog.SetGroupsPerZone.Time.start)
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:CreateGroupSettings(groupSize, numGroups)
  <span class="keyword">local</span> _GroupSpacingSettings = self.Config.GroupSpacingSettings
  <span class="keyword">return</span> {
    GroupSize = groupSize,
    NumberGroups = numGroups,
    minSeparation_Groups = _GroupSpacingSettings[groupSize].minSeparation_Groups <span class="keyword">or</span> _GroupSpacingSettings.General.minSeparation_Groups,
    minSeperation = _GroupSpacingSettings[groupSize].minSeperation <span class="keyword">or</span> _GroupSpacingSettings.General.minSeperation,
    maxSeperation = _GroupSpacingSettings[groupSize].maxSeperation <span class="keyword">or</span> _GroupSpacingSettings.General.maxSeperation,
  }
<span class="keyword">end</span>

<span class="comment">--- Determine the Types comprising each generated group.
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : With added tables for:
</span><span class="comment">--
</span><span class="comment">--       self.Zones.Sub[_i].BuiltSpawner[_j][_k].Types = _groupTypes
</span><span class="comment">--       self.Zones.Main.BuiltSpawner[_j][_k].Types = _groupTypes
</span><span class="comment">--
</span><span class="comment">-- where
</span><span class="comment">--
</span><span class="comment">--       _i = Number of the self.Zone.Sub table
</span><span class="comment">--       _j = # main group self.Sub[_i].GroupSettings or #self.Main.GroupSettings
</span><span class="comment">--       _k = # sub group in self.Sub[_i].GroupSettings.NumberGroups or #self.Main.GroupSettings.NumberGroups
</span><span class="comment">--       _groupTypes = {
</span><span class="comment">--                        [1] = "Supply",
</span><span class="comment">--                        [..] = "AAA",
</span><span class="comment">--                        [n] = "typeName",
</span><a id="1691"></a><span class="comment">--                      }
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:SetGroupTypes()
 <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.SetGroupTypes = {Time = {},}
    self.DebugLog.SetGroupTypes.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>

  <span class="keyword">local</span> typeList = {}
  <span class="keyword">for</span> _k, _v <span class="keyword">in</span> <span class="global">pairs</span>(self.ParsedTypes) <span class="keyword">do</span>
    typeList[#typeList + <span class="number">1</span>] = _k
  <span class="keyword">end</span>

  <span class="keyword">local</span> <span class="keyword">function</span> removeTypeFromList(typeList, randType)
    <span class="keyword">local</span> idx = SPECTRE.Utils.getIndex(typeList, randType)
    <span class="keyword">if</span> idx ~= <span class="keyword">nil</span> <span class="keyword">then</span>
      <span class="global">table</span>.remove(typeList, idx)
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">local</span> <span class="keyword">function</span> generateGroupTypes(zone, groupSettings)
    <span class="keyword">local</span> groupTypes = {}
    <span class="keyword">local</span> allTypes = {}

    <span class="keyword">for</span> _j = <span class="number">1</span>, #groupSettings, <span class="number">1</span> <span class="keyword">do</span>
      zone.BuiltSpawner[_j] = {}
      <span class="keyword">for</span> _k = <span class="number">1</span>, groupSettings[_j].NumberGroups, <span class="number">1</span> <span class="keyword">do</span>
        zone.BuiltSpawner[_j][_k] = {}
        typeList = SPECTRE.Utils.Shuffle(typeList)
        <span class="keyword">local</span> _groupTypes = {}

        <span class="keyword">for</span> _t = <span class="number">1</span>, groupSettings[_j].GroupSize + self.Config.numExtraUnits, <span class="number">1</span> <span class="keyword">do</span>
          <span class="keyword">if</span> _t &lt;= groupSettings[_j].GroupSize <span class="keyword">then</span>
            <span class="keyword">local</span> randType = SPECTRE.Utils.PickRandomFromTable(typeList)
            <span class="keyword">local</span> amount_min = self.ParsedTypes[randType].amounts.min
            <span class="keyword">local</span> amount_max = self.ParsedTypes[randType].amounts.max
            <span class="keyword">local</span> amount_numUsed = self.ParsedTypes[randType].amounts.numUsed
            <span class="keyword">local</span> limited = self.ParsedTypes[randType].limited
            amount_numUsed = amount_numUsed + <span class="number">1</span>
            self.ParsedTypes[randType].amounts.numUsed = amount_numUsed

            <span class="keyword">if</span> amount_max ~= <span class="number">0</span> <span class="keyword">and</span> amount_numUsed &gt;= amount_max <span class="keyword">then</span>
              removeTypeFromList(typeList, randType)
            <span class="keyword">end</span>

            <span class="keyword">if</span> amount_numUsed &gt;= amount_min <span class="keyword">and</span> limited == <span class="number">1</span> <span class="keyword">then</span>
              removeTypeFromList(typeList, randType)
            <span class="keyword">end</span>

            _groupTypes[#_groupTypes + <span class="number">1</span>] = randType
            allTypes[#allTypes + <span class="number">1</span>] = randType
            self.AllTypes[#self.AllTypes + <span class="number">1</span>] = randType
          <span class="keyword">else</span>
            <span class="keyword">local</span> curNumExtraUnit = _t - groupSettings[_j].GroupSize
            <span class="keyword">local</span> extraType
            <span class="keyword">local</span> tempCounter = <span class="number">0</span>

            <span class="keyword">for</span> _iTemp = <span class="number">1</span>, #self.ExtraTypesToGroups, <span class="number">1</span> <span class="keyword">do</span>
              <span class="keyword">for</span> _x = <span class="number">1</span>, self.ExtraTypesToGroups[_iTemp].numtype, <span class="number">1</span> <span class="keyword">do</span>
                tempCounter = tempCounter + <span class="number">1</span>
                <span class="keyword">if</span> tempCounter == curNumExtraUnit <span class="keyword">then</span>
                  extraType = self.ExtraTypesToGroups[_iTemp].<span class="global">type</span>
                  <span class="keyword">break</span>
                <span class="keyword">end</span>
              <span class="keyword">end</span>
              <span class="keyword">if</span> tempCounter == curNumExtraUnit <span class="keyword">then</span>
                <span class="keyword">break</span>
              <span class="keyword">end</span>
            <span class="keyword">end</span>

            _groupTypes[#_groupTypes + <span class="number">1</span>] = extraType
            allTypes[#allTypes + <span class="number">1</span>] = extraType
            self.AllTypes[#self.AllTypes + <span class="number">1</span>] = extraType
          <span class="keyword">end</span>
        <span class="keyword">end</span>

        zone.BuiltSpawner[_j][_k].Types = _groupTypes
      <span class="keyword">end</span>
    <span class="keyword">end</span>

    zone.AllTypes = allTypes
  <span class="keyword">end</span>

  <span class="keyword">for</span> _i = <span class="number">1</span>, #self.Zones.Sub, <span class="number">1</span> <span class="keyword">do</span>
    self.Zones.Sub[_i].BuiltSpawner = {}
    self.Zones.Sub[_i].AllTypes = {}
    generateGroupTypes(self.Zones.Sub[_i], self.Zones.Sub[_i].GroupSettings)
    <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupTypes() - self.Zones.Sub[_i]"</span>)
      BASE:E(self.Zones.Sub[_i])
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  self.Zones.Main.AllTypes = {}
  self.Zones.Main.BuiltSpawner = {}
  generateGroupTypes(self.Zones.Main, self.Zones.Main.GroupSettings)

  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.SetGroupTypes.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupTypes() - Time: "</span> .. self.DebugLog.SetGroupTypes.Time.stop - self.DebugLog.SetGroupTypes.Time.start)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupTypes() - self.Zones.Main"</span>)
    BASE:E(self.Zones.Main)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupTypes() - TOTAL COUNT"</span>)
    <span class="keyword">for</span> _k, _v <span class="keyword">in</span> <span class="global">pairs</span>(self.ParsedTypes) <span class="keyword">do</span>
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupTypes() - TOTAL COUNT - "</span> .. _k)
      BASE:E(self.ParsedTypes[_k].amounts.numUsed)
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Determine the corresponding type template for the generated Types comprising each generated group.
</span><span class="comment">--
</span><span class="comment">--      The template name is pulled from the list of provided template groupname
</span><span class="comment">--      defined in the mission editor corresponding to the type.
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : With added tables for:
</span><span class="comment">--
</span><span class="comment">--       self.Zones.Sub[_i].BuiltSpawner[_j][_k].TemplateNames = _groupTypes
</span><span class="comment">--       self.Zones.Main.BuiltSpawner[_j][_k].TemplateNames = _groupTypes
</span><span class="comment">--
</span><span class="comment">-- where
</span><span class="comment">--
</span><span class="comment">--       _i = Number of the self.Zone.Sub table
</span><span class="comment">--       _j = # main group self.Sub[_i].GroupSettings or #self.Main.GroupSettings
</span><span class="comment">--       _k = # sub group in self.Sub[_i].GroupSettings.NumberGroups
</span><span class="comment">--            or
</span><span class="comment">--            #self.Main.GroupSettings.NumberGroups
</span><span class="comment">--
</span><span class="comment">--       _groupTypes = {
</span><span class="comment">--                        [1] = "Template_Supply_Ural375",
</span><span class="comment">--                        [..] = "Template_ATGM_BTRRD",
</span><span class="comment">--                        [n] = "typeName",
</span><a id="1825"></a><span class="comment">--                      }
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:SetGroupTypesTemplates()
 <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.SetGroupTypesTemplates = {Time = {},}
    self.DebugLog.SetGroupTypesTemplates.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>

  <span class="keyword">local</span> <span class="keyword">function</span> generateTemplateNames(zone, groupSettings, builtSpawner)
    <span class="keyword">for</span> _j = <span class="number">1</span>, #groupSettings, <span class="number">1</span> <span class="keyword">do</span>
      <span class="keyword">for</span> _k = <span class="number">1</span>, groupSettings[_j].NumberGroups, <span class="number">1</span> <span class="keyword">do</span>
        <span class="keyword">local</span> _groupTypes = {}
        <span class="keyword">for</span> _t = <span class="number">1</span>, groupSettings[_j].GroupSize + self.Config.numExtraUnits, <span class="number">1</span> <span class="keyword">do</span>
          <span class="keyword">local</span> Type_ = builtSpawner[_j][_k].Types[_t]
          <span class="keyword">local</span> TypeTable_ = self.ParsedTypes[Type_].names
          TypeTable_ = SPECTRE.Utils.Shuffle(TypeTable_)
          <span class="keyword">local</span> randType = SPECTRE.Utils.PickRandomFromTable(TypeTable_)
          _groupTypes[#_groupTypes + <span class="number">1</span>] = randType
        <span class="keyword">end</span>
        builtSpawner[_j][_k].TemplateNames = _groupTypes
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">for</span> _i = <span class="number">1</span>, #self.Zones.Sub, <span class="number">1</span> <span class="keyword">do</span>
    generateTemplateNames(self.Zones.Sub[_i], self.Zones.Sub[_i].GroupSettings, self.Zones.Sub[_i].BuiltSpawner)
    <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupTypesTemplates() - self.Zones.Sub[_i]"</span>)
      BASE:E(self.Zones.Sub[_i])
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  generateTemplateNames(self.Zones.Main, self.Zones.Main.GroupSettings, self.Zones.Main.BuiltSpawner)

  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.SetGroupTypesTemplates.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupTypesTemplates() - Time: "</span> .. self.DebugLog.SetGroupTypesTemplates.Time.stop - self.DebugLog.SetGroupTypesTemplates.Time.start)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - SetGroupTypesTemplates() - self.Zones.Main"</span>)
    BASE:E(self.Zones.Main)
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Determines the coordinates for all generated Types.
</span><span class="comment">--
</span><span class="comment">--      Determines center for each grouping of Types, then
</span><span class="comment">--      determines the placement of each type based on group centers.
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : Returns modified self array. See functions:
</span><span class="comment">--
</span><span class="comment">--       SPECTRE.DYNAMIC_SPAWNER:Set_Vec2_GroupCenters()
</span><a id="1878"></a><span class="comment">--       SPECTRE.DYNAMIC_SPAWNER:Set_Vec2_Types()
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:DetermineCoordinates()
 <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.DetermineCoordinates = {Time = {},}
    self.DebugLog.DetermineCoordinates.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>
  <span class="comment">-- self:FindObjects()
</span>  self:Set_Vec2_GroupCenters()
  self:Set_Vec2_Types()

  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.DetermineCoordinates.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER: DetermineCoordinates - Time: "</span> .. self.DebugLog.DetermineCoordinates.Time.stop - self.DebugLog.DetermineCoordinates.Time.start)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- ###Generates and activates in game units based on generated dynamic spawner.
</span><span class="comment">--
</span><span class="comment">-- * Spawned units follow naming conventions.
</span><span class="comment">-- * All Type group &amp; unit names are based on the zone they fall in to.
</span><span class="comment">--
</span><span class="comment">--        --- The Dynamic Spawner returns a MOOSE #GROUP Object for each spawned Type.
</span><span class="comment">--        -- May be accessed as any other Moose #GROUP object.
</span><span class="comment">--
</span><span class="comment">--         _spawnunit = SPAWN:New():Spawn()
</span><span class="comment">--
</span><span class="comment">--         self.Zones.Main.BuiltSpawner[_j][_k].ActivatedUnits[_m]    = _spawnunit
</span><span class="comment">--         self.Zones.Sub[_i].BuiltSpawner[_j][_k].ActivatedUnits[_m] = _spawnunit
</span><span class="comment">--
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : self with added table for .ActivatedUnits
</span><span class="comment">--
</span><span class="comment">--        self.Zones.Sub[_i].BuiltSpawner[_j][_k].ActivatedUnits[#] = _spawnunit
</span><span class="comment">--        self.Zones.Main.BuiltSpawner[_j][_k].ActivatedUnits[#] = _spawnunit
</span><span class="comment">-- where
</span><span class="comment">--
</span><span class="comment">--        _i = Number of the self.Zone.Sub table
</span><span class="comment">--        _j = # main group self.Sub[_i].GroupSettings or #self.Main.GroupSettings
</span><span class="comment">--        _k = # sub group in self.Sub[_i].GroupSettings.NumberGroups or #self.Main.GroupSettings.NumberGroups
</span><span class="comment">--        _spawnunit = SPAWN:NewWithAlias(template_, name_ .. "_" .. self.Zones.Sub[_i].TypeCounter)
</span><span class="comment">--                          :InitHeading(0,364)
</span><span class="comment">--                          :SpawnFromVec2(vec2_)
</span><span class="comment">--                     or
</span><span class="comment">--                     SPAWN:NewWithAlias(template_, name_ .. "_" .. self.Zones.Main.TypeCounter)
</span><span class="comment">--                          :InitHeading(0,364)
</span><span class="comment">--                          :SpawnFromVec2(vec2_)
</span><span class="comment">-- where
</span><span class="comment">--
</span><span class="comment">--        name_ = self.Zones.Sub[_i].name or self.Zones.Main.name
</span><span class="comment">--        template_ = self.Zones.Sub[_i].BuiltSpawner[_j][_k].TemplateNames[#] or self.Zones.Main.BuiltSpawner[_j][_k].TemplateNames[#]
</span><span class="comment">--        vec2_ = self.Zones.Sub[_i].BuiltSpawner[_j][_k].Vec2Types[#] or self.Zones.Main.BuiltSpawner[_j][_k].Vec2Types[#]
</span><a id="1932"></a><span class="comment">--
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:Spawn()
 <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.Spawn = {Time = {},}
    self.DebugLog.Spawn.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>

  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - Spawn() - ENTER"</span>)
  <span class="keyword">end</span>

  <span class="keyword">local</span> <span class="keyword">function</span> spawnUnits(zone, name, builtSpawner, typeCounter)
    <span class="keyword">for</span> _j = <span class="number">1</span>, #zone.GroupSettings, <span class="number">1</span> <span class="keyword">do</span>
      <span class="keyword">for</span> _k = <span class="number">1</span>, zone.GroupSettings[_j].NumberGroups, <span class="number">1</span> <span class="keyword">do</span>
        builtSpawner[_j][_k].ActivatedUnits = {}
        <span class="keyword">for</span> _m = <span class="number">1</span>, zone.GroupSettings[_j].GroupSize + self.Config.numExtraUnits, <span class="number">1</span> <span class="keyword">do</span>
          <span class="keyword">local</span> template_ = builtSpawner[_j][_k].TemplateNames[_m]
          <span class="keyword">local</span> vec2_ = builtSpawner[_j][_k].Vec2Types[_m]



          <span class="keyword">local</span> tempCode = typeCounter
          <span class="keyword">local</span> FoundGroup
          <span class="keyword">repeat</span>
            <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
              BASE:E(<span class="string">"DEBUG : AIRDROP determining if group exists"</span>)
              BASE:E(<span class="string">"DEBUG : tempCode "</span> .. tempCode)
              BASE:E(<span class="string">"DEBUG : groupname "</span> )
              BASE:E(name .. <span class="string">"_"</span> ..  tempCode .. <span class="string">"#001"</span>)
            <span class="keyword">end</span>
            FoundGroup = GROUP:FindByName(name .. <span class="string">"_"</span> .. tempCode .. <span class="string">"#001"</span>)
            <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
              BASE:E(<span class="string">"DEBUG : found? "</span>)
              BASE:E(FoundGroup)
            <span class="keyword">end</span>
            <span class="keyword">if</span> FoundGroup <span class="keyword">then</span>
              tempCode = tempCode + <span class="number">1</span>
            <span class="keyword">else</span>
              FoundGroup = <span class="keyword">false</span>
            <span class="keyword">end</span>
          <span class="keyword">until</span> (FoundGroup == <span class="keyword">false</span>)
          typeCounter = tempCode



          <span class="keyword">local</span> _spawnunit = SPAWN:NewWithAlias(template_, name .. <span class="string">"_"</span> .. typeCounter)
            :InitHeading(<span class="number">0</span>,<span class="number">364</span>)
            :SpawnFromVec2(vec2_)
          builtSpawner[_j][_k].ActivatedUnits[_m] = _spawnunit
          typeCounter = typeCounter + <span class="number">1</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> typeCounter
  <span class="keyword">end</span>

  <span class="keyword">for</span> _i = <span class="number">1</span>, #self.Zones.Sub, <span class="number">1</span> <span class="keyword">do</span>
    self.Zones.Sub[_i].TypeCounter = SPECTRE.DYNAMIC_SPAWNER.COUNTER
    self.Zones.Sub[_i].TypeCounter = spawnUnits(self.Zones.Sub[_i], self.Zones.Sub[_i].name, self.Zones.Sub[_i].BuiltSpawner, self.Zones.Sub[_i].TypeCounter)
    SPECTRE.DYNAMIC_SPAWNER.COUNTER = self.Zones.Sub[_i].TypeCounter
  <span class="keyword">end</span>

  self.Zones.Main.TypeCounter = SPECTRE.DYNAMIC_SPAWNER.COUNTER
  self.Zones.Main.TypeCounter = spawnUnits(self.Zones.Main, self.Zones.Main.name, self.Zones.Main.BuiltSpawner, self.Zones.Main.TypeCounter)
  SPECTRE.DYNAMIC_SPAWNER.COUNTER = self.Zones.Main.TypeCounter

  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.Spawn.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - Spawn() - Time: "</span> .. self.DebugLog.Spawn.Time.stop - self.DebugLog.Spawn.Time.start)
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">---_framework.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with the framework of the DYNAMIC_SPAWNER class.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">--      You probably shouldnt use these.
</span><span class="comment">--
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section _framework
</span>
<span class="comment">--- Yield function for the internally used coroutine.
</span><span class="comment">--
</span><span class="comment">-- Allows the spawner to be run in 'multithreading', preventing interruption of main game state.
</span><span class="comment">--
</span><span class="comment">-- Allows Dynamic Spawner to be run "in background" over time.
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param limit : The limit on operations before a yield is triggered.
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self
</span><span class="comment">--
</span><span class="comment">--      self with new operation counter value.
</span><a id="2031"></a><span class="comment">--      (Incremented by 1. Reset to 0 if limit is reached and yield is triggered)
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:CO_Yield(limit)
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - CO_Yield"</span>)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - CO_Yield - Co_Counter"</span>)
    BASE:E(self.Co_Counter)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - CO_Yield - Limit"</span>)
    BASE:E(limit)
  <span class="keyword">end</span>
  self.Co_Counter = self.Co_Counter + <span class="number">1</span>
  <span class="keyword">if</span> self.Co_Counter &gt;= limit <span class="keyword">then</span>
    self.Co_Counter = <span class="number">0</span>
    <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - CO_Yield() - YIELDED"</span>)
    <span class="keyword">end</span>
    self.Co_MultiGenerate.yield()
    <span class="comment">--coroutine.yield()
</span>  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Outputs debug information about the DYNAMIC_SPAWNER into the in game messages.
</span><span class="comment">--
</span><span class="comment">-- Displays: General Unit Info, Zone Info, Length of time taken for program stages
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><a id="2057"></a><span class="comment">-- @return #DYNAMIC_SPAWNER self
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:DebugMessage()
 <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - DebugMessage() "</span>)
    self.DebugLog.DebugMessage = {Time = {},}
    self.DebugLog.DebugMessage.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>
  <span class="keyword">if</span> self.DebugMessages == <span class="number">1</span> <span class="keyword">then</span>

    <span class="keyword">local</span> report = REPORT:New(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - "</span> .. self.Zones.Main.name)
    report:Add(<span class="string">"------------------------------------------------------------------------------------------------"</span>)
    report:Add(<span class="string">" "</span>)

    <a id="2071"></a><span class="comment">------------ Num Types
</span>    <span class="keyword">local</span> numTypes = #self.AllTypes
    <span class="keyword">local</span> numMain = #self.Zones.Main.AllTypes
    <span class="keyword">local</span> numSubs = <span class="number">0</span>
    <span class="keyword">for</span> _i = <span class="number">1</span>, #self.Zones.Sub, <span class="number">1</span> <span class="keyword">do</span>
      numSubs = numSubs + #self.Zones.Sub[ _i].AllTypes
    <span class="keyword">end</span>

    <a id="2079"></a><span class="comment">--------------Execution Times
</span>    <span class="keyword">local</span> _trun = <span class="number">4</span>
    <span class="keyword">local</span> exe_ConfigParse  = SPECTRE.Utils.trunc((self.DebugLog.ConfigParse.Time.stop - self.DebugLog.ConfigParse.Time.start), _trun) <span class="keyword">or</span> <span class="string">"nul"</span>
    <span class="keyword">local</span> exe_WeightZones  = SPECTRE.Utils.trunc((self.DebugLog.WeightZones.Time.stop - self.DebugLog.WeightZones.Time.start), _trun) <span class="keyword">or</span> <span class="string">"nul"</span>
    <span class="keyword">local</span> exe_Spawn        = SPECTRE.Utils.trunc((self.DebugLog.Spawn.Time.stop       - self.DebugLog.Spawn.Time.start), _trun) <span class="keyword">or</span> <span class="string">"nul"</span>
    <span class="keyword">local</span> exe_GroupCenters = SPECTRE.Utils.trunc((self.DebugLog.Set_Vec2_GroupCenters.Time.stop - self.DebugLog.Set_Vec2_GroupCenters.Time.start), _trun) <span class="keyword">or</span> <span class="string">"nul"</span>
    <span class="keyword">local</span> exe_Types        = SPECTRE.Utils.trunc((self.DebugLog.Set_Vec2_Types.Time.stop        - self.DebugLog.Set_Vec2_Types.Time.start), _trun) <span class="keyword">or</span> <span class="string">"nul"</span>
    <span class="keyword">local</span> exe_Generation   = SPECTRE.Utils.trunc((self.DebugLog.GenerationProcess.Time.stop     - self.DebugLog.GenerationProcess.Time.start), _trun) <span class="keyword">or</span> <span class="string">"nul"</span>

    report:Add(<span class="string">"Total Types Spawned: "</span> .. numTypes .. <span class="string">" | Main Zone: "</span> .. numMain .. <span class="string">" | Sub Zones: "</span> .. numSubs)
    report:Add(<span class="string">" "</span>)
    report:Add(<span class="string">"Total  Run  Time   : "</span> .. exe_Generation ..<span class="string">"s"</span>)
    report:Add(<span class="string">" "</span>)
    report:Add(<span class="string">"Execution Times |================================================="</span>)
    report:Add(<span class="string">" "</span>)
    report:Add(<span class="string">"Config: "</span> .. exe_ConfigParse .. <span class="string">"s "</span> .. <span class="string">" | Zones: "</span> .. exe_WeightZones .. <span class="string">"s | Groups: "</span> .. exe_GroupCenters .. <span class="string">"s | Spawn: "</span> .. exe_Spawn .. <span class="string">"s"</span>)
    report:Add(<span class="string">"Other: "</span> .. <span class="global">math</span>.abs(exe_Generation - (exe_ConfigParse+exe_WeightZones+exe_Spawn+exe_GroupCenters+exe_Types))  .. <span class="string">"s "</span>)
    report:Add(<span class="string">"Types: "</span> .. exe_Types .. <span class="string">"s"</span>)
    report:Add(<span class="string">" "</span>)
    <span class="comment">-------------Types
</span>

    <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - DebugMessage - AllTypesMain "</span>)
      BASE:E(self.Zones.Main.AllTypes)
      <span class="keyword">for</span> _i = <span class="number">1</span>, #self.Zones.Sub, <span class="number">1</span> <span class="keyword">do</span>
        BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - DebugMessage - AllTypes sub "</span> .. _i)
        BASE:E(self.Zones.Sub[_i].AllTypes)
      <span class="keyword">end</span>
    <span class="keyword">end</span>

    report:Add(<span class="string">"================================= Types Spawned | Overall: "</span>)
    <span class="keyword">local</span> countMerged = SPECTRE.Utils.CountValues(self.AllTypes)
    <span class="keyword">for</span> _k,_v <span class="keyword">in</span> <span class="global">pairs</span>(countMerged) <span class="keyword">do</span>
      report:AddIndent(_k .. <span class="string">" : "</span> .. _v, <span class="string">"-"</span>)
    <span class="keyword">end</span>
    <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - DebugMessage - self.AllTypes "</span>)
      BASE:E(self.AllTypes)
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - DebugMessage - self.AllTypes counts "</span>)
      BASE:E(countMerged)
    <span class="keyword">end</span>

    <span class="keyword">if</span> self.DebugSummaryOnly == <span class="keyword">false</span> <span class="keyword">or</span> self.DebugSummaryOnly == <span class="keyword">nil</span> <span class="keyword">then</span>

      report:Add(<span class="string">" "</span>)
      report:Add(<span class="string">"================================= Types Spawned | Main Zone: "</span> .. self.Zones.Main.name)
      <span class="keyword">local</span> countMain = SPECTRE.Utils.CountValues(self.Zones.Main.AllTypes)
      <span class="keyword">for</span> _k,_v <span class="keyword">in</span> <span class="global">pairs</span>(countMain) <span class="keyword">do</span>
        report:AddIndent(_k .. <span class="string">" : "</span> .. _v, <span class="string">"-"</span>)
      <span class="keyword">end</span>
      <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
        BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - DebugMessage - result main"</span>)
        BASE:E(countMain)
      <span class="keyword">end</span>


      <span class="keyword">for</span> _i = <span class="number">1</span>, #self.Zones.Sub, <span class="number">1</span> <span class="keyword">do</span>
        report:Add(<span class="string">" "</span>)
        report:Add(<span class="string">"================================= Types Spawned | Sub Zones: "</span> .. self.Zones.Sub[_i].name)
        <span class="keyword">local</span> countSub = SPECTRE.Utils.CountValues(self.Zones.Sub[_i].AllTypes)
        <span class="keyword">for</span> _k,_v <span class="keyword">in</span> <span class="global">pairs</span>(countSub) <span class="keyword">do</span>
          report:AddIndent(_k .. <span class="string">" : "</span> .. _v, <span class="string">"-"</span>)
        <span class="keyword">end</span>
        <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
          BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - DebugMessage - result sub "</span> .. _i)
          BASE:E(countSub)
        <span class="keyword">end</span>
      <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
      <span class="keyword">local</span> out = report:Text()
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - DebugMessage() - report:Text()"</span>)
      BASE:E(out)
    <span class="keyword">end</span>

    trigger.action.outText(report:Text(),<span class="number">20</span>, <span class="keyword">false</span>)
  <span class="keyword">end</span>
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.DebugMessage.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER: DebugMessage - Time: "</span> .. self.DebugLog.DebugMessage.Time.stop - self.DebugLog.DebugMessage.Time.start)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">---Generates and activates the SPECTRE.DYNAMIC_SPAWNER based on provided configs/settings.
</span><span class="comment">--
</span><span class="comment">-- Runs through:
</span><span class="comment">--
</span><span class="comment">--         self:ConfigParse()
</span><span class="comment">--         self:WeightZones()
</span><span class="comment">--         self:SetNumTypesPerZone()
</span><span class="comment">--         self:SetGroupsPerZone()
</span><span class="comment">--         self:SetGroupTypes()
</span><span class="comment">--         self:SetGroupTypesTemplates()
</span><span class="comment">--         self:DetermineCoordinates()
</span><span class="comment">--         self:Spawn()
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self : the SPECTRE.DYNAMIC_SPAWNER OBJECT
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : self with tables added from the following operations:
</span><span class="comment">--
</span><span class="comment">--         SPECTRE.DYNAMIC_SPAWNER:ConfigParse()
</span><span class="comment">--         SPECTRE.DYNAMIC_SPAWNER:WeightZones()
</span><span class="comment">--         SPECTRE.DYNAMIC_SPAWNER:SetNumTypesPerZone()
</span><span class="comment">--         SPECTRE.DYNAMIC_SPAWNER:SetGroupsPerZone()
</span><span class="comment">--         SPECTRE.DYNAMIC_SPAWNER:SetGroupTypes()
</span><span class="comment">--         SPECTRE.DYNAMIC_SPAWNER:SetGroupTypesTemplates()
</span><span class="comment">--         SPECTRE.DYNAMIC_SPAWNER:DetermineCoordinates()
</span><span class="comment">--         SPECTRE.DYNAMIC_SPAWNER:Spawn()
</span><span class="comment">--
</span><a id="2190"></a><span class="comment">--         See specific above function for more details.
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER.GenerationProcess(self)
 <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.GenerationProcess = {Time = {},}
    self.DebugLog.GenerationProcess.Time.start = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - GenerationProcess() - start time"</span>)
    BASE:E(self.DebugLog.GenerationProcess.Time.start)
  <span class="keyword">end</span>
  self:ConfigParse()
  self:WeightZones()
  self:SetNumTypesPerZone()
  self:SetGroupsPerZone()
  self:SetGroupTypes()
  self:SetGroupTypesTemplates()
  self:DetermineCoordinates()
  self:Spawn()

  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.GenerationProcess.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - GenerationProcess() - Time: "</span> ..  self.DebugLog.GenerationProcess.Time.stop - self.DebugLog.GenerationProcess.Time.start)
    <span class="comment">--self:DEBUG_PRINT_self()
</span>  <span class="keyword">end</span>
  <span class="keyword">if</span> self.DebugMessages == <span class="number">1</span> <span class="keyword">then</span>
    self:DebugMessage()
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Determines the Vec2 for the center of each generated group in every zone.
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : self with added tables for .ObjectCoords.groupcenters and .GroupCenterVec2
</span><span class="comment">--
</span><span class="comment">--           self.Zones.Sub[_i].BuiltSpawner[_j][_k].GroupCenterVec2 = possibleVec2
</span><span class="comment">--           self.Zones.Sub[_i].ObjectCoords.groupcenters[#] = possibleVec2
</span><span class="comment">--           self.Zones.Main.ObjectCoords.groupcenters[#] = possibleVec2
</span><span class="comment">--           self.Zones.Main.BuiltSpawner[_j][_k].GroupCenterVec2 = possibleVec2
</span><span class="comment">-- where
</span><span class="comment">--
</span><span class="comment">--       _i = Number of the self.Zone.Sub table
</span><span class="comment">--       _j = # main group self.Sub[_i].GroupSettings or #self.Main.GroupSettings
</span><span class="comment">--       _k = # sub group in self.Sub[_i].GroupSettings.NumberGroups or #self.Main.GroupSettings.NumberGroups
</span><a id="2233"></a><span class="comment">--       possibleVec2 = {x = #, y = #,}
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:Set_Vec2_GroupCenters()
 <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - Set_Vec2_GroupCenters - Enter"</span>)
    self.DebugLog.Set_Vec2_GroupCenters = {Time = {},}
    self.DebugLog.Set_Vec2_GroupCenters.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>
  self.Zones.Main.ObjectCoords = { groupcenters = {} }

  <span class="keyword">for</span> i = <span class="number">1</span>, #self.Zones.Sub <span class="keyword">do</span>
    <span class="keyword">local</span> subZone = self.Zones.Sub[i]
    subZone.ObjectCoords = { groupcenters = {} }

    <span class="keyword">for</span> j = <span class="number">1</span>, #subZone.GroupSettings <span class="keyword">do</span>
      <span class="keyword">local</span> groupSettings = subZone.GroupSettings[j]
      <span class="keyword">local</span> numGroups = groupSettings.NumberGroups

      <span class="keyword">for</span> k = <span class="number">1</span>, numGroups <span class="keyword">do</span>
        <span class="keyword">local</span> possibleVec2
        <span class="keyword">local</span> flag_goodcoord = <span class="keyword">false</span>

        <span class="keyword">repeat</span>
          flag_goodcoord = <span class="keyword">true</span>

          possibleVec2 = subZone.zone:GetRandomVec2()

          <span class="keyword">if</span> <span class="keyword">not</span> self:vec2AtNoGoSurface(possibleVec2) <span class="keyword">then</span>
            flag_goodcoord = self:CheckVec2_NoGoZones(possibleVec2, self.Zones.Restricted)
          <span class="keyword">end</span>

          <span class="keyword">if</span> flag_goodcoord <span class="keyword">then</span>
            <span class="keyword">for</span> _, coords <span class="keyword">in</span> <span class="global">pairs</span>(subZone.ObjectCoords) <span class="keyword">do</span>
              <span class="keyword">local</span> distance

              <span class="keyword">if</span> coords == <span class="string">"units"</span> <span class="keyword">then</span>
                distance = groupSettings.minSeperation
              <span class="keyword">elseif</span> coords == <span class="string">"groupcenters"</span> <span class="keyword">then</span>
                distance = groupSettings.minSeparation_Groups
              <span class="keyword">else</span>
                distance = subZone.DistanceFromBuildings
              <span class="keyword">end</span>

              <span class="keyword">if</span> coords == <span class="string">"groupcenters"</span> <span class="keyword">then</span>
                <span class="keyword">for</span> _, checkCoord <span class="keyword">in</span> <span class="global">ipairs</span>(subZone.ObjectCoords[coords]) <span class="keyword">do</span>
                  <span class="keyword">if</span> SPECTRE.WORLD.f_distance(checkCoord, possibleVec2) &lt; distance <span class="keyword">then</span>
                    flag_goodcoord = <span class="keyword">false</span>
                    <span class="keyword">break</span>
                  <span class="keyword">end</span>
                <span class="keyword">end</span>
              <span class="keyword">end</span>

              <span class="keyword">if</span> <span class="keyword">not</span> flag_goodcoord <span class="keyword">then</span>
                <span class="keyword">break</span>
              <span class="keyword">end</span>
            <span class="keyword">end</span>
          <span class="keyword">end</span>
        <span class="keyword">until</span> flag_goodcoord

        subZone.BuiltSpawner[j][k].GroupCenterVec2 = possibleVec2
        subZone.ObjectCoords.groupcenters[#subZone.ObjectCoords.groupcenters + <span class="number">1</span>] = possibleVec2
        self.Zones.Main.ObjectCoords.groupcenters[#self.Zones.Main.ObjectCoords.groupcenters + <span class="number">1</span>] = possibleVec2
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">for</span> j = <span class="number">1</span>, #self.Zones.Main.GroupSettings <span class="keyword">do</span>
    <span class="keyword">local</span> groupSettings = self.Zones.Main.GroupSettings[j]
    <span class="keyword">local</span> numGroups = groupSettings.NumberGroups

    <span class="keyword">for</span> k = <span class="number">1</span>, numGroups <span class="keyword">do</span>
      <span class="keyword">local</span> possibleVec2
      <span class="keyword">local</span> flag_goodcoord = <span class="keyword">false</span>

      <span class="keyword">repeat</span>
        flag_goodcoord = <span class="keyword">true</span>

        possibleVec2 = self.Zones.Main.zone:GetRandomVec2()

        <span class="keyword">if</span> <span class="keyword">not</span> self:vec2AtNoGoSurface(possibleVec2) <span class="keyword">then</span>
          flag_goodcoord = self:CheckVec2_NoGoZones(possibleVec2, self.Zones.Restricted)
        <span class="keyword">end</span>

        <span class="keyword">if</span> flag_goodcoord <span class="keyword">then</span>
          <span class="keyword">for</span> _, coords <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones.Main.ObjectCoords) <span class="keyword">do</span>
            <span class="keyword">local</span> distance

            <span class="keyword">if</span> coords == <span class="string">"units"</span> <span class="keyword">then</span>
              distance = groupSettings.minSeperation
            <span class="keyword">elseif</span> coords == <span class="string">"groupcenters"</span> <span class="keyword">then</span>
              distance = groupSettings.minSeparation_Groups
            <span class="keyword">else</span>
              distance = self.Zones.Main.DistanceFromBuildings
            <span class="keyword">end</span>

            <span class="keyword">if</span> coords == <span class="string">"groupcenters"</span> <span class="keyword">then</span>
              <span class="keyword">for</span> _, checkCoord <span class="keyword">in</span> <span class="global">ipairs</span>(self.Zones.Main.ObjectCoords[coords]) <span class="keyword">do</span>
                <span class="keyword">if</span> SPECTRE.WORLD.f_distance(checkCoord, possibleVec2) &lt; distance <span class="keyword">then</span>
                  flag_goodcoord = <span class="keyword">false</span>
                  <span class="keyword">break</span>
                <span class="keyword">end</span>
              <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> <span class="keyword">not</span> flag_goodcoord <span class="keyword">then</span>
              <span class="keyword">break</span>
            <span class="keyword">end</span>
          <span class="keyword">end</span>
        <span class="keyword">end</span>
      <span class="keyword">until</span> flag_goodcoord

      self.Zones.Main.BuiltSpawner[j][k].GroupCenterVec2 = possibleVec2
      self.Zones.Main.ObjectCoords.groupcenters[#self.Zones.Main.ObjectCoords.groupcenters + <span class="number">1</span>] = possibleVec2
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.Set_Vec2_GroupCenters.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER: Set_Vec2_GroupCenters - Time: "</span> .. self.DebugLog.Set_Vec2_GroupCenters.Time.stop - self.DebugLog.Set_Vec2_GroupCenters.Time.start)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - Set_Vec2_GroupCenters() - self.Zones.Main.BuiltSpawner"</span>)
    BASE:E(self.Zones.Main.BuiltSpawner)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Determines the Vec2 for each of the Types of each generated group in every zone.
</span><span class="comment">--
</span><span class="comment">-- Creates a subzone around the group center and places all types within.
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : self with added tables for .zone, .ObjectCoords, .Vec2Types
</span><span class="comment">--
</span><span class="comment">--        self.Zones.Sub[_i].BuiltSpawner[_j][_k].zone = ZONE_RADIUS:New(tempZoneName,tempZoneVec2,tempZoneRadius)
</span><span class="comment">--        self.Zones.Sub[_i].BuiltSpawner[_j][_k].ObjectCoords = SPECTRE.DYNAMIC_SPAWNER.FindObjectsInZone(self.Zones.Sub[_i].BuiltSpawner[_j][_k].zone)
</span><span class="comment">--        self.Zones.Sub[_i].BuiltSpawner[_j][_k].Vec2Types[#] = possibleVec2
</span><span class="comment">--           and
</span><span class="comment">--        self.Zones.Main.BuiltSpawner[_j][_k].zone = ZONE_RADIUS:New(tempZoneName,tempZoneVec2,tempZoneRadius)
</span><span class="comment">--        self.Zones.Main.BuiltSpawner[_j][_k].ObjectCoords = SPECTRE.DYNAMIC_SPAWNER.FindObjectsInZone(self.Zones.Main.BuiltSpawner[_j][_k].zone)
</span><span class="comment">--        self.Zones.Main.BuiltSpawner[_j][_k].Vec2Types[#] = possibleVec2
</span><span class="comment">-- where
</span><span class="comment">--
</span><span class="comment">--       _i = Number of the self.Zone.Sub table
</span><span class="comment">--       _j = # main group self.Sub[_i].GroupSettings or #self.Main.GroupSettings
</span><span class="comment">--       _k = # sub group in self.Sub[_i].GroupSettings.NumberGroups or #self.Main.GroupSettings.NumberGroups
</span><span class="comment">--       tempZoneName = self.Zones.Sub[_i].name .. "z".. _i .. "j" .. _j .. "k" .. _k
</span><span class="comment">--                         or
</span><span class="comment">--                      self.Zones.Main.name .. "j" .. _j .. "k" .. _k
</span><span class="comment">--       tempZoneVec2 = self.Zones.Sub[_i].BuiltSpawner[_j][_k].GroupCenterVec2
</span><span class="comment">--                         or
</span><span class="comment">--                      self.Zones.Main.BuiltSpawner[_j][_k].GroupCenterVec2
</span><span class="comment">--       tempZoneRadius = (_distanceFromUnits * _groupSize) + (_distanceFromGroups * _numGroup ) + _distanceFromBuildings
</span><a id="2383"></a><span class="comment">--       possibleVec2 = {x = #, y = #,}
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:Set_Vec2_Types()
 <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.Set_Vec2_Types = {Time = {},}
    self.DebugLog.Set_Vec2_Types.Time.start = <span class="global">os</span>.clock()
  <span class="keyword">end</span>
  <span class="comment">--local counter_operation = 0
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - Set_Vec2_Types() - ENTER"</span>)
  <span class="keyword">end</span>

  <span class="keyword">local</span> <span class="keyword">function</span> generateVec2Types(zone, groupSettings, distanceFromBuildings)
    <span class="keyword">local</span> vec2Types = {}
    <span class="keyword">local</span> objectCoords = SPECTRE.DYNAMIC_SPAWNER.FindObjectsInZone(zone)
    <span class="keyword">local</span> groupSize = groupSettings.GroupSize
    <span class="keyword">local</span> numGroups = groupSettings.NumberGroups
    <span class="keyword">local</span> distanceFromUnits = groupSettings.maxSeperation
    <span class="keyword">local</span> distanceFromGroups = groupSettings.minSeparation_Groups

    <span class="keyword">for</span> typeNum = <span class="number">1</span>, groupSize + self.Config.numExtraUnits <span class="keyword">do</span>
      <span class="keyword">local</span> possibleVec2
      <span class="keyword">local</span> flag_goodcoord = <span class="keyword">false</span>

      <span class="keyword">repeat</span>
        flag_goodcoord = <span class="keyword">true</span>
        possibleVec2 = zone:GetRandomVec2()

        <span class="keyword">for</span> _, coords <span class="keyword">in</span> <span class="global">pairs</span>(objectCoords) <span class="keyword">do</span>
          <span class="keyword">local</span> distance = coords == <span class="string">"units"</span> <span class="keyword">and</span> groupSettings.minSeperation <span class="keyword">or</span> distanceFromBuildings

          <span class="keyword">for</span> _, checkCoord <span class="keyword">in</span> <span class="global">ipairs</span>(coords) <span class="keyword">do</span>
            <span class="keyword">if</span> SPECTRE.WORLD.f_distance(checkCoord, possibleVec2) &lt; distance <span class="keyword">then</span>
              flag_goodcoord = <span class="keyword">false</span>
              <span class="keyword">break</span>
            <span class="keyword">end</span>
          <span class="keyword">end</span>

          <span class="keyword">if</span> <span class="keyword">not</span> flag_goodcoord <span class="keyword">then</span>
            <span class="keyword">break</span>
          <span class="keyword">end</span>
        <span class="keyword">end</span>
      <span class="keyword">until</span> flag_goodcoord

      vec2Types[typeNum] = possibleVec2
      objectCoords.units[#objectCoords.units + <span class="number">1</span>] = possibleVec2
    <span class="keyword">end</span>

    <span class="keyword">return</span> vec2Types, objectCoords
  <span class="keyword">end</span>

  <span class="keyword">for</span> i = <span class="number">1</span>, #self.Zones.Sub <span class="keyword">do</span>
    <span class="keyword">local</span> subZone = self.Zones.Sub[i]

    <span class="keyword">for</span> j = <span class="number">1</span>, #subZone.GroupSettings <span class="keyword">do</span>
      <span class="keyword">local</span> groupSettings = subZone.GroupSettings[j]

      <span class="keyword">for</span> k = <span class="number">1</span>, groupSettings.NumberGroups <span class="keyword">do</span>
        <span class="keyword">local</span> builtSpawner = subZone.BuiltSpawner[j][k]
        <span class="keyword">local</span> tempZoneName = subZone.name .. <span class="string">"z"</span> .. i .. <span class="string">"j"</span> .. j .. <span class="string">"k"</span> .. k
        <span class="keyword">local</span> tempZoneVec2 = builtSpawner.GroupCenterVec2
        <span class="keyword">local</span> tempZoneRadius = (groupSettings.maxSeperation * groupSettings.GroupSize) +
          (groupSettings.minSeparation_Groups * groupSettings.NumberGroups) +
          subZone.DistanceFromBuildings

        builtSpawner.zone = ZONE_RADIUS:New(tempZoneName, tempZoneVec2, tempZoneRadius)
        builtSpawner.Vec2Types, builtSpawner.ObjectCoords = generateVec2Types(builtSpawner.zone, groupSettings, subZone.DistanceFromBuildings)
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">for</span> j = <span class="number">1</span>, #self.Zones.Main.GroupSettings <span class="keyword">do</span>
    <span class="keyword">local</span> groupSettings = self.Zones.Main.GroupSettings[j]

    <span class="keyword">for</span> k = <span class="number">1</span>, groupSettings.NumberGroups <span class="keyword">do</span>
      <span class="keyword">local</span> builtSpawner = self.Zones.Main.BuiltSpawner[j][k]
      <span class="keyword">local</span> tempZoneName = self.Zones.Main.name .. <span class="string">"j"</span> .. j .. <span class="string">"k"</span> .. k
      <span class="keyword">local</span> tempZoneVec2 = builtSpawner.GroupCenterVec2
      <span class="keyword">local</span> tempZoneRadius = (groupSettings.maxSeperation * groupSettings.GroupSize) +
        (groupSettings.minSeparation_Groups * groupSettings.NumberGroups) +
        self.Zones.Main.DistanceFromBuildings

      builtSpawner.zone = ZONE_RADIUS:New(tempZoneName, tempZoneVec2, tempZoneRadius)
      builtSpawner.Vec2Types, builtSpawner.ObjectCoords = generateVec2Types(builtSpawner.zone, groupSettings, self.Zones.Main.DistanceFromBuildings)
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    self.DebugLog.Set_Vec2_Types.Time.stop = <span class="global">os</span>.clock()
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - Set_Vec2_Types() - Time: "</span> .. self.DebugLog.Set_Vec2_Types.Time.stop - self.DebugLog.Set_Vec2_Types.Time.start)
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - Set_Vec2_Types() - self.Zones.Main.BuiltSpawner"</span>)
    BASE:E(self.Zones.Main.BuiltSpawner)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Find all Object entities in all spawner related main and sub zones.
</span><span class="comment">--
</span><span class="comment">-- Finds the following, then adds them to a table for tracking:
</span><span class="comment">--
</span><span class="comment">--       Object.Category.SCENERY
</span><span class="comment">--       Object.Category.STATIC
</span><span class="comment">--       Object.Category.UNIT
</span><span class="comment">--       Unit.Category.GROUND_UNIT
</span><span class="comment">--       Unit.Category.STRUCTURE
</span><span class="comment">--       Unit.Category.SHIP
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @return #DYNAMIC_SPAWNER self : self with an added ObjectCoords table of all objects detected in zone.
</span><span class="comment">--
</span><span class="comment">--        self.Zones.Sub[_i].ObjectCoords = ObjectCoords
</span><span class="comment">--        self.Zones.Main.ObjectCoords = ObjectCoords
</span><span class="comment">-- where
</span><span class="comment">--
</span><span class="comment">--        _i = subzone key number in self.Zones.Sub table
</span><span class="comment">--        ObjectCoords = {
</span><span class="comment">--                          building = {DATA},
</span><span class="comment">--                          others   = {DATA},
</span><span class="comment">--                          units    = {DATA},
</span><a id="2500"></a><span class="comment">--                       }
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:FindObjects()
  <span class="keyword">local</span> <span class="keyword">function</span> processObjects(zone)
    <span class="keyword">local</span> ObjectCoords = {
      buildings = {},
      others = {},
      units = {}
    }
    <span class="keyword">local</span> objects = zone.ScanData <span class="keyword">and</span> zone.ScanData.Scenery <span class="keyword">or</span> {}
    <span class="keyword">local</span> units = zone.ScanData <span class="keyword">and</span> zone.ScanData.Units <span class="keyword">or</span> {}
    <span class="keyword">local</span> sceneryTable = zone.ScanData <span class="keyword">and</span> zone.ScanData.SceneryTable <span class="keyword">or</span> {}

    <span class="keyword">for</span> _, _object <span class="keyword">in</span> <span class="global">pairs</span>(objects) <span class="keyword">do</span>
      <span class="keyword">for</span> _, _scen <span class="keyword">in</span> <span class="global">pairs</span>(_object) <span class="keyword">do</span>
        <span class="keyword">local</span> scenery = _scen
        <span class="keyword">local</span> description = scenery:GetDesc()
        <span class="keyword">if</span> description <span class="keyword">and</span> description.attributes <span class="keyword">and</span> description.attributes.Buildings <span class="keyword">then</span>
          ObjectCoords.buildings[#ObjectCoords.buildings + <span class="number">1</span>] = { x = scenery:GetCoordinate().x, y = scenery:GetCoordinate().z }
        <span class="keyword">else</span>
          ObjectCoords.others[#ObjectCoords.others + <span class="number">1</span>] = { x = scenery.SceneryObject:getPosition().p.x, y = scenery.SceneryObject:getPosition().p.z }
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">for</span> _, _object <span class="keyword">in</span> <span class="global">pairs</span>(units) <span class="keyword">do</span>
      <span class="keyword">local</span> unitPosition = UNIT:FindByName(_object:getName()):GetPosition()
      ObjectCoords.units[#ObjectCoords.units + <span class="number">1</span>] = { x = unitPosition.p.x, y = unitPosition.p.z }
    <span class="keyword">end</span>

    <span class="keyword">for</span> _, sceneryObject <span class="keyword">in</span> <span class="global">ipairs</span>(sceneryTable) <span class="keyword">do</span>
      ObjectCoords.others[#ObjectCoords.others + <span class="number">1</span>] = { x = sceneryObject.SceneryObject:getPosition().p.x, y = sceneryObject.SceneryObject:getPosition().p.z }
    <span class="keyword">end</span>

    <span class="keyword">return</span> ObjectCoords
  <span class="keyword">end</span>

  <span class="keyword">for</span> i = <span class="number">1</span>, #self.Zones.Sub <span class="keyword">do</span>
    self.Zones.Sub[i].ObjectCoords = processObjects(self.Zones.Sub[i].zone)
  <span class="keyword">end</span>

  self.Zones.Main.ObjectCoords = processObjects(self.Zones.Main.zone)

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Find all Object entities in provided ZONE_RADIUS object.
</span><span class="comment">--
</span><span class="comment">-- Finds the following, then adds them to a table for tracking:
</span><span class="comment">--
</span><span class="comment">--       Object.Category.SCENERY
</span><span class="comment">--       Object.Category.STATIC
</span><span class="comment">--       Object.Category.UNIT
</span><span class="comment">--       Unit.Category.GROUND_UNIT
</span><span class="comment">--       Unit.Category.STRUCTURE
</span><span class="comment">--       Unit.Category.SHIP
</span><span class="comment">-- @param _zone: ZONE_RADIUS object to scan for objects.
</span><span class="comment">-- @return ObjectCoords : table of all objects detected in zone.
</span><span class="comment">--
</span><span class="comment">--        ObjectCoords = {
</span><span class="comment">--                          building = {DATA},
</span><span class="comment">--                          others   = {DATA},
</span><span class="comment">--                          units    = {DATA},
</span><span class="comment">--                       }
</span><a id="2563"></a><span class="comment">--
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER.FindObjectsInZone(_zone)
  <span class="keyword">local</span> ObjectCoords = {
    buildings = {},
    others = {},
    units = {}
  }

  _zone:Scan({Object.Category.SCENERY, Object.Category.STATIC, Object.Category.UNIT}, {Unit.Category.GROUND_UNIT, Unit.Category.STRUCTURE, Unit.Category.SHIP})

  <span class="keyword">local</span> scanData = _zone.ScanData
  <span class="keyword">if</span> scanData <span class="keyword">then</span>
    <span class="comment">-- Scenery and Static objects
</span>    <span class="keyword">if</span> scanData.Scenery <span class="keyword">then</span>
      <span class="keyword">for</span> _, sceneryList <span class="keyword">in</span> <span class="global">pairs</span>(scanData.Scenery) <span class="keyword">do</span>
        <span class="keyword">for</span> _, scenery <span class="keyword">in</span> <span class="global">pairs</span>(sceneryList) <span class="keyword">do</span>
          <span class="keyword">local</span> description = scenery:GetDesc()
          <span class="keyword">if</span> description <span class="keyword">and</span> description.attributes <span class="keyword">and</span> description.attributes.Buildings <span class="keyword">then</span>
            ObjectCoords.buildings[#ObjectCoords.buildings + <span class="number">1</span>] = {x = scenery:GetCoordinate().x, y = scenery:GetCoordinate().z}
          <span class="keyword">else</span>
            ObjectCoords.others[#ObjectCoords.others + <span class="number">1</span>] = {x = scenery.SceneryObject:getPosition().p.x, y = scenery.SceneryObject:getPosition().p.z}
          <span class="keyword">end</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">-- Units
</span>    <span class="keyword">if</span> scanData.Units <span class="keyword">then</span>
      <span class="keyword">for</span> _, unit <span class="keyword">in</span> <span class="global">pairs</span>(scanData.Units) <span class="keyword">do</span>
        ObjectCoords.units[#ObjectCoords.units + <span class="number">1</span>] = {x = UNIT:FindByName(unit:getName()):GetPosition().p.x, y = UNIT:FindByName(unit:getName()):GetPosition().p.z}
      <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">-- Scenery Table
</span>    <span class="keyword">if</span> scanData.SceneryTable <span class="keyword">then</span>
      <span class="keyword">for</span> _, scenery <span class="keyword">in</span> <span class="global">ipairs</span>(scanData.SceneryTable) <span class="keyword">do</span>
        ObjectCoords.others[#ObjectCoords.others + <span class="number">1</span>] = {x = scenery.SceneryObject:getPosition().p.x, y = scenery.SceneryObject:getPosition().p.z}
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">return</span> ObjectCoords
<span class="keyword">end</span>

<span class="comment">---Checks the surface at a vec2 and compares vs nogo surfaces.
</span><span class="comment">--
</span><span class="comment">-- If surface is nogo, returns true.
</span><span class="comment">--
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param vec2 to check surface of
</span><span class="comment">-- @return true vec is a nogo surface
</span><a id="2614"></a><span class="comment">-- @return false vec is not a nogo surface
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:vec2AtNoGoSurface(vec2)
 <span class="comment">-- local DEBUG = false or self.DebugEnabled
</span>
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - vec2AtNoGoSurface - "</span>)
  <span class="keyword">end</span>

  <span class="keyword">local</span> surfaceType = COORDINATE:NewFromVec2(vec2):GetSurfaceType()

  <span class="keyword">local</span> Surfaces = {
    LAND = <span class="keyword">true</span>,
    SHALLOW_WATER = <span class="keyword">true</span>,
    WATER = <span class="keyword">true</span>,
    ROAD = <span class="keyword">true</span>,
    RUNWAY = <span class="keyword">true</span>,
  }

  surfaceType = Surfaces[surfaceType] <span class="keyword">and</span> surfaceType <span class="keyword">or</span> <span class="keyword">nil</span>



  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - vec2AtNoGoSurface - surfaceType"</span>)
    BASE:E(surfaceType)
  <span class="keyword">end</span>
  <span class="keyword">if</span> surfaceType == <span class="keyword">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">end</span>
  <span class="keyword">for</span> _, noGoSurface <span class="keyword">in</span> <span class="global">ipairs</span>(self.NoGoSurface) <span class="keyword">do</span>
    <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
      BASE:E(<span class="string">"SPECTRE|DYNAMIC_SPAWNER - vec2AtNoGoSurface - noGoSurface"</span>)
      BASE:E(noGoSurface)
    <span class="keyword">end</span>
    <span class="keyword">if</span> noGoSurface == surfaceType <span class="keyword">then</span>
      <span class="keyword">return</span> <span class="keyword">true</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">return</span> <span class="keyword">false</span>
<span class="keyword">end</span>

<span class="comment">--- Determines if vec2 is in the zone.
</span><span class="comment">--
</span><span class="comment">-- Multithreaded version of what is available in the SPECTRE.WORLD class.
</span><span class="comment">--
</span><span class="comment">-- Requires quadpoint zone, defined in ME.
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param vec2 : Vec2 to check, {x = , y = }
</span><span class="comment">-- @param zoneName : Name of quadpoint zone, defined in Mission Editor.
</span><a id="2662"></a><span class="comment">-- @return result : true or false
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:PointInZone(vec2, zoneName)
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"DEBUG - PointInZone - zoneName"</span>)
    BASE:E(zoneName)
  <span class="keyword">end</span>
  <span class="keyword">local</span> _zone = mist.DBs.zonesByName[zoneName]
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"DEBUG - PointInZone - _zone"</span>)
    BASE:E(_zone)
  <span class="keyword">end</span>
  <span class="keyword">local</span> box =  _zone.verticies
  <span class="keyword">local</span> _vec2 = {}
  <span class="keyword">if</span> vec2.x == <span class="keyword">nil</span> <span class="keyword">then</span>
    _vec2.x = vec2[<span class="number">1</span>]
    _vec2.y = vec2[<span class="number">2</span>]
  <span class="keyword">else</span>
    _vec2 = vec2
  <span class="keyword">end</span>
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"DEBUG - PointInZone - vec2"</span>)
    BASE:E(vec2)
    BASE:E(<span class="string">"DEBUG - PointInZone - _vec2"</span>)
    BASE:E(_vec2)
    BASE:E(<span class="string">"DEBUG - PointInZone - bo2x"</span>)
    BASE:E(box)
  <span class="keyword">end</span>
  <span class="comment">-- self:CO_Yield(self.Config.operationLimit)
</span>  <span class="keyword">local</span> result = self:PointWithinShape(_vec2, box)<span class="comment">--SPECTRE.POLY.PointWithinShape(_vec2, box)
</span>  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"SPECTRE|WORLD - PointInZone - result"</span>)
    BASE:E(result)
  <span class="keyword">end</span>
  <span class="keyword">return</span> result
<span class="keyword">end</span>

<span class="comment">--- Determines if vec2 is in a list of zones.
</span><span class="comment">--
</span><span class="comment">-- Multithreaded version of what is available in the SPECTRE.WORLD class.
</span><span class="comment">--
</span><span class="comment">-- Requires quadpoint zones, defined in ME.
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param vec2 : Vec2 to check, {x = , y = }
</span><span class="comment">-- @param zoneList : List of Names of quadpoint zone, defined in Mission Editor.
</span><span class="comment">--
</span><span class="comment">--        zoneList = {"name1","name2",...,n,}
</span><span class="comment">-- @return 1 = not in zones
</span><a id="2709"></a><span class="comment">-- @return 0 = Vec2 is in Nogo zones
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:CheckVec2_NoGoZones(possibleVec2,zoneList)
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"DEBUG - CheckVec2_NoGoZones - zoneNameList"</span>)
    BASE:E(zoneList)
    BASE:E(<span class="string">"DEBUG - CheckVec2_NoGoZones - vec2"</span>)
    BASE:E(possibleVec2)
  <span class="keyword">end</span>
  <span class="keyword">local</span> result
  <span class="keyword">for</span> _v = <span class="number">1</span>, #zoneList, <span class="number">1</span> <span class="keyword">do</span>
    <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
      BASE:E(<span class="string">"SPECTRE|WORLD - CheckVec2_NoGoZones - vec2"</span>)
      BASE:E(possibleVec2)
      BASE:E(<span class="string">"SPECTRE|WORLD - CheckVec2_NoGoZones - zoneNameList[_v]"</span>)
      BASE:E(zoneList[_v])
    <span class="keyword">end</span>
    result = self:PointInZone(possibleVec2, zoneList[_v])<span class="comment">--SPECTRE.DYNAMIC_SPAWNER.PointInZone(possibleVec2, zoneList[_v])
</span>    <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
      BASE:E(<span class="string">"SPECTRE|WORLD - CheckVec2_NoGoZones - result"</span>)
      BASE:E(result)
    <span class="keyword">end</span>
    <span class="keyword">if</span> result <span class="keyword">then</span>
      <span class="keyword">return</span> <span class="number">0</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> <span class="number">1</span>
<span class="keyword">end</span>



<span class="comment">---DYNAMIC_SPAWNER.PointWithinShape.
</span><span class="comment">-- ===
</span><span class="comment">-- Checks if point is within shape.
</span><span class="comment">--
</span><span class="comment">-- Multithreaded version of what is available in SPECTRE.WORLD
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section DYNAMIC_SPAWNER.PointWithinShape
</span>

<span class="comment">---PointWithinShape.
</span><span class="comment">--
</span><span class="comment">--       1. Draw a horizontal line to the right of each point and extend it to infinity.
</span><span class="comment">--       2. Count the number of times the line intersects with polygon edges.
</span><span class="comment">--       3. A point is inside the polygon if either count of intersections is odd or point lies on an edge of polygon.
</span><span class="comment">--       4. If none of the conditions is true, then point lies outside.
</span><span class="comment">-- @param #DYNAMIC_SPAWNER self
</span><span class="comment">-- @param P The vec2 to test whether inside polygon or not.
</span><span class="comment">--
</span><span class="comment">--           P = {x=#,y=#}
</span><span class="comment">-- @param Polygon Polygon to test P against. Table of Vec2 points. #Polygon must be &gt;= 4
</span><span class="comment">--
</span><span class="comment">--        Polygon = {
</span><span class="comment">--                    [1] = {x = #, y = #},
</span><span class="comment">--                    [...] = {x = #, y = #},
</span><span class="comment">--                    [n] = {x = #, y = #},
</span><span class="comment">-- @return true
</span><a id="2766"></a><span class="comment">-- @return false
</span><span class="keyword">function</span> SPECTRE.DYNAMIC_SPAWNER:PointWithinShape(point, polygon)
  <span class="keyword">if</span> self.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    BASE:E(<span class="string">"DEBUG - PointWithinShape - 1"</span>)
  <span class="keyword">end</span>
  <span class="keyword">local</span> i, j = #polygon, <span class="number">1</span>
  <span class="keyword">local</span> oddNodes = <span class="keyword">false</span>
  <span class="keyword">for</span> i = <span class="number">1</span>, #polygon <span class="keyword">do</span>
    <span class="keyword">if</span> (polygon[i].y &lt; point.y <span class="keyword">and</span> polygon[j].y &gt;= point.y <span class="keyword">or</span> polygon[j].y &lt; point.y <span class="keyword">and</span> polygon[i].y &gt;= point.y) <span class="keyword">then</span>
      <span class="keyword">if</span> (polygon[i].x + (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) * (polygon[j].x - polygon[i].x) &lt; point.x) <span class="keyword">then</span>
        oddNodes = <span class="keyword">not</span> oddNodes
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    j = i
  <span class="keyword">end</span>
  <span class="keyword">return</span> oddNodes
<span class="keyword">end</span></pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2023-06-15 13:10:10 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
