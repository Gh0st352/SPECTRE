<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>S.P.E.C.T.R.E.</h1>


<ul>
  <li><a href="../manual.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="nowrap">
  <li><a href="../source/ai.lua.html">ai.lua</a></li>
  <li><a href="../source/brain.lua.html">brain.lua</a></li>
  <li><a href="../source/handlers.lua.html">handlers.lua</a></li>
  <li><a href="../source/iads.lua.html">iads.lua</a></li>
  <li><a href="../source/io.lua.html">io.lua</a></li>
  <li><a href="../source/markers.lua.html">markers.lua</a></li>
  <li><a href="../source/menu.lua.html">menu.lua</a></li>
  <li><a href="../source/plyrmgr.lua.html">plyrmgr.lua</a></li>
  <li><a href="../source/poly.lua.html">poly.lua</a></li>
  <li><a href="../source/rewards.lua.html">rewards.lua</a></li>
  <li><a href="../source/spawner.lua.html">spawner.lua</a></li>
  <li><a href="../source/spectre.lua.html">spectre.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/world.lua.html">world.lua</a></li>
  <li><strong>zonemgr.lua</strong></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/AI.html">AI</a></li>
  <li><a href="../modules/BRAIN.html">BRAIN</a></li>
  <li><a href="../modules/HANDLERS.html">HANDLERS</a></li>
  <li><a href="../modules/IADS.html">IADS</a></li>
  <li><a href="../modules/IO.html">IO</a></li>
  <li><a href="../modules/MARKERS.html">MARKERS</a></li>
  <li><a href="../modules/MENU.html">MENU</a></li>
  <li><a href="../modules/PLYRMGR.html">PLYRMGR</a></li>
  <li><a href="../modules/POLY.html">POLY</a></li>
  <li><a href="../modules/REWARDS.html">REWARDS</a></li>
  <li><a href="../modules/SPAWNER.html">SPAWNER</a></li>
  <li><a href="../modules/SPECTRE.html">SPECTRE</a></li>
  <li><a href="../modules/UTILS.html">UTILS</a></li>
  <li><a href="../modules/WORLD.html">WORLD</a></li>
  <li><a href="../modules/ZONEMGR.html">ZONEMGR</a></li>
</ul>
<h2>Topics</h2>
<ul class="">
  <li><a href="../topics/readme.md.html">readme</a></li>
</ul>

</div>

<div id="content">

    <h2>zonemgr.lua</h2>
<pre>
<span class="comment">--- **ZONEMGR**
</span><span class="comment">--
</span><span class="comment">-- The brain of SPECTRE, allowing the game to interpret various units positioning and data with ML strategies.
</span><span class="comment">--
</span><span class="comment">-- Intelligently manage hotspots, intelligence, sitrep, and automated spawning in the zones.
</span><span class="comment">--
</span><span class="comment">-- The <a href="../modules/ZONEMGR.html#">ZONEMGR</a> module within the SPECTRE system is designed for dynamic zone management,
</span><span class="comment">-- offering a centralized approach to handle various zone-related operations.
</span><span class="comment">--
</span><span class="comment">-- @module ZONEMGR
</span><span class="comment">-- @extends SPECTRE
</span>
<span class="comment">--- 1 - Zone Manager.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with Zone Manager operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span>
<span class="comment">--- SPECTRE.ZONEMGR.
</span><span class="comment">--
</span><span class="comment">-- The brain of SPECTRE, allowing the game to interpret various units positioning and data with ML strategies.
</span><span class="comment">--
</span><span class="comment">-- Intelligently manage hotspots, intelligence, sitrep, and automated spawning in the zones.
</span><span class="comment">--
</span><span class="comment">-- The <a href="../modules/ZONEMGR.html#">ZONEMGR</a> module within the SPECTRE system is designed for dynamic zone management,
</span><span class="comment">-- offering a centralized approach to handle various zone-related operations.
</span><span class="comment">--
</span><a id="31"></a><span class="comment">-- @field #ZONEMGR
</span>SPECTRE.ZONEMGR = {}

<span class="comment">--- Configurations for ZONEMGR operations.
</span><a id="35"></a><span class="comment">-- @field #ZONEMGR.Config Configuration table with operation limit.
</span>SPECTRE.ZONEMGR.Config = {}

<span class="comment">--- Maximum number of operations that ZONEMGR can handle.
</span><a id="39"></a><span class="comment">-- Defines the upper limit for ZONEMGR operations.
</span>SPECTRE.ZONEMGR.Config.operationLimit = <span class="number">150</span>

<span class="comment">--- Minimum value for random seed generation.
</span><a id="43"></a><span class="comment">-- Sets the lower bound for random seed values.
</span>SPECTRE.ZONEMGR._randSeedMin = <span class="number">500</span>

<span class="comment">--- Maximum value for random seed generation.
</span><a id="47"></a><span class="comment">-- Sets the upper bound for random seed values.
</span>SPECTRE.ZONEMGR._randSeedMax = <span class="number">2000</span>

<span class="comment">--- Nominal value for random seed generation.
</span><a id="51"></a><span class="comment">-- The default or standard seed value used in randomization.
</span>SPECTRE.ZONEMGR._randSeedNom = <span class="number">2000</span>

<span class="comment">--- Nudge factor for random seed adjustment.
</span><a id="55"></a><span class="comment">-- Modifier to fine-tune the randomization process.
</span>SPECTRE.ZONEMGR._randSeedNudge = <span class="number">0.7</span>

<span class="comment">--- Flag for enabling persistence functionality.
</span><a id="59"></a><span class="comment">-- Indicates if persistence is active in ZONEMGR.
</span>SPECTRE.ZONEMGR._persistence = <span class="keyword">false</span>

SPECTRE.ZONEMGR._markerScheduler = {}
SPECTRE.ZONEMGR._markerQueue = {}
SPECTRE.ZONEMGR._removeMarkerQueue = {}
SPECTRE.ZONEMGR._hotspotQueue = {}
SPECTRE.ZONEMGR._HotspotSched = {}

<span class="comment">--- WIP.
</span><span class="comment">-- Flag for enabling CAP functionality.
</span><a id="70"></a><span class="comment">-- Indicates if CAP Defense is active in ZONEMGR.
</span>SPECTRE.ZONEMGR._enableCAP = <span class="keyword">false</span>
SPECTRE.ZONEMGR.UpdatingCAP = <span class="keyword">false</span>
SPECTRE.ZONEMGR.COUNTER = <span class="number">1</span>
SPECTRE.ZONEMGR.Handler_ = EVENT:New()
SPECTRE.ZONEMGR.schedulerCAPMin = <span class="number">20</span>
SPECTRE.ZONEMGR.schedulerCAPMax = <span class="number">30</span>
SPECTRE.ZONEMGR.schedulerCAPFactor = <span class="number">0.25</span>

<span class="comment">--- WIP.
</span><span class="comment">-- Flag for enabling CAP functionality.
</span><a id="81"></a><span class="comment">-- Indicates if CAP Defense is active in ZONEMGR.
</span>SPECTRE.ZONEMGR._schedlerCAP = {}

<span class="comment">--- WIP.
</span><span class="comment">-- Storage for CAP template group names.
</span><a id="86"></a><span class="comment">-- ipair, key = coalition, value = ipair string table of CAP template group names
</span>SPECTRE.ZONEMGR._CAPtemplates = {
  [<span class="number">0</span>] = {},
  [<span class="number">1</span>] = {},
  [<span class="number">2</span>] = {}
}

<a id="93"></a><span class="comment">--- WIP.
</span>SPECTRE.ZONEMGR.settingsCAP = {
  [<span class="number">0</span>] = {
    RestockTime = <span class="number">999999</span>,
    Min = <span class="number">0</span>,
    Nominal = <span class="number">0</span>,
    Max = <span class="number">0</span>,
    PlayerRatio = <span class="number">1</span>,
    NudgeFactor = <span class="number">0.5</span>,
  },
  [<span class="number">1</span>] = {
    RestockTime = <span class="number">30</span>,
    Min = <span class="number">2</span>,
    Nominal = <span class="number">6</span>,
    Max = <span class="number">12</span>,
    PlayerRatio = <span class="number">1</span>,
    NudgeFactor = <span class="number">0.5</span>,
  },
  [<span class="number">2</span>] = {
    RestockTime = <span class="number">30</span>,
    Min = <span class="number">1</span>,
    Nominal = <span class="number">3</span>,
    Max = <span class="number">4</span>,
    PlayerRatio = <span class="number">1</span>,
    NudgeFactor = <span class="number">0.5</span>,
  },
}

SPECTRE.ZONEMGR._CAPspawns = {
  [<span class="number">0</span>] = {},
  [<span class="number">1</span>] = {},
  [<span class="number">2</span>] = {},
}

<a id="127"></a><span class="comment">--- Flag for enabling _AirfieldCaptureSpawns functionality.
</span>SPECTRE.ZONEMGR._AirfieldCaptureSpawns = <span class="keyword">false</span>
<a id="129"></a><span class="comment">--- Flag for enabling _AirfieldCaptureClean functionality.
</span>SPECTRE.ZONEMGR._AirfieldCaptureClean = <span class="keyword">false</span>
<span class="comment">--- Persistence settings for different templates.
</span><a id="132"></a><span class="comment">-- @field #ZONEMGR.persistanceSettings Specifies paths for Fill and Airfield templates.
</span>SPECTRE.ZONEMGR.persistanceSettings = {
  FillTemplates = <span class="string">"SPAWNERTemplates/Fill/"</span>,
  AirfieldTemplates = <span class="string">"SPAWNERTemplates/Airfield/"</span>,
}

<a id="138"></a><span class="comment">--- Table to store Admin UCIDs for special functions like LiveEditor.
</span>SPECTRE.ZONEMGR.AdminUCIDs = {}

<a id="141"></a><span class="comment">--- keep small, for ex: zone with min distance from side to side = 148680m, a scale facor of 0.05 gives min dist from detected groups of 148680*0.05=7434m.
</span>SPECTRE.ZONEMGR._smartFillMinDistFactor = <span class="number">0.05</span>

<span class="comment">--- Dictionary to store zone instances.
</span><a id="145"></a><span class="comment">-- @field #ZONEMGR.Zones
</span>SPECTRE.ZONEMGR.Zones = {}

<span class="comment">--- Dictionary to store airfield spawner instances.
</span><a id="149"></a><span class="comment">-- @field #ZONEMGR.AIRFIELDSPAWNERS
</span>SPECTRE.ZONEMGR.AIRFIELDSPAWNERS = {}

<span class="comment">--- Dictionary to store fill spawner instances.
</span><a id="153"></a><span class="comment">-- @field #ZONEMGR.FILLSPAWNERS
</span>SPECTRE.ZONEMGR.FILLSPAWNERS = {}

<span class="comment">--- Dictionary to store generated airfield spawns.
</span><a id="157"></a><span class="comment">-- @field #ZONEMGR.generatedAirfields
</span>SPECTRE.ZONEMGR.generatedAirfields = {}

<span class="comment">--- Dictionary to store generated fill spawns.
</span><a id="161"></a><span class="comment">-- @field #ZONEMGR.generatedFills
</span>SPECTRE.ZONEMGR.generatedFills = {}

<a id="164"></a><span class="comment">--- Flag indicating if zones are currently being updated.
</span>SPECTRE.ZONEMGR.UpdatingZones = <span class="keyword">false</span>

<span class="comment">--- Scheduler for periodic Zone ownership updates.
</span><a id="168"></a><span class="comment">-- @field #ZONEMGR.UpdateSched
</span>SPECTRE.ZONEMGR.UpdateSched = {}

<a id="171"></a><span class="comment">--- Flag indicating if SSB management is active.
</span>SPECTRE.ZONEMGR.SSB = <span class="keyword">false</span>

<a id="174"></a><span class="comment">--- Flags for SSB on state (default 0).
</span>SPECTRE.ZONEMGR.SSBon = <span class="number">0</span>

<a id="177"></a><span class="comment">--- Flags for SSB off states (default 100).
</span>SPECTRE.ZONEMGR.SSBoff = <span class="number">100</span>

<a id="180"></a><span class="comment">--- Boolean Toggle for drawing unit hotspots (default false).
</span>SPECTRE.ZONEMGR.Hotspots = <span class="keyword">false</span>

<a id="183"></a><span class="comment">--- Boolean Toggle for drawing hotspot intel (default false).
</span>SPECTRE.ZONEMGR.Intel = <span class="keyword">false</span>

<a id="186"></a><span class="comment">--- Code marker for the zones (default 1035200).
</span>SPECTRE.ZONEMGR.codeMarker_ = <span class="number">1035200</span>

<span class="comment">--- A list to seed airbases.
</span><a id="190"></a><span class="comment">-- @field #ZONEMGR.AirbaseSeed
</span>SPECTRE.ZONEMGR.AirbaseSeed = {}

<a id="193"></a><span class="comment">--- Factor for determining minimum distance for smart fill (scale factor).
</span>SPECTRE.ZONEMGR._smartFillMinDistFactor = <span class="number">0.05</span>

<a id="196"></a><span class="comment">--- How often to update self.
</span>SPECTRE.ZONEMGR.UpdateInterval = <span class="number">25</span>

<a id="199"></a><span class="comment">--- Adjust how often to update self.
</span>SPECTRE.ZONEMGR.UpdateIntervalNudge = <span class="number">0.25</span>

<span class="comment">--- Create a new zone manager instance.
</span><span class="comment">--
</span><span class="comment">-- This function initializes a new instance of the SPECTRE.ZONEMGR class. It inherits from the BASE class
</span><span class="comment">-- and sets up the random seed count based on predefined parameters.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR
</span><span class="comment">-- @return #ZONEMGR self The newly created instance of the zone manager.
</span><a id="209"></a><span class="comment">-- @usage local zoneManager = SPECTRE.ZONEMGR:New() -- Creates a new zone manager instance.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:New()
  <span class="keyword">local</span> self = BASE:Inherit(self, SPECTRE:New())
  <span class="keyword">local</span> _randseedCount = SPECTRE.UTILS.generateNominal(self._randSeedNom, self._randSeedMin, self._randSeedMax, self._randSeedNudge)
  <span class="keyword">for</span> _seedC = <span class="number">1</span> , _randseedCount, <span class="number">1</span> <span class="keyword">do</span>
    <span class="global">math</span>.random()
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- 2 - Enable Toggles.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All toggles associated with Zone Manager operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span>
<span class="comment">--- Enable or disable the CAP defense system for the SPECTRE.ZONEMGR instance.
</span><span class="comment">--
</span><span class="comment">-- This function controls the activation state of the persistence system within the SPECTRE.ZONEMGR class.
</span><span class="comment">-- It allows the persistence feature to be toggled on or off. When enabled, the persistence system maintains
</span><span class="comment">-- stateful data across different game sessions or events. The function defaults to enabling persistence if no
</span><span class="comment">-- specific value is provided.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self
</span><span class="comment">-- @param enabled A boolean value (true or false) to enable or disable the system respectively. Defaults to true if not specified.
</span><a id="236"></a><span class="comment">-- @return #ZONEMGR self
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:enableCAP(enabled)
  <span class="comment">-- Default to true if no value is provided
</span>  enabled = enabled <span class="keyword">or</span> <span class="keyword">true</span>

  <span class="comment">-- Set the persistence setting based on the 'enabled' parameter
</span>  self._enableCAP = enabled

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Enable or disable the persistence system for the SPECTRE.ZONEMGR instance.
</span><span class="comment">--
</span><span class="comment">-- This function controls the activation state of the persistence system within the SPECTRE.ZONEMGR class.
</span><span class="comment">-- It allows the persistence feature to be toggled on or off. When enabled, the persistence system maintains
</span><span class="comment">-- stateful data across different game sessions or events. The function defaults to enabling persistence if no
</span><span class="comment">-- specific value is provided.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager to adjust the persistence setting.
</span><span class="comment">-- @param enabled A boolean value (true or false) to enable or disable the persistence system respectively. Defaults to true if not specified.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance with the updated persistence setting.
</span><span class="comment">-- @usage zoneManager:enablePersistance(true) -- Enables the persistence system.
</span><a id="258"></a><span class="comment">-- @usage zoneManager:enablePersistance(false) -- Disables the persistence system.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:enablePersistance(enabled)
  <span class="comment">-- Default to true if no value is provided
</span>  enabled = enabled <span class="keyword">or</span> <span class="keyword">true</span>

  <span class="comment">-- Set the persistence setting based on the 'enabled' parameter
</span>  self._persistence = enabled

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Enable or disable automatic spawns for the coalition that captures an airfield for the SPECTRE.ZONEMGR instance.
</span><span class="comment">--
</span><span class="comment">--  EX: If enabled, when Blue captures an airfield, will pull a random AIRFIELDSPAWNER template from ZONEMGR db and spawn friendly blue units at the field.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager to adjust the persistence setting.
</span><span class="comment">-- @param enabled A boolean value (true or false) to enable or disable the persistence system respectively. Defaults to true if not specified.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance with the updated persistence setting.
</span><span class="comment">-- @usage zoneManager:enableAirfieldCaptureSpawns(true) -- Enables automatic spawns for the coalition that captures an airfield at the airfield.
</span><a id="277"></a><span class="comment">-- @usage zoneManager:enableAirfieldCaptureSpawns(false) -- Disables automatic spawns for the coalition that captures an airfield at the airfield.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:enableAirfieldCaptureSpawns(enabled)
  <span class="comment">-- Default to true if no value is provided
</span>  enabled = enabled <span class="keyword">or</span> <span class="keyword">true</span>
  self._AirfieldCaptureSpawns = enabled
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Enables or disables hotspots within the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- This function is responsible for activating or deactivating hotspot functionality in the ZoneManager. Hotspots are key areas or points
</span><span class="comment">-- of interest within game zones, and managing their activation is crucial for dynamic gameplay. The function takes an optional parameter
</span><span class="comment">-- to specify whether hotspots should be enabled or disabled, defaulting to true (enabled) if not specified.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param enabled (optional) Boolean value to enable (true) or disable (false) hotspots. Defaults to true if not specified.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance with hotspots enabled or disabled as specified.
</span><a id="294"></a><span class="comment">-- @usage local zoneManagerWithHotspots = SPECTRE.ZONEMGR:enableHotspots() -- Enables hotspots in the ZoneManager.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:enableHotspots(enabled)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:InitHotspots | ---------------------"</span>)
  enabled = enabled <span class="keyword">or</span> <span class="keyword">true</span>

  self.Hotspots = enabled
  <span class="keyword">return</span> self
<span class="keyword">end</span>
<span class="comment">--- Enables or disables hotspot intelligence within the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- This function manages the activation of hotspot intelligence in the ZoneManager, which provides strategic insights
</span><span class="comment">-- about key areas within game zones. It allows the game to offer enhanced interactive and tactical experiences based on hotspot activities.
</span><span class="comment">-- The function can be configured to enable or disable this feature, with a default behavior of enabling it if no specific instruction is provided.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param enabled (optional) Boolean value to enable (true) or disable (false) the hotspot intelligence feature. Defaults to true if not specified.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance with the hotspot intelligence feature enabled or disabled as specified.
</span><a id="311"></a><span class="comment">-- @usage local zoneManagerWithIntel = SPECTRE.ZONEMGR:enableHotspotIntel() -- Enables hotspot intelligence in the ZoneManager.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:enableHotspotIntel(enabled)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:enableHotspotIntel | ---------------------"</span>)
  enabled = enabled <span class="keyword">or</span> <span class="keyword">true</span>

  self.Intel = enabled
  <span class="keyword">return</span> self
<span class="keyword">end</span>


<span class="comment">--- Enables live editing of managed zones via markers.
</span><span class="comment">--
</span><span class="comment">-- This function allows for real-time modifications to the managed zones through the use of in-game markers.
</span><span class="comment">-- It supports various commands for deleting and spawning elements like zones, airfields, and circles,
</span><span class="comment">-- providing flexibility and dynamic control over the game's strategic elements. The function handles different
</span><span class="comment">-- edit types and sets up event handlers for marker changes, enabling users to interactively manage zones directly within the game environment.
</span><span class="comment">--
</span><span class="comment">-- Delete: /del [command] [coal] [opt param, ...]
</span><span class="comment">--
</span><span class="comment">--      /del zone [coal]
</span><span class="comment">--      /del airfield [coal]
</span><span class="comment">--      /del allairfield [coal]
</span><span class="comment">--      /del circle [coal] [Circle Diameter (meters), centered on marker]
</span><span class="comment">--
</span><span class="comment">-- Spawn: /spawn [command] [coal] [opt param, ...]
</span><span class="comment">--
</span><span class="comment">--      /spawn zone [coal] [country] [smart] [bias]
</span><span class="comment">--      /spawn zone 1 1 1 2
</span><span class="comment">--      /spawn airfield [coal] [country]
</span><span class="comment">--      /spawn allairfield [coal] [country]
</span><span class="comment">--      /spawn circle [coal] [Circle Diameter (meters), centered on marker] [country] [name]
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance with live edit functionality enabled.
</span><a id="345"></a><span class="comment">-- @usage local zoneManagerWithLiveEdit = SPECTRE.ZONEMGR:enableLiveEdit() -- Enables live editing of zones in the ZoneManager.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:enableLiveEdit()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:enableLiveEdit | ---------------------"</span>)
  <span class="comment">--  self.LIVEEDIT:Init(self)
</span>  <span class="comment">-- Iterate over all support settings
</span>  <span class="keyword">for</span> editType, isEnabled <span class="keyword">in</span> <span class="global">pairs</span>(self.Settings.Edit) <span class="keyword">do</span>
    <span class="comment">-- Initialize tracker if the support type is not "ESCORT" and it is enabled
</span>    <span class="keyword">if</span> isEnabled <span class="keyword">then</span>
      self.MARKERS.TRACKERS[editType] = {}

      <span class="comment">-- Set the event marker function
</span>      self._EventMarker = self[<span class="string">"_EventMarker"</span>]

      <span class="keyword">local</span> markerSettings = self.MARKERS.Settings[editType]
      <span class="keyword">if</span> <span class="keyword">not</span> markerSettings.KeyWords <span class="keyword">or</span> #markerSettings.KeyWords == <span class="number">0</span> <span class="keyword">then</span>
        self.MARKERS.TRACKERS[editType] = MARKEROPS_BASE:New(markerSettings.TagName, markerSettings.CaseSensitive)
      <span class="keyword">else</span>
        self.MARKERS.TRACKERS[editType] = MARKEROPS_BASE:New(markerSettings.TagName, markerSettings.KeyWords, markerSettings.CaseSensitive)
      <span class="keyword">end</span>

      <span class="comment">-- Set up event handler for changes in markers
</span>      self.MARKERS.TRACKERS[editType].OnAfterMarkChanged = <span class="keyword">function</span>(From, Event, To, Text, Keywords, Coord)
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR | LIVEEDIT | "</span>.. editType .. <span class="string">":OnAfterMarkChanged | ------------------------"</span>)
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG  | From   | "</span>, From)
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG  | Event  | "</span>, Event)
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG  | To     | "</span>, To)
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG  | Text   | "</span>, Text)
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG  | Keywords| "</span>, Keywords)
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG  | coord   | "</span>, Coord)

        <span class="keyword">local</span> origText = Keywords
        <span class="keyword">local</span> sanitizedText = Keywords:gsub(<span class="string">"/"</span>, <span class="string">""</span>):upper()
        <span class="keyword">local</span> MarkerType = {}
        <span class="keyword">for</span> word <span class="keyword">in</span> sanitizedText:gmatch(<span class="string">"%w+"</span>) <span class="keyword">do</span> <span class="global">table</span>.insert(MarkerType, word) <span class="keyword">end</span>
        <span class="keyword">local</span> MarkInfo = SPECTRE.MARKERS.World.FindByText(origText)

        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG  | MarkerType   | "</span>, MarkerType)
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG  | MarkInfo     | "</span>, MarkInfo)
        <span class="keyword">local</span> Packet = {
          From = From,
          Event = Event,
          To = To,
          Text = Text,
          sanitizedText = sanitizedText,
          MarkerType = MarkerType,
          MarkInfo = MarkInfo,
          Keywords = Keywords,
          Coord = Coord,
        }
        self  = self._EventMarker(self, Packet)
        <span class="keyword">return</span> self
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>
<span class="comment">--- x - Utilities.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *Misc utilities associated with Zone Manager operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span>
<span class="comment">--- Retrieves the coalition ownership of a specified zone.
</span><span class="comment">--
</span><span class="comment">-- This function determines and returns the current coalition ownership of a specific zone within the SPECTRE.ZONEMGR system.
</span><span class="comment">-- It first calls a method to determine the zone's current ownership status and then retrieves the coalition (either Red, Blue, or None)
</span><span class="comment">-- that owns the zone. This information is crucial for various gameplay mechanics and strategies related to zone control.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param zoneName The name of the zone whose coalition ownership is to be determined.
</span><span class="comment">-- @return ownedBy The current coalition (Red, Blue, or None) that owns the specified zone.
</span><a id="419"></a><span class="comment">-- @usage local owningCoalition = zoneManager:getZoneCoalition("Zone1") -- Retrieves the coalition owning "Zone1".
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.getZoneCoalition(self, zoneName)
  self.Zones[zoneName]:DetermineZoneOwnership()
  <span class="keyword">local</span> ownedBy = self.Zones[zoneName].OwnedByCoalition
  <span class="keyword">return</span> ownedBy
<span class="keyword">end</span>

<span class="comment">--- Retrieves the airfields and zones owned by the red and blue coalitions.
</span><span class="comment">--
</span><span class="comment">-- This function iterates through the zones managed by the <a href="../modules/ZONEMGR.html#">ZONEMGR</a> instance, determining which coalition owns each zone and airfield.
</span><span class="comment">-- It classifies the zones and airfields based on their ownership and returns separate lists for red and blue coalitions.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @return redZones Table of zones owned by the red coalition.
</span><span class="comment">-- @return blueZones Table of zones owned by the blue coalition.
</span><span class="comment">-- @return redAirfields Table of airfields owned by the red coalition.
</span><span class="comment">-- @return blueAirfields Table of airfields owned by the blue coalition.
</span><a id="436"></a><span class="comment">-- @usage local redZones, blueZones, redAirfields, blueAirfields = zoneManager:getOwnedProperty() -- Retrieves owned zones and airfields.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.getOwnedProperty(self)
  <span class="keyword">local</span> redZones, blueZones, redAirfields, blueAirfields = {}, {}, {}, {}
  <span class="keyword">for</span> _k, _v <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
    <span class="keyword">local</span> zoneOwnedBy = self:getZoneCoalition(_k)
    <span class="keyword">if</span> zoneOwnedBy == <span class="number">1</span> <span class="keyword">then</span>
      <span class="global">table</span>.insert(redZones, _k)
    <span class="keyword">elseif</span> zoneOwnedBy == <span class="number">2</span> <span class="keyword">then</span>
      <span class="global">table</span>.insert(blueZones, _k)
    <span class="keyword">end</span>
    <span class="keyword">for</span> _ab, _abV <span class="keyword">in</span> <span class="global">pairs</span>(_v.Airbases) <span class="keyword">do</span>
      <span class="keyword">local</span> airfieldOwnedBy = _abV.ownedBy
      <span class="keyword">if</span> airfieldOwnedBy == <span class="number">1</span> <span class="keyword">then</span>
        <span class="global">table</span>.insert(redAirfields, _ab)
      <span class="keyword">elseif</span> airfieldOwnedBy == <span class="number">2</span> <span class="keyword">then</span>
        <span class="global">table</span>.insert(blueAirfields, _ab)
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> redZones, blueZones, redAirfields, blueAirfields
<span class="keyword">end</span>

<span class="comment">--- Calculates a strategically positioned vector point within a zone.
</span><span class="comment">--
</span><span class="comment">-- This function computes a vector point within specified boundaries that adheres to certain strategic constraints such as
</span><span class="comment">-- coalition bias, minimum and maximum distances from hotspots, and clustering effects. It is designed to smartly position
</span><span class="comment">-- game elements in a way that respects the current state of the battlefield and strategic considerations, making it a key
</span><span class="comment">-- component for dynamic gameplay and scenario generation within the SPECTRE.ZONEMGR system.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param quad_bounds The bounding coordinates defining the area within which the point is to be generated.
</span><span class="comment">-- @param hotspot_clusters Clusters of hotspots that influence the positioning of the point.
</span><span class="comment">-- @param coalition_bias Bias towards a specific coalition in determining the point's position.
</span><span class="comment">-- @param min_distance The minimum distance the point should maintain from any hotspot.
</span><span class="comment">-- @param max_distance The maximum distance within which the point should be from any hotspot.
</span><span class="comment">-- @return point The calculated vector point that satisfies the given constraints.
</span><span class="comment">-- @usage local newZoneManager = SPECTRE.ZONEMGR:New() -- Creates a new ZoneManager instance.
</span><a id="473"></a><span class="comment">-- @usage local strategicPoint = newZoneManager:getSmartVec2(quadBounds, hotspots, coalitionBias, minDist, maxDist) -- Calculates a strategic point within the specified parameters.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.getSmartVec2(self, quad_bounds, hotspot_clusters, coalition_bias, min_distance, max_distance)
  coalition_bias = coalition_bias <span class="keyword">or</span> <span class="number">0</span>
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | -------------------"</span>)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | coalition_bias | "</span> ..  coalition_bias )
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | min_distance   | "</span> ..  min_distance)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | max_distance   | "</span> ..  max_distance)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | quad_bounds[1] | x: "</span> ..  quad_bounds[<span class="number">1</span>].x .. <span class="string">" | y: "</span> .. quad_bounds[<span class="number">1</span>].y)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | quad_bounds[2] | x: "</span> ..  quad_bounds[<span class="number">2</span>].x .. <span class="string">" | y: "</span> .. quad_bounds[<span class="number">2</span>].y)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | quad_bounds[3] | x: "</span> ..  quad_bounds[<span class="number">3</span>].x .. <span class="string">" | y: "</span> .. quad_bounds[<span class="number">3</span>].y)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | quad_bounds[4] | x: "</span> ..  quad_bounds[<span class="number">4</span>].x .. <span class="string">" | y: "</span> .. quad_bounds[<span class="number">4</span>].y)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | -------------------"</span>)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | hotspot_clusters "</span> , hotspot_clusters)
  <span class="keyword">local</span> <span class="keyword">function</span> random_point_in_polygon(quad_bounds, hotspot_clusters, min_distance)
    <span class="keyword">local</span> <span class="keyword">function</span> random_point_in_bounds(bounds)
      <span class="keyword">local</span> x_min = <span class="global">math</span>.min(bounds[<span class="number">1</span>].x, bounds[<span class="number">3</span>].x)
      <span class="keyword">local</span> x_max = <span class="global">math</span>.max(bounds[<span class="number">1</span>].x, bounds[<span class="number">3</span>].x)
      <span class="keyword">local</span> y_min = <span class="global">math</span>.min(bounds[<span class="number">1</span>].y, bounds[<span class="number">3</span>].y)
      <span class="keyword">local</span> y_max = <span class="global">math</span>.max(bounds[<span class="number">1</span>].y, bounds[<span class="number">3</span>].y)
      <span class="keyword">return</span> {
        x = <span class="global">math</span>.random() * (x_max - x_min) + x_min,
        y = <span class="global">math</span>.random() * (y_max - y_min) + y_min
      }
    <span class="keyword">end</span>

    <span class="keyword">local</span> <span class="keyword">function</span> is_point_outside_all_clusters(point, clusters, min_dist)
      <span class="keyword">for</span> _, cluster <span class="keyword">in</span> <span class="global">ipairs</span>(clusters) <span class="keyword">do</span>

        <span class="keyword">if</span>  cluster.Center <span class="keyword">and</span> SPECTRE.POLY.distance(point, cluster.Center) &lt; (cluster.Radius + min_dist) <span class="keyword">then</span>
          <span class="keyword">return</span> <span class="keyword">false</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span>
      <span class="keyword">return</span> <span class="keyword">true</span>
    <span class="keyword">end</span>

    <span class="keyword">local</span> point
    <span class="keyword">local</span> _glassBreak2 = <span class="number">0</span>
    <span class="keyword">local</span> _valid2 = <span class="keyword">false</span>
    <span class="keyword">repeat</span>
      point = random_point_in_bounds(quad_bounds)
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | Determining point in bounds"</span>)

      <span class="keyword">local</span> _outsideClusterFlag = <span class="keyword">true</span>
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | Determining point outside clusters"</span>)
      _outsideClusterFlag = is_point_outside_all_clusters(point, hotspot_clusters, min_distance)

      _valid2 = SPECTRE.POLY.PointWithinShape(point, quad_bounds) <span class="keyword">and</span> _outsideClusterFlag

      <span class="keyword">if</span> _glassBreak2 &gt;= self.Config.operationLimit <span class="keyword">then</span>
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.SPAWNER:getSmartVec2 | is_point_outside_all_clusters --- GLASSBREAK --"</span>)
        _valid2 = <span class="keyword">true</span>
      <span class="keyword">end</span>
      _glassBreak2 = _glassBreak2 + <span class="number">1</span>
    <span class="keyword">until</span> _valid2
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | point_outside_all_clusters &amp; point_in_bounds"</span>)
    <span class="keyword">return</span> point
  <span class="keyword">end</span>

  <span class="keyword">local</span> <span class="keyword">function</span> distance_to_nearest_hotspot(p, hotspots)
    <span class="keyword">local</span> min_distance = <span class="global">math</span>.huge
    <span class="keyword">for</span> _, group <span class="keyword">in</span> <span class="global">ipairs</span>(hotspots) <span class="keyword">do</span>
      <span class="keyword">for</span> _, unit <span class="keyword">in</span> <span class="global">ipairs</span>(group.Units) <span class="keyword">do</span>
        <span class="keyword">local</span> distance = SPECTRE.POLY.distance(p, unit.vec2)
        <span class="keyword">if</span> distance &lt; min_distance <span class="keyword">then</span>
          min_distance = distance
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> min_distance
  <span class="keyword">end</span>

  <span class="keyword">local</span> <span class="keyword">function</span> is_cluster_empty(cluster)
    <span class="keyword">return</span> <span class="keyword">not</span> cluster <span class="keyword">or</span> #cluster == <span class="number">0</span>
  <span class="keyword">end</span>

  <span class="keyword">local</span> valid = <span class="keyword">false</span>
  <span class="keyword">local</span> glassBreak = <span class="number">0</span>
  <span class="keyword">local</span> point
  <span class="keyword">while</span> <span class="keyword">not</span> valid <span class="keyword">do</span>

    point = random_point_in_polygon(quad_bounds, hotspot_clusters, min_distance)
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | random_point       | x: "</span> ..  point.x .. <span class="string">" | y: "</span> .. point.y)
    <span class="keyword">local</span> distancePointToRed
    <span class="keyword">local</span> distancePointToBlue
    <span class="keyword">if</span> is_cluster_empty(hotspot_clusters[<span class="number">1</span>]) <span class="keyword">and</span> is_cluster_empty(hotspot_clusters[<span class="number">2</span>]) <span class="keyword">then</span>
      coalition_bias = <span class="number">0</span>
    <span class="keyword">else</span>
      distancePointToRed = is_cluster_empty(hotspot_clusters[<span class="number">1</span>]) <span class="keyword">and</span> max_distance <span class="keyword">or</span> distance_to_nearest_hotspot(point, hotspot_clusters[<span class="number">1</span>])
      distancePointToBlue  = is_cluster_empty(hotspot_clusters[<span class="number">2</span>]) <span class="keyword">and</span> max_distance <span class="keyword">or</span> distance_to_nearest_hotspot(point, hotspot_clusters[<span class="number">2</span>])
    <span class="keyword">end</span>
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | distancePointToRed  | "</span> .. <span class="global">tostring</span>(distancePointToRed))
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | distancePointToBlue | "</span> .. <span class="global">tostring</span>(distancePointToBlue))

    <span class="keyword">local</span> satisfies_bias = <span class="keyword">true</span>
    <span class="keyword">if</span> coalition_bias == <span class="number">1</span> <span class="keyword">then</span>
      <span class="keyword">if</span> <span class="keyword">not</span> is_cluster_empty(hotspot_clusters[<span class="number">1</span>]) <span class="keyword">then</span>
        satisfies_bias = distancePointToRed &lt;= distancePointToBlue
      <span class="keyword">elseif</span> <span class="keyword">not</span> is_cluster_empty(hotspot_clusters[<span class="number">2</span>]) <span class="keyword">then</span>
        satisfies_bias = distancePointToBlue &gt; (min_distance+(max_distance*.<span class="number">05</span>)) <span class="keyword">and</span> distancePointToBlue &lt;= max_distance
      <span class="keyword">end</span>
    <span class="keyword">elseif</span> coalition_bias == <span class="number">2</span> <span class="keyword">then</span>
      <span class="keyword">if</span> <span class="keyword">not</span> is_cluster_empty(hotspot_clusters[<span class="number">2</span>]) <span class="keyword">then</span>
        satisfies_bias = distancePointToBlue &lt;= distancePointToRed
      <span class="keyword">elseif</span> <span class="keyword">not</span> is_cluster_empty(hotspot_clusters[<span class="number">1</span>]) <span class="keyword">then</span>
        satisfies_bias = distancePointToRed &gt; (min_distance+(max_distance*.<span class="number">05</span>)) <span class="keyword">and</span> distancePointToRed &lt;= max_distance
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | satisfies_bias   | "</span> .. <span class="global">tostring</span>(satisfies_bias))
    <span class="keyword">local</span> satisfies_distance = <span class="keyword">true</span>
    <span class="keyword">if</span> <span class="keyword">not</span> is_cluster_empty(hotspot_clusters[<span class="number">1</span>]) <span class="keyword">or</span> <span class="keyword">not</span> is_cluster_empty(hotspot_clusters[<span class="number">2</span>]) <span class="keyword">then</span>
      satisfies_distance = distancePointToRed &gt;= min_distance <span class="keyword">and</span> distancePointToBlue &gt;= min_distance <span class="keyword">and</span> distancePointToRed &lt;= max_distance <span class="keyword">and</span> distancePointToBlue &lt;= max_distance
    <span class="keyword">elseif</span> coalition_bias == <span class="number">1</span> <span class="keyword">and</span> is_cluster_empty(hotspot_clusters[<span class="number">1</span>]) <span class="keyword">then</span>
      satisfies_distance = distancePointToBlue &gt;= max_distance
    <span class="keyword">elseif</span> coalition_bias == <span class="number">2</span> <span class="keyword">and</span> is_cluster_empty(hotspot_clusters[<span class="number">2</span>]) <span class="keyword">then</span>
      satisfies_distance = distancePointToRed &gt;= max_distance
    <span class="keyword">end</span>
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | satisfies_distance   | "</span> .. <span class="global">tostring</span>(satisfies_distance))
    valid = satisfies_bias <span class="keyword">and</span> satisfies_distance
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | valid   | "</span> .. <span class="global">tostring</span>(valid))
    <span class="keyword">if</span> glassBreak &gt;= self.Config.operationLimit <span class="keyword">then</span>
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.SPAWNER:generateSubZoneCircles | --- GLASSBREAK --"</span>)
      valid = <span class="keyword">true</span>
    <span class="keyword">end</span>
    glassBreak = glassBreak + <span class="number">1</span>
  <span class="keyword">end</span>
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.getSmartVec2 | final point       | x: "</span> ..  point.x .. <span class="string">" | y: "</span> .. point.y)
  <span class="keyword">return</span> point
<span class="keyword">end</span>

<span class="comment">--- Identifies and categorizes units within a specified zone.
</span><span class="comment">--
</span><span class="comment">-- This function scans a defined zone (<code>t_ZOBJ</code>) for all units, including ground units, structures, and ships.
</span><span class="comment">-- It categorizes detected units based on their coalition, providing an organized list of units within the zone.
</span><span class="comment">-- This is useful for understanding the distribution and alignment of forces within a specific area, which can be
</span><span class="comment">-- critical for strategic planning and decision making in gameplay scenarios.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param t_ZOBJ The zone object within which units are to be scanned and identified.
</span><span class="comment">-- @return temp_detectedUnits A table categorizing detected units by coalition (0 for neutral, 1 for red, 2 for blue).
</span><a id="612"></a><span class="comment">-- @usage local detectedUnits = zoneManager:FindUnitsInZone(zoneObject) -- Scans and categorizes units within the specified zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.FindUnitsInZone(self, t_ZOBJ)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG:FindUnitsInZone | -------------------------------------------- "</span>)
  <span class="keyword">local</span> temp_detectedUnits = {}
  temp_detectedUnits[<span class="number">0</span>] = {}
  temp_detectedUnits[<span class="number">1</span>] = {}
  temp_detectedUnits[<span class="number">2</span>] = {}
  t_ZOBJ:Scan({Object.Category.UNIT}, {Unit.Category.GROUND_UNIT, Unit.Category.STRUCTURE, Unit.Category.SHIP})
  <span class="keyword">local</span> scanData = t_ZOBJ.ScanData
  <span class="keyword">if</span> scanData <span class="keyword">then</span>
    <span class="comment">-- Units
</span>    <span class="keyword">if</span> scanData.Units <span class="keyword">then</span>
      <span class="keyword">for</span> _, unit <span class="keyword">in</span> <span class="global">pairs</span>(scanData.Units) <span class="keyword">do</span>
        <span class="keyword">local</span> _unitCoal = unit:getCoalition()
        <span class="keyword">local</span> _unitName = unit:getName()
        <span class="keyword">local</span> _life = unit:getLife()
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG:FindUnitsInZone | FOUND UNIT  | _unitCoal | "</span> .. _unitCoal .. <span class="string">" | _unitName | "</span> .. _unitName)
        temp_detectedUnits[_unitCoal][#temp_detectedUnits[_unitCoal] + <span class="number">1</span>] = {
          name = _unitName,
          unitObj = unit,
          coal = _unitCoal,
          life = _life,
        }
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> temp_detectedUnits
<span class="keyword">end</span>

<span class="comment">--- Constructs a list of group names from detected units based on their coalition.
</span><span class="comment">--
</span><span class="comment">-- This function processes a list of detected units, filtering them by a specified coalition.
</span><span class="comment">-- It retrieves the names of the groups to which these units belong.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param _detectedUnits A table containing units detected within a specific zone, categorized by coalition.
</span><span class="comment">-- @param coal The coalition identifier (1 for red, 2 for blue) used to filter the detected units.
</span><span class="comment">-- @return _GroupNames A table containing the names of groups that belong to the specified coalition.
</span><a id="650"></a><span class="comment">-- @usage local groupNames = zoneManager:buildGroupsFromUnits(detectedUnits, coalitionId) -- Retrieves group names for units of a specific coalition.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.buildGroupsFromUnits(self, _detectedUnits, coal)
  <span class="keyword">local</span> _GroupNames = {}
  <span class="keyword">if</span> #_detectedUnits[coal] &gt; <span class="number">0</span> <span class="keyword">then</span>
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG  | Detected Coal Units"</span>)
    <span class="keyword">for</span> _, _Unit <span class="keyword">in</span> <span class="global">ipairs</span>(_detectedUnits[coal]) <span class="keyword">do</span>
      <span class="keyword">local</span> unitName  = _Unit.name
      <span class="keyword">local</span> _unit     = Unit.getByName(unitName)
      <span class="keyword">if</span> _unit <span class="keyword">then</span>
        <span class="keyword">local</span> _Group    =  Unit.getGroup(_unit )
        <span class="keyword">if</span> _Group <span class="keyword">then</span>
          <span class="keyword">local</span> groupName = Group.getName(_Group)
          <span class="keyword">if</span> groupName <span class="keyword">then</span>
            SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG  | group in Zone |"</span> .. groupName)
            SPECTRE.UTILS.safeInsert(_GroupNames,groupName)
          <span class="keyword">end</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> _GroupNames
<span class="keyword">end</span>

<span class="comment">--- Determines the zone object for a given coordinate (Vec2).
</span><span class="comment">--
</span><span class="comment">-- This function iterates through all the zones managed by the ZoneManager and identifies which zone
</span><span class="comment">-- a given set of coordinates (Vec2 format) falls into. This is particularly useful for pinpointing
</span><span class="comment">-- the specific zone in which a marker, unit, or event is located based on its coordinates.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param vec2 The Vec2 coordinates used to determine the relevant zone.
</span><span class="comment">-- @return #ZONEMGR.Zone _zoneObjectRETURN The zone object that contains the specified coordinates.
</span><a id="682"></a><span class="comment">-- @usage local zoneObject = zoneManager:findZoneForVec2(coordinates) -- Retrieves the zone object for given coordinates.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.findZoneForVec2(self, vec2)
  <span class="keyword">local</span> markerInZone = <span class="keyword">false</span>
  <span class="keyword">local</span> _zoneObjectRETURN = {}
  <span class="keyword">for</span> _zoneName, _zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
    markerInZone = SPECTRE.POLY.PointWithinShape(vec2, _zoneObject.Vertices2D)
    <span class="keyword">if</span> markerInZone <span class="keyword">then</span>
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.FLAG  | mark in Zone |"</span> .. _zoneName)
      _zoneObjectRETURN = _zoneObject
      <span class="keyword">break</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> _zoneObjectRETURN
<span class="keyword">end</span>
<span class="comment">--- x - Spawner.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All functions associated with Zone Manager spawning.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span>

<span class="comment">--- Spawns airbase elements within specified zones.
</span><span class="comment">--
</span><span class="comment">-- This function is responsible for spawning airbase elements within the game environment. It can process one or multiple zones,
</span><span class="comment">-- spawning airbases with specific characteristics such as coalition, country, and size. The function also handles the dynamic generation
</span><span class="comment">-- of airfield structures based on the specified parameters. It's crucial for setting up the airbase infrastructure within different zones
</span><span class="comment">-- managed by the ZONEMGR system.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param _airbaseName The name of the airbase to be spawned.
</span><span class="comment">-- @param coalition The coalition to which the airbase belongs.
</span><span class="comment">-- @param country The country to which the airbase belongs.
</span><span class="comment">-- @param _zoneNameT (optional) Specific zone name to process, or all zones if not provided.
</span><span class="comment">-- @param SPWNR_ (optional) Spawner to use for airbase generation.
</span><span class="comment">-- @param SPWNRTemplate (optional) Creates a template on the fly from provided spawner, and uses that. SPWNR_ must be nil.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after spawning the airbase elements.
</span><span class="comment">-- @usage local newZoneManager = SPECTRE.ZONEMGR:New() -- Creates a new ZoneManager instance.
</span><a id="721"></a><span class="comment">-- @usage newZoneManager:spawnAirbase("Airbase1", 2, "USA", "Zone1") -- Spawns "Airbase1" in "Zone1" for the Blue coalition and USA.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:spawnAirbase(_airbaseName, coalition, country, _zoneNameT, SPWNR_, SPWNRTemplate)
  _zoneNameT = _zoneNameT <span class="keyword">or</span> <span class="keyword">nil</span>
  SPWNR_ = SPWNR_ <span class="keyword">or</span> <span class="keyword">nil</span>
  SPWNRTemplate = SPWNRTemplate <span class="keyword">or</span> <span class="keyword">nil</span>
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnAirbase | ------- "</span>, _airbaseName)
  <span class="keyword">local</span> zonesToProcess = _zoneNameT <span class="keyword">and</span> {[_zoneNameT] = self.Zones[_zoneNameT]} <span class="keyword">or</span> self.Zones
  <span class="keyword">for</span> _zoneName, _zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(zonesToProcess) <span class="keyword">do</span>
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnAirbase | Zone Name | "</span>, _zoneName)
    <span class="keyword">local</span> _airbaseObject = _zoneObject.Airbases[_airbaseName]
    <span class="keyword">if</span> _airbaseObject <span class="keyword">then</span>
      <span class="keyword">if</span> SPWNRTemplate ~= <span class="keyword">nil</span> <span class="keyword">then</span> SPWNR_ = SPECTRE.SPAWNER:New():ImportTemplate(SPWNRTemplate) <span class="keyword">end</span>
      <span class="keyword">local</span> _spawner = SPWNR_ <span class="keyword">or</span> SPECTRE.SPAWNER:New():ImportTemplate(self.AIRFIELDSPAWNERS[SPECTRE.UTILS.PickRandomFromKVTable(self.AIRFIELDSPAWNERS)])

      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnAirbase | Airbase Object | "</span>, _airbaseObject)
      <span class="keyword">local</span> _vec2 = _airbaseObject.Object:GetVec2()
      <span class="keyword">local</span> _airbaseSize = (_airbaseObject.Object.AirbaseZone.Radius * <span class="number">1.5</span>) * <span class="number">2</span>
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnAirbase | Vec2.x | "</span> .. _vec2.x)
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnAirbase | Vec2.y | "</span> .. _vec2.y)
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnAirbase | Airbase Size | "</span> .. _airbaseSize)

      <span class="keyword">local</span> genIndex = #self.generatedAirfields + <span class="number">1</span>
      self.generatedAirfields[genIndex] = _spawner
      self.generatedAirfields[genIndex]:setCoalition(coalition)
      self.generatedAirfields[genIndex]:setCountry(country)
      self.generatedAirfields[genIndex]:setZoneSizeMain(_airbaseSize, _airbaseSize * <span class="number">0.8</span>, _airbaseSize * <span class="number">1.2</span>, <span class="number">0.5</span>)
      self.generatedAirfields[genIndex]:DynamicGenerationZONE(_vec2, _airbaseName)<span class="comment">--, true, true)
</span>    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Spawns airbases within a specific zone.
</span><span class="comment">--
</span><span class="comment">-- This function is designed to spawn all airbases within a given zone. It iterates through each airbase in the specified zone,
</span><span class="comment">-- invoking the <code>spawnAirbase</code> method for each airbase with designated coalition and country parameters. This is essential for
</span><span class="comment">-- populating specific zones with the required airbase infrastructure, tailored to the needs of the specified coalition and country.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param _zoneName The name of the zone where airbases are to be spawned.
</span><span class="comment">-- @param _coalition The coalition to which the airbases will belong.
</span><span class="comment">-- @param _country The country to which the airbases will belong.
</span><span class="comment">-- @param SPWNRTemplate (optional) Creates a template on the fly from provided spawner, and uses that. SPWNR_ must be nil.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after spawning the airbases in the specified zone.
</span><span class="comment">-- @usage local newZoneManager = SPECTRE.ZONEMGR:New() -- Creates a new ZoneManager instance.
</span><a id="766"></a><span class="comment">-- @usage newZoneManager:spawnAirbasesInZone("Zone1", 2, "USA") -- Spawns all airbases in "Zone1" for the Blue coalition and USA.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:spawnAirbasesInZone(_zoneName, _coalition, _country, SPWNRTemplate)
  SPWNRTemplate = SPWNRTemplate <span class="keyword">or</span> <span class="keyword">nil</span>
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnAirbasesInZone | _zoneName | "</span> ..  _zoneName)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnAirbasesInZone | coalition | "</span> ,  _coalition)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnAirbasesInZone | country   | "</span> ,  _country)
  <span class="keyword">local</span> _zoneObject = self.Zones[_zoneName]
  <span class="keyword">for</span> _airbaseName, _airbaseObject <span class="keyword">in</span> <span class="global">pairs</span> (_zoneObject.Airbases) <span class="keyword">do</span>
    self:spawnAirbase(_airbaseName, _coalition, _country, _zoneName, <span class="keyword">nil</span>, SPWNRTemplate)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>


<span class="comment">--- Spawns fill elements at a specified vector location within a zone.
</span><span class="comment">--
</span><span class="comment">-- This function is designed to spawn fill elements, such as troops or equipment, at a given vector location within a specified zone.
</span><span class="comment">-- It allows customization of the spawn area's diameter, coalition, and country. The function selects a spawner template randomly or
</span><span class="comment">-- uses a provided one, setting up the necessary parameters for dynamic generation within the zone. This feature is essential for
</span><span class="comment">-- populating zones with various in-game elements, adding realism and strategic depth to the game environment.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param vec2_SpawnCenter The vector location (x, y coordinates) where fill elements are to be spawned.
</span><span class="comment">-- @param diameter_SpawnZone The diameter of the spawn zone around the vector location.
</span><span class="comment">-- @param coalition The coalition to which the fill elements will belong.
</span><span class="comment">-- @param country The country to which the fill elements will belong.
</span><span class="comment">-- @param _zoneName (optional) The name of the zone where the elements are to be spawned.
</span><span class="comment">-- @param SPWNR_ (optional) The spawner to use for fill generation.
</span><span class="comment">-- @param SPWNRTemplate (optional) Creates a template on the fly from provided spawner, and uses that. SPWNR_ must be nil.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after spawning the fill elements.
</span><span class="comment">-- @usage local newZoneManager = SPECTRE.ZONEMGR:New() -- Creates a new ZoneManager instance.
</span><a id="797"></a><span class="comment">-- @usage newZoneManager:spawnFillAtVec2({x = 1000, y = 2000}, 5000, 2, "USA", "Zone1") -- Spawns fill elements at the specified location in "Zone1".
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:spawnFillAtVec2(vec2_SpawnCenter, diameter_SpawnZone, coalition, country, _zoneName, SPWNR_ , SPWNRTemplate)
  SPWNR_ = SPWNR_ <span class="keyword">or</span> <span class="keyword">nil</span>
  SPWNRTemplate = SPWNRTemplate <span class="keyword">or</span> <span class="keyword">nil</span>
  _zoneName = _zoneName <span class="keyword">or</span> <span class="keyword">nil</span>

  <span class="keyword">if</span> _zoneName == <span class="keyword">nil</span> <span class="keyword">then</span>
    <span class="keyword">local</span> InZone = <span class="keyword">false</span>
    <span class="keyword">for</span> _zName, _zObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
      InZone =  SPECTRE.WORLD.PointInZone(vec2_SpawnCenter, _zName)

      <span class="keyword">if</span> InZone <span class="keyword">then</span> _zoneName = _zName <span class="keyword">break</span> <span class="keyword">end</span>
    <span class="keyword">end</span>

  <span class="keyword">end</span>

  <span class="keyword">if</span> SPWNRTemplate ~= <span class="keyword">nil</span> <span class="keyword">then</span> SPWNR_ = SPECTRE.SPAWNER:New():ImportTemplate(SPWNRTemplate) <span class="keyword">end</span>
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillAtVec2 | ------- "</span>)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillAtVec2 | _zoneName : "</span> .. _zoneName)
  <span class="keyword">local</span> _spawner = SPWNR_ <span class="keyword">or</span> SPECTRE.SPAWNER:New():ImportTemplate(self.FILLSPAWNERS[SPECTRE.UTILS.PickRandomFromKVTable(self.FILLSPAWNERS)])
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillAtVec2 | vec2_SpawnCenter.x | "</span> .. vec2_SpawnCenter.x)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillAtVec2 | vec2_SpawnCenter.y | "</span> .. vec2_SpawnCenter.y)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillAtVec2 | SpawnZone Diameter | "</span> .. diameter_SpawnZone)

  <span class="keyword">local</span> genIndex = #self.generatedFills + <span class="number">1</span>
  self.generatedFills[genIndex] = _spawner
  self.generatedFills[genIndex]:setCoalition(coalition)
  self.generatedFills[genIndex]:setCountry(country)
  self.generatedFills[genIndex]:setZoneSizeMain(diameter_SpawnZone, diameter_SpawnZone * <span class="number">0.8</span>, diameter_SpawnZone * <span class="number">1.2</span>, <span class="number">0.5</span>)
  self.generatedFills[genIndex]:DynamicGenerationZONE(vec2_SpawnCenter, _zoneName)<span class="comment">--, true, true)
</span>  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Spawns fill elements within a specified zone.
</span><span class="comment">--
</span><span class="comment">-- This function handles the spawning of fill elements like troops or equipment within a specific zone. It selects a spawner template,
</span><span class="comment">-- either provided or picked randomly from available templates, and determines a central point within the zone to spawn these elements.
</span><span class="comment">-- The function ensures that the spawning point and area are strategically viable and do not conflict with restricted zones. This is essential
</span><span class="comment">-- for dynamically populating game zones with various elements, enhancing the gameplay experience and the tactical complexity of the zone.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param _zoneName The name of the zone where fill elements are to be spawned.
</span><span class="comment">-- @param coalition The coalition to which the fill elements will belong.
</span><span class="comment">-- @param country The country to which the fill elements will belong.
</span><span class="comment">-- @param SPWNR_ (optional) The spawner to use for fill generation.
</span><span class="comment">-- @param SPWNRTemplate (optional) Creates a template on the fly from provided spawner, and uses that. SPWNR_ must be nil.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after spawning the fill elements in the specified zone.
</span><span class="comment">-- @usage local newZoneManager = SPECTRE.ZONEMGR:New() -- Creates a new ZoneManager instance.
</span><a id="845"></a><span class="comment">-- @usage newZoneManager:spawnFillInZone("Zone1", 2, "USA") -- Spawns fill elements in "Zone1" for the Blue coalition and USA.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:spawnFillInZone(_zoneName, coalition, country, SPWNR_, SPWNRTemplate)
  SPWNR_ = SPWNR_ <span class="keyword">or</span> <span class="keyword">nil</span>
  SPWNRTemplate = SPWNRTemplate <span class="keyword">or</span> <span class="keyword">nil</span>
  <span class="keyword">if</span> SPWNRTemplate ~= <span class="keyword">nil</span> <span class="keyword">then</span> SPWNR_ = SPECTRE.SPAWNER:New():ImportTemplate(SPWNRTemplate) <span class="keyword">end</span>
  <span class="keyword">local</span> _bias = <span class="number">0</span>
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillInZone | ---- | "</span> .. _zoneName .. <span class="string">" | --------"</span>)
  <span class="keyword">local</span> _spawner = SPWNR_ <span class="keyword">or</span> SPECTRE.SPAWNER:New():ImportTemplate(self.FILLSPAWNERS[SPECTRE.UTILS.PickRandomFromKVTable(self.FILLSPAWNERS)])
  <span class="keyword">local</span> _zoneObject = self.Zones[_zoneName]
  <span class="keyword">local</span> _initialMinDist, _initialMaxDist = SPECTRE.POLY.getMinMaxDistances(_zoneObject.Vertices2D)
  <span class="keyword">local</span> _tNom = _initialMinDist/<span class="number">2</span>
  <span class="keyword">local</span> _offset = SPECTRE.UTILS.generateNominal(_tNom, _tNom*<span class="number">0.8</span>, _tNom*<span class="number">1.2</span>, _spawner.nudgeFactor)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillInZone | _offset | "</span> .. _offset)
  <span class="keyword">local</span> _nominal = _initialMinDist/<span class="number">2</span>
  <span class="keyword">local</span> vec2_SpawnCenter
  <span class="keyword">local</span> flag_goodcoord = <span class="keyword">true</span>
  <span class="keyword">local</span> glassBreak = <span class="number">0</span>
  <span class="comment">--_zoneObject:getHotspotGroups()
</span>  <span class="keyword">repeat</span>
    flag_goodcoord = <span class="keyword">true</span>
    vec2_SpawnCenter = _zoneObject.ZONEPOLYOBJ:GetRandomVec2()
    <span class="keyword">if</span> flag_goodcoord <span class="keyword">then</span> flag_goodcoord = _spawner.checkNOGO(_spawner, vec2_SpawnCenter, _spawner.ZonesRestricted) <span class="keyword">end</span>
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.SPAWNER:spawnFillInZone | GOODCOORD? | "</span> .. <span class="global">tostring</span>(flag_goodcoord))
    <span class="keyword">if</span> glassBreak &gt;= _spawner.Config.operationLimit <span class="keyword">then</span>
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.SPAWNER:spawnFillInZone | --- GLASSBREAK --"</span>)
      flag_goodcoord = <span class="keyword">true</span>
    <span class="keyword">end</span>
    glassBreak = glassBreak + <span class="number">1</span>
  <span class="keyword">until</span> flag_goodcoord

  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillInZone | ---- | "</span> .. _zoneName .. <span class="string">" | --------"</span>)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillInZone | vec2_SpawnCenter.x | "</span> .. vec2_SpawnCenter.x)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillInZone | vec2_SpawnCenter.y | "</span> .. vec2_SpawnCenter.y)

  <span class="keyword">local</span> diameter_SpawnZone = SPECTRE.UTILS.generateNominal(_nominal, _nominal*<span class="number">0.8</span>, _nominal*<span class="number">1.2</span>, _spawner.nudgeFactor)<span class="comment">-- scale based on zone size
</span>  self:spawnFillAtVec2(vec2_SpawnCenter, diameter_SpawnZone, coalition, country, _zoneName, _spawner )
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Spawns fill elements within a specified zone using intelligent positioning.
</span><span class="comment">--
</span><span class="comment">-- This function takes a strategic approach to spawn fill elements, such as troops or equipment, within a specified zone.
</span><span class="comment">-- It utilizes the <code>getSmartVec2</code> method to determine an optimal spawning location based on various factors, including
</span><span class="comment">-- minimum and maximum distances, hotspot clustering, and coalition bias. The function ensures the spawn point is outside
</span><span class="comment">-- restricted areas and dynamically calculates the spawn zone's diameter. It's pivotal for introducing intelligent and
</span><span class="comment">-- adaptive gameplay elements within the zones managed by the ZONEMGR system.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param _zoneName The name of the zone where fill elements are to be strategically spawned.
</span><span class="comment">-- @param coalition The coalition to which the fill elements will belong.
</span><span class="comment">-- @param country The country to which the fill elements will belong.
</span><span class="comment">-- @param SPWNR_ (optional) The spawner to use for fill generation.
</span><span class="comment">-- @param _bias (optional) A bias factor towards a specific coalition in positioning the fill elements.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after strategically spawning the fill elements in the specified zone.
</span><span class="comment">-- @usage local newZoneManager = SPECTRE.ZONEMGR:New() -- Creates a new ZoneManager instance.
</span><a id="900"></a><span class="comment">-- @usage newZoneManager:spawnFillInZoneSmart("Zone1", 2, "USA", nil, 0) -- Strategically spawns fill elements in "Zone1" for the Blue coalition and USA.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:spawnFillInZoneSmart(_zoneName, coalition, country,  SPWNR_, _bias, SPWNRTemplate)
  SPWNR_ = SPWNR_ <span class="keyword">or</span> <span class="keyword">nil</span>
  SPWNRTemplate = SPWNRTemplate <span class="keyword">or</span> <span class="keyword">nil</span>
  <span class="keyword">if</span> SPWNRTemplate ~= <span class="keyword">nil</span> <span class="keyword">then</span> SPWNR_ = SPECTRE.SPAWNER:New():ImportTemplate(SPWNRTemplate) <span class="keyword">end</span>
  _bias = _bias <span class="keyword">or</span> <span class="number">0</span>
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillInZone | ---- | "</span> .. _zoneName .. <span class="string">" | --------"</span>)
  <span class="keyword">local</span> _spawner = SPWNR_ <span class="keyword">or</span> SPECTRE.SPAWNER:New():ImportTemplate(self.FILLSPAWNERS[SPECTRE.UTILS.PickRandomFromKVTable(self.FILLSPAWNERS)])
  <span class="keyword">local</span> _zoneObject = self.Zones[_zoneName]
  <span class="keyword">local</span> _initialMinDist, _initialMaxDist = SPECTRE.POLY.getMinMaxDistances(_zoneObject.Vertices2D)
  <span class="keyword">local</span> _tNom = _initialMinDist/<span class="number">2</span>
  <span class="keyword">local</span> _offset = SPECTRE.UTILS.generateNominal(_tNom, _tNom*<span class="number">0.8</span>, _tNom*<span class="number">1.2</span>, _spawner.nudgeFactor)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillInZone | _offset | "</span> .. _offset)
  <span class="keyword">local</span> _nominal = _initialMinDist/<span class="number">2</span>
  <span class="keyword">local</span> vec2_SpawnCenter
  <span class="keyword">local</span> flag_goodcoord = <span class="keyword">true</span>
  <span class="keyword">local</span> glassBreak = <span class="number">0</span>
  _zoneObject:getHotspotGroups()
  <span class="keyword">repeat</span>
    flag_goodcoord = <span class="keyword">true</span>
    vec2_SpawnCenter = self:getSmartVec2(_zoneObject.Vertices2D, _zoneObject.HotspotClusters, _bias, _initialMinDist*self._smartFillMinDistFactor, _initialMinDist) <span class="comment">---ZONE_POLYGON:NewFromPointsArray("Temp_" .. os.time() ,_tempZONEpoly):GetRandomVec2()--SPECTRE.POLY.getRandomPointInPolygon(_tempZONEpoly)
</span>    <span class="keyword">if</span> flag_goodcoord <span class="keyword">then</span> flag_goodcoord = _spawner.checkNOGO(_spawner, vec2_SpawnCenter, _spawner.ZonesRestricted) <span class="keyword">end</span>
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.SPAWNER:spawnFillInZone | GOODCOORD? | "</span> .. <span class="global">tostring</span>(flag_goodcoord))
    <span class="keyword">if</span> glassBreak &gt;= _spawner.Config.operationLimit <span class="keyword">then</span>
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.SPAWNER:spawnFillInZone | --- GLASSBREAK --"</span>)
      flag_goodcoord = <span class="keyword">true</span>
    <span class="keyword">end</span>
    glassBreak = glassBreak + <span class="number">1</span>
  <span class="keyword">until</span> flag_goodcoord

  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillInZone | ---- | "</span> .. _zoneName .. <span class="string">" | --------"</span>)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillInZone | vec2_SpawnCenter.x | "</span> .. vec2_SpawnCenter.x)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:spawnFillInZone | vec2_SpawnCenter.y | "</span> .. vec2_SpawnCenter.y)

  <span class="keyword">local</span> diameter_SpawnZone = SPECTRE.UTILS.generateNominal(_nominal, _nominal*<span class="number">0.8</span>, _nominal*<span class="number">1.2</span>, _spawner.nudgeFactor)<span class="comment">-- scale based on zone size
</span>  self:spawnFillAtVec2(vec2_SpawnCenter, diameter_SpawnZone, coalition, country, _zoneName, _spawner )
  <span class="keyword">return</span> self
<span class="keyword">end</span>


<span class="comment">--- x - Templates.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All functions associated with Zone Manager templates.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span>
<span class="comment">--- Clears all fill spawner templates in the zone manager.
</span><span class="comment">--
</span><span class="comment">-- This function resets the 'FILLSPAWNERS' table within the zone manager instance, effectively clearing all existing fill spawner templates.
</span><span class="comment">-- It's useful for reinitializing or updating the spawner settings in the zone manager.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR
</span><span class="comment">-- @return #ZONEMGR self
</span><a id="955"></a><span class="comment">-- @usage zoneManager:clearFillSpawnerTemplates() -- Clears all fill spawner templat
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:clearFillSpawnerTemplates()
  self.FILLSPAWNERS = {}
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Adds a fill spawner template to the zone manager.
</span><span class="comment">--
</span><span class="comment">-- This function adds a new spawner template or retrieves an existing one from a persistence file. It creates a unique identifier
</span><span class="comment">-- for the template, checks for existing persistence files, and loads them if present. If the file is not found or if the force flag
</span><span class="comment">-- is set, a new template is created from the provided spawner object. The function is essential for managing spawner templates,
</span><span class="comment">-- ensuring that they are consistent and retrievable across game sessions when persistence is enabled.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param #SPAWNER _SPWNR The spawner object from which the template is created.
</span><span class="comment">-- @param name_ (optional) The name of the template. Defaults to a unique identifier based on the current time.
</span><span class="comment">-- @param force (optional) A boolean flag to force creation of a new template, regardless of existing persistence.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after adding or updating the spawner template.
</span><span class="comment">-- @usage local newZoneManager = SPECTRE.ZONEMGR:New() -- Creates a new ZoneManager instance.
</span><a id="974"></a><span class="comment">-- @usage newZoneManager:AddFillSpawnerTemplate(spawnerObject, "TemplateName", true) -- Adds or updates a template named "TemplateName".
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:AddFillSpawnerTemplate(_SPWNR, name_, force)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:AddFillSpawnerTemplate | ----------- "</span> , _SPWNR )
  force = force <span class="keyword">or</span> <span class="keyword">false</span>
  <span class="keyword">local</span> _Randname = name_ <span class="keyword">or</span> <span class="global">os</span>.time()
  <span class="keyword">local</span> _filename = SPECTRE._persistenceLocations.ZONEMGR.path .. self.persistanceSettings.FillTemplates .. _Randname .. <span class="string">".lua"</span>
  self.FILLSPAWNERS[_Randname] = SPECTRE.BRAIN.checkAndPersist(
    _filename,
    force,
    self.FILLSPAWNERS[_Randname],
    self._persistence,
    <span class="keyword">function</span>(_Object)  <span class="comment">-- Update: Include _Object as a parameter
</span>      <span class="keyword">return</span> self._CreateSpawnerTemplate(_SPWNR, _Object)  <span class="comment">-- Update: Pass _Object to the new function
</span>    <span class="keyword">end</span>
  )
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Clears all Airfield spawner templates in the zone manager.
</span><span class="comment">--
</span><span class="comment">-- This function resets the 'AIRFIELDSPAWNERS' table within the zone manager instance, effectively clearing all existing Airfield spawner templates.
</span><span class="comment">-- It's useful for reinitializing or updating the spawner settings in the zone manager.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR
</span><span class="comment">-- @return #ZONEMGR self
</span><a id="999"></a><span class="comment">-- @usage zoneManager:clearFillSpawnerTemplates() -- Clears all fill spawner templat
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:clearAirfieldSpawnerTemplates()
  self.AIRFIELDSPAWNERS = {}
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Adds an airfield spawner template to the zone manager.
</span><span class="comment">--
</span><span class="comment">-- This function is responsible for adding a new airfield spawner template or retrieving an existing one from a persistence file.
</span><span class="comment">-- It generates a unique identifier for the template and checks for existing persistence files, loading them if present. If no file
</span><span class="comment">-- is found, or if the force creation flag is set, a new template is created from the provided spawner object. This functionality
</span><span class="comment">-- is crucial for maintaining a consistent set of airfield spawner templates that can be reused and persist across game sessions.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param #SPAWNER _SPWNR The spawner object from which the airfield template is created.
</span><span class="comment">-- @param name_ (optional) The name of the airfield template. Defaults to a unique identifier based on the current time.
</span><span class="comment">-- @param force (optional) A boolean flag to force the creation of a new template, overriding existing persistence.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after adding or updating the airfield spawner template.
</span><span class="comment">-- @usage local newZoneManager = SPECTRE.ZONEMGR:New() -- Creates a new ZoneManager instance.
</span><a id="1018"></a><span class="comment">-- @usage newZoneManager:AddAirfieldSpawnerTemplate(spawnerObject, "AirfieldName", true) -- Adds or updates an airfield template named "AirfieldName".
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:AddAirfieldSpawnerTemplate(_SPWNR, name_, force)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:AddAirfieldSpawnerTemplate | ----------- "</span> , _SPWNR )
  force = force <span class="keyword">or</span> <span class="keyword">false</span>
  <span class="keyword">local</span> _Randname = name_ <span class="keyword">or</span> <span class="global">os</span>.time()
  <span class="keyword">local</span> _filename = SPECTRE._persistenceLocations.ZONEMGR.path .. self.persistanceSettings.AirfieldTemplates .. _Randname .. <span class="string">".lua"</span>

  self.AIRFIELDSPAWNERS[_Randname] = SPECTRE.BRAIN.checkAndPersist(
    _filename,
    force,
    self.AIRFIELDSPAWNERS[_Randname],
    self._persistence,
    <span class="keyword">function</span>(_Object)  <span class="comment">-- Update: Include _Object as a parameter
</span>      <span class="keyword">return</span> self._CreateSpawnerTemplate(_SPWNR, _Object)  <span class="comment">-- Update: Pass _Object to the new function
</span>    <span class="keyword">end</span>
  )
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Creates a spawner template based on a provided spawner object.
</span><span class="comment">--
</span><span class="comment">-- This function generates a template from the given '_SPWNR' spawner object using 'SPECTRE.UTILS.templateFromObject'.
</span><span class="comment">-- It updates the '_Object' with this new template.
</span><span class="comment">-- This function is typically used internally within the zone manager to create or update templates for spawners.
</span><span class="comment">--
</span><span class="comment">-- @param _SPWNR The spawner object from which the template is to be created.
</span><span class="comment">-- @param _Object The object to be updated with the new spawner template.
</span><span class="comment">-- @return _Object The updated object with the new spawner template.
</span><a id="1046"></a><span class="comment">-- @usage local updatedObject = SPECTRE.ZONEMGR._CreateSpawnerTemplate(spawner, existingObject) -- Updates 'existingObject' with a template from 'spawner'.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR._CreateSpawnerTemplate(_SPWNR, _Object)
  <span class="comment">-- Update _Object with the new template and return it
</span>  _Object = SPECTRE.UTILS.templateFromObject(_SPWNR)
  <span class="keyword">return</span> _Object
<span class="keyword">end</span>

<span class="comment">--- x - Init.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with Zone Manager operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span>

<span class="comment">--- Initializes the ZoneManager with all necessary configurations.
</span><span class="comment">--
</span><span class="comment">-- This function is essential for starting a new ZoneManager object. It goes through a series of steps to fully initialize
</span><span class="comment">-- the ZoneManager, including determining zone ownership, updating border ownership, setting drawing properties, and initializing
</span><span class="comment">-- event handlers and update schedulers for each zone. This comprehensive setup ensures that all zones are properly configured
</span><span class="comment">-- and ready for strategic gameplay and interactions within the game environment.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after initialization.
</span><a id="1071"></a><span class="comment">-- @usage local initializedZoneManager = SPECTRE.ZONEMGR:Init() -- Initializes and configures the ZoneManager with all necessary settings.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:Init()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:Init | ---------------------"</span>)
  <span class="comment">-- Determine ownership of each zone.
</span>  <span class="keyword">for</span> zoneName, zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
    zoneObject:DetermineZoneOwnership()
  <span class="keyword">end</span>

  <span class="comment">-- Update the border ownership for each zone.
</span>  <span class="keyword">for</span> zoneName, zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
    zoneObject:UpdateBorderOwnership()
  <span class="keyword">end</span>

  <span class="comment">-- Determine the drawing color, draw the zone, and draw arrows for each zone.
</span>  <span class="keyword">for</span> zoneName, zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
    zoneObject:DetermineDrawColor()
    zoneObject:DrawZone()
    zoneObject:DrawArrows()
  <span class="keyword">end</span>
  self:InitSSB()
  <span class="comment">-- Initialize event handlers for each zone.
</span>  <span class="keyword">for</span> zoneName, zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
    zoneObject:InitHandlers()
  <span class="keyword">end</span>

  <span class="comment">-- Initialize the update scheduler.
</span>  self:UpdateSchedInit()

  <span class="keyword">if</span> self.Hotspots == <span class="keyword">true</span> <span class="keyword">then</span>
    self:HotspotSchedInit()
  <span class="keyword">end</span>

  <span class="keyword">if</span> self._enableCAP == <span class="keyword">true</span> <span class="keyword">then</span>
    self:CAPschedInit()
  <span class="keyword">end</span>

  <span class="comment">--  if self._AirfieldCaptureSpawns then
</span>  <span class="comment">--    self._AirfieldCaptureHandler = EVENT:New()
</span>  <span class="comment">--    self._AirfieldCaptureHandler:HandleEvent(EVENTS.BaseCaptured, function(eventData)
</span>  <span class="comment">--      self:_AirfieldCapture(eventData)
</span>  <span class="comment">--    end)
</span>  <span class="comment">--  end
</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Initializes a scheduler for periodic zone updates following base captures.
</span><span class="comment">--
</span><span class="comment">-- This function sets up a scheduler within the ZONEMGR system to periodically check and update zones. The updates are triggered
</span><span class="comment">-- by changes resulting from base captures. It ensures that the zone states within the game environment are accurately updated to
</span><span class="comment">-- reflect the latest developments, such as changes in ownership, borders, and zone draw colors. This dynamic updating is crucial
</span><span class="comment">-- for maintaining an up-to-date and strategically accurate game map.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance with the update scheduler initialized.
</span><a id="1126"></a><span class="comment">-- @usage local updatedZoneManager = SPECTRE.ZONEMGR:UpdateSchedInit() -- Initializes the update scheduler for the ZoneManager.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:UpdateSchedInit()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:UpdateSchedInit | ---------------------"</span>)
  self.UpdateSched = SCHEDULER:New(self, <span class="keyword">function</span>()
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:self.UpdateSched | "</span>)
    <span class="keyword">if</span> <span class="keyword">not</span> self.UpdatingZones <span class="keyword">then</span>
      <span class="keyword">local</span> zoneNeedsUpdate = <span class="keyword">false</span>
      <span class="keyword">for</span> zoneName, zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
        <span class="keyword">if</span> zoneObject.UpdateQueue &gt; <span class="number">0</span> <span class="keyword">then</span>
          zoneNeedsUpdate = <span class="keyword">true</span>
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:self.UpdateSched | ZONE NEEDS UPDATES: "</span> .. zoneName .. <span class="string">" | Q:"</span> .. zoneObject.UpdateQueue )
          self.UpdatingZones = <span class="keyword">true</span>
          <span class="keyword">break</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span>
      <span class="keyword">if</span> zoneNeedsUpdate <span class="keyword">then</span>
        <span class="keyword">for</span> zoneName, zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
          zoneObject:DetermineZoneOwnership()
        <span class="keyword">end</span>
        <span class="keyword">for</span> zoneName, zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
          zoneObject:UpdateBorderOwnership()
        <span class="keyword">end</span>
        <span class="keyword">for</span> zoneName, zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
          zoneObject:DetermineDrawColor()
          zoneObject:DrawZone()
          zoneObject:DrawArrows()
        <span class="keyword">end</span>
        <span class="keyword">for</span> zoneName, zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
          <span class="keyword">if</span> zoneObject.UpdateQueue &gt; <span class="number">0</span> <span class="keyword">then</span>
            zoneObject.UpdateQueue = zoneObject.UpdateQueue - <span class="number">1</span>
            <span class="keyword">if</span> zoneObject.UpdateQueue &gt; <span class="number">2</span> <span class="keyword">then</span> zoneObject.UpdateQueue = <span class="number">2</span> <span class="keyword">end</span>
            SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:self.UpdateSched | END UPDATE RUN: "</span> .. zoneName .. <span class="string">" | Q: "</span> .. zoneObject.UpdateQueue )
          <span class="keyword">end</span>
        <span class="keyword">end</span>
        self.UpdatingZones = <span class="keyword">false</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> self
  <span class="keyword">end</span>, {self}, self.UpdateInterval, self.UpdateInterval, self.UpdateIntervalNudge)
  self:MarkerScheduleInit()
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Initializes the marker update scheduler for the zone manager.
</span><span class="comment">--
</span><span class="comment">-- This function sets up a scheduler to manage marker operations within the zone manager.
</span><span class="comment">-- It processes various marker queues including hotspot, marker, and marker removal queues.
</span><span class="comment">-- The scheduler handles the addition, update, and removal of markers at specified intervals.
</span><span class="comment">-- This only exists because of a bug in DCS. When it is fixed updates wont be tied to a schedule queue.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR
</span><span class="comment">-- @return #ZONEMGR self
</span><a id="1178"></a><span class="comment">-- @usage zoneManager:MarkerScheduleInit() -- Initializes the marker update scheduler for 'zoneManager'.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:MarkerScheduleInit()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:MarkerScheduleInit | ---------------------"</span>)

  <span class="comment">-- Scheduler for managing marker operations
</span>  self._markerScheduler = SCHEDULER:New(self, <span class="keyword">function</span>()
    <span class="comment">-- Process markers for hotspot queue
</span>    <span class="keyword">for</span> i = #self._hotspotQueue, <span class="number">1</span>, -<span class="number">1</span> <span class="keyword">do</span>
      <span class="keyword">local</span> _marker = self._hotspotQueue[i]
      <span class="keyword">if</span> _marker <span class="keyword">then</span>
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:MarkerSchedule | Mark Circle: "</span> .. <span class="global">tostring</span>(_marker.MarkerID))
        trigger.action.circleToAll(_marker.coal, _marker.MarkerID, _marker.Vec3, _marker.radius, _marker.color, _marker.fillColor, _marker.num, _marker.ReadOnly)
        <span class="global">table</span>.remove(self._hotspotQueue, i)  <span class="comment">-- Remove processed marker
</span>      <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">-- Process markers for marker queue
</span>    <span class="keyword">for</span> i = #self._markerQueue, <span class="number">1</span>, -<span class="number">1</span> <span class="keyword">do</span>
      <span class="keyword">local</span> _marker = self._markerQueue[i]
      <span class="keyword">if</span> _marker <span class="keyword">then</span>
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:MarkerSchedule | Mark Intel: "</span> .. <span class="global">tostring</span>(_marker.MarkerID))
        trigger.action.markToCoalition(_marker.MarkerID, _marker.intelString, _marker.Vec3, _marker.coal, _marker.ReadOnly)
        <span class="global">table</span>.remove(self._markerQueue, i)  <span class="comment">-- Remove processed marker
</span>      <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">-- Process markers for removal
</span>    <span class="keyword">for</span> i = #self._removeMarkerQueue, <span class="number">1</span>, -<span class="number">1</span> <span class="keyword">do</span>
      <span class="keyword">local</span> _marker = self._removeMarkerQueue[i]
      <span class="keyword">if</span> _marker <span class="keyword">then</span>
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:MarkerSchedule | Remove Marker: "</span> .. <span class="global">tostring</span>(_marker.MarkerID))
        trigger.action.removeMark(_marker.MarkerID)
        <span class="global">table</span>.remove(self._removeMarkerQueue, i)  <span class="comment">-- Remove processed marker
</span>      <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">return</span> self
  <span class="keyword">end</span>, {self}, self.UpdateInterval, self.UpdateInterval, self.UpdateIntervalNudge)  <span class="comment">-- Schedule settings
</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>


<span class="comment">--- Activates the SSB  property within the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- This function enables the SSB property for the ZoneManager.
</span><span class="comment">-- The function allows for an optional parameter to enable or disable the SSB property, defaulting to true (enabled) if not specified.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param enabled (optional) Boolean value to enable (true) or disable (false) the SSB property. Defaults to true if not specified.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance with the SSB property initialized.
</span><a id="1229"></a><span class="comment">-- @usage local zoneManagerWithSSB = SPECTRE.ZONEMGR:enableSSB() -- Initializes the SSB property in the ZoneManager.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:enableSSB(enabled)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:InitSSB | ---------------------"</span>)
  enabled = enabled <span class="keyword">or</span> <span class="keyword">true</span>
  <span class="comment">-- Enable the SSB property.
</span>  self.SSB = enabled

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Activates the SSB property within the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- This function inits  SSB  for the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance with the SSB property initialized.
</span><a id="1245"></a><span class="comment">-- @usage local zoneManagerWithSSB = SPECTRE.ZONEMGR:InitSSB() -- Initializes the SSB property in the ZoneManager.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:InitSSB()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:InitSSB | ---------------------"</span>)
  <span class="keyword">if</span> self.SSB == <span class="keyword">true</span> <span class="keyword">then</span>
    <span class="comment">-- Enable the SSB property.
</span>    <span class="comment">-- Set the user flag "SSB" to the SSBoff value.
</span>    trigger.action.setUserFlag(<span class="string">"SSB"</span>, self.SSBoff)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Initializes the scheduler for managing hotspots within zones.
</span><span class="comment">--
</span><span class="comment">-- This function iterates through all zones managed by the ZONEMGR system and initializes individual hotspot schedulers
</span><span class="comment">-- for zones where hotspots are enabled. It ensures that hotspots
</span><span class="comment">-- are actively managed and updated within each zone. This process is vital for maintaining a dynamic and engaging game
</span><span class="comment">-- environment where strategic points (hotspots) can influence player actions and scenarios.
</span><span class="comment">--
</span><span class="comment">--
</span><span class="comment">-- This function sets up a scheduler to periodically check and update hotspots within the zone. It ensures that the hotspots
</span><span class="comment">-- and any related intelligence data are refreshed at regular intervals. The scheduler also accounts for ongoing updates,
</span><span class="comment">-- avoiding overlaps in processing. This systematic approach to managing hotspots enhances the zone's dynamics, ensuring
</span><span class="comment">-- that changes in game conditions are regularly reflected in hotspot statuses and information.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance with hotspot schedulers initialized for relevant zones.
</span><span class="comment">-- @usage local zoneManager = SPECTRE.ZONEMGR:New() -- Creates a new ZoneManager instance.
</span><a id="1272"></a><span class="comment">-- @usage zoneManager:HotspotSchedInit() -- Initializes hotspot schedulers for zones with hotspots enabled.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:HotspotSchedInit()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:HotspotSchedInit | ---------------------"</span>)
  <span class="keyword">for</span> zoneName, zoneObject <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
    <span class="comment">-- Initialize a scheduler to periodically check and update zones
</span>    self._HotspotSched[zoneName] = {}
    self._HotspotSched[zoneName] = SCHEDULER:New(self, <span class="keyword">function</span>()

        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:HotspotSched | ZONE: "</span> .. zoneName)
        <span class="comment">-- Only proceed if zones are not already being updated
</span>        <span class="keyword">if</span> <span class="keyword">not</span> zoneObject.UpdatingHotspots <span class="keyword">then</span>
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:HotspotSched | UPDATES NOT IN PROG, STARTING"</span>)
          zoneObject.UpdatingHotspots = <span class="keyword">true</span>

          <span class="keyword">local</span> _Timer = TIMER:New(<span class="keyword">function</span>()
            SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:HotspotSched | UPDATING     | "</span> .. zoneObject.ZoneName )
            <span class="keyword">if</span> zoneObject.Hotspots == <span class="keyword">true</span> <span class="keyword">then</span>
              zoneObject:getHotspotGroups()
              zoneObject:ClearHotspots()
              zoneObject:DrawHotspots()
            <span class="keyword">end</span>
            <span class="keyword">if</span> zoneObject.Intel == <span class="keyword">true</span> <span class="keyword">then</span>
              zoneObject:ClearIntel()
              zoneObject:getHotspotsIntel()
              <span class="comment">--zoneObject:DrawHotspotsIntel()
</span>            <span class="keyword">end</span>
            SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:HotspotSched | END UPDATING | "</span> .. zoneObject.ZoneName )
            zoneObject.UpdatingHotspots = <span class="keyword">false</span>
          <span class="keyword">end</span>, zoneObject)
          _Timer:Start(<span class="global">math</span>.random(<span class="number">1</span>,<span class="number">5</span>))
        <span class="keyword">else</span>
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:HotspotSched | UPDATES ALREADY IN PROG"</span>)
        <span class="keyword">end</span>
    <span class="keyword">end</span>, {self}, <span class="global">math</span>.random(<span class="number">1</span>,<span class="number">20</span>), self.UpdateInterval, self.UpdateIntervalNudge)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Initializes the Combat Air Patrol (CAP) scheduler for the zone manager.
</span><span class="comment">--
</span><span class="comment">-- This function sets up a scheduler to manage CAP operations within the zone manager.
</span><span class="comment">--
</span><span class="comment">-- It periodically checks and updates CAP units based on coalition ownership of zones.
</span><span class="comment">--
</span><span class="comment">-- The scheduler handles the dynamic allocation and management of CAP units, considering factors like:
</span><span class="comment">-- zone ownership, available templates, and specific settings for each coalition.
</span><span class="comment">--
</span><span class="comment">-- It ensures CAP units are deployed and managed effectively in response to the changing game environment.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR
</span><span class="comment">-- @return #ZONEMGR self
</span><a id="1323"></a><span class="comment">-- @usage zoneManager:CAPschedInit() -- Initializes the CAP scheduler for 'zoneManager'.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:CAPschedInit()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPschedInit | ---------------------"</span>)

  self._schedlerCAP = SCHEDULER:New(self, <span class="keyword">function</span>()
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:self.CAPsched | "</span>)
    <span class="comment">-- Only proceed if zones are not already being updated
</span>    <span class="keyword">if</span> <span class="keyword">not</span> self.UpdatingCAP <span class="keyword">then</span>
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPschedInit | UPDATES NOT IN PROG, STARTING"</span>)
      self.UpdatingCAP = <span class="keyword">true</span>

      <span class="keyword">local</span> _Timer = TIMER:New(<span class="keyword">function</span>()
        <span class="keyword">for</span> _coal = <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span> <span class="keyword">do</span>
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched | UPDATING | _coal: "</span> .. _coal .. <span class="string">" ~~~~~~~~~~"</span>)
          <span class="keyword">local</span> ownedZones = {}
          <span class="keyword">local</span> _numTotal = <span class="number">0</span>
          <span class="keyword">for</span> _k, _v <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
            _numTotal = _numTotal + <span class="number">1</span>
            <span class="keyword">if</span> _v.OwnedByCoalition == _coal <span class="keyword">then</span> ownedZones[_k] = _k <span class="keyword">end</span>
          <span class="keyword">end</span>
          <span class="keyword">local</span> _numOwned = SPECTRE.UTILS.sumTable(ownedZones)

          <span class="keyword">local</span> _percentOwned = _numOwned / _numTotal



          <span class="keyword">local</span> _Templates = self._CAPtemplates[_coal]
          <span class="keyword">local</span> _Settings = self.settingsCAP[_coal]
          <span class="keyword">local</span> _Spawns = self._CAPspawns[_coal]
          <span class="keyword">local</span> _genNom = SPECTRE.UTILS.generateNominal(_Settings.Nominal*_percentOwned &gt; _Settings.Min <span class="keyword">and</span> _Settings.Nominal*_percentOwned <span class="keyword">or</span> _Settings.Min, _Settings.Min, _Settings.Max*_percentOwned, _Settings.NudgeFactor)
          <span class="keyword">local</span> _FreeSpawns = _genNom - #_Spawns

          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched | UPDATING | activeSpawns : "</span> .. #_Spawns )
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched | UPDATING | _genNom      : "</span> .. _genNom )
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched | UPDATING | _FreeSpawns  : "</span> .. _FreeSpawns )

          <span class="keyword">local</span> _SPAWNNAME = <span class="string">"CAP_"</span> .. _coal
          <span class="keyword">local</span> _spawnCountry = _coal == <span class="number">1</span> <span class="keyword">and</span> SPECTRE.Countries.Red <span class="keyword">or</span> _coal == <span class="number">2</span> <span class="keyword">and</span> SPECTRE.Countries.Blue
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched | UPDATING | _spawnCountry   : "</span> .. <span class="global">tostring</span>(_spawnCountry) )

          <span class="keyword">while</span> _FreeSpawns &gt; <span class="number">0</span> <span class="keyword">do</span>
            <span class="keyword">local</span> _spawnTemplate = SPECTRE.UTILS.PickRandomFromTable(_Templates)
            SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched | UPDATING | _spawnTemplate  : "</span> .. <span class="global">tostring</span>(_spawnTemplate ))

            <span class="keyword">local</span> _selectedZone = SPECTRE.UTILS.PickRandomFromKVTable(ownedZones)
            SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPschedInit | UPDATING | _selectedZone  : "</span> .. <span class="global">tostring</span>(_selectedZone ))

            <span class="keyword">local</span> _selectedAirbase
            <span class="keyword">if</span> _selectedZone <span class="keyword">then</span>
              <span class="keyword">local</span> ownedAirbases = {}
              <span class="keyword">for</span> _k, _v <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones[_selectedZone].Airbases) <span class="keyword">do</span>
                <span class="keyword">local</span> _airbaseCoal = AIRBASE:FindByName(_k):GetCoalition()
                <span class="keyword">if</span> _airbaseCoal == _coal <span class="keyword">then</span> ownedAirbases[_k] = _k <span class="keyword">end</span>
              <span class="keyword">end</span>
              _selectedAirbase = SPECTRE.UTILS.PickRandomFromKVTable(ownedAirbases)
            <span class="keyword">end</span>
            SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched | UPDATING | _selectedAirbase  : "</span> .. <span class="global">tostring</span>(_selectedAirbase ))

            <span class="keyword">if</span> _selectedAirbase <span class="keyword">then</span>

              <span class="keyword">local</span> typeCounter = SPECTRE.COUNTER<span class="comment">--self.COUNTER
</span>              <span class="keyword">local</span> tempCode = typeCounter
              <span class="keyword">local</span> FoundGroup

              <span class="keyword">repeat</span>
                FoundGroup = GROUP:FindByName(_SPAWNNAME .. <span class="string">"_"</span> .. tempCode .. <span class="string">"#001"</span>)
                <span class="keyword">if</span> FoundGroup <span class="keyword">then</span>
                  tempCode = tempCode + <span class="number">1</span>
                <span class="keyword">else</span>
                  FoundGroup = <span class="keyword">false</span>
                <span class="keyword">end</span>
              <span class="keyword">until</span> (FoundGroup == <span class="keyword">false</span>)
              typeCounter = tempCode
              SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched | UPDATING | typeCounter     : "</span> .. <span class="global">tostring</span>(typeCounter) )

              <span class="keyword">local</span> _specZoneObj = self.Zones[_selectedZone]
              <span class="keyword">local</span> _initialMinDist, _initialMaxDist = SPECTRE.POLY.getMinMaxDistances(_specZoneObj.Vertices2D)

              <span class="keyword">local</span> _bias = (<span class="global">math</span>.random() &gt; <span class="number">0.5</span> <span class="keyword">and</span> (_specZoneObj.HotspotClusters[<span class="number">1</span>] <span class="keyword">and</span> <span class="number">1</span>)) <span class="keyword">or</span> ((_specZoneObj.HotspotClusters[<span class="number">2</span>] <span class="keyword">and</span> <span class="number">2</span>) <span class="keyword">or</span> (_specZoneObj.HotspotClusters[<span class="number">1</span>] <span class="keyword">and</span> <span class="number">1</span>) ) <span class="keyword">or</span> <span class="number">0</span>
              <span class="keyword">local</span> _min = _bias == _coal <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">or</span> _initialMinDist*self._smartFillMinDistFactor
              <span class="keyword">local</span> _max = _initialMinDist
              <span class="keyword">local</span> _vec2SMART = self:getSmartVec2(_specZoneObj.Vertices2D, _specZoneObj.HotspotClusters, _bias , _min, _max)
              <span class="keyword">local</span> _defenseCOORD = COORDINATE:NewFromVec2(_vec2SMART)


              <span class="keyword">local</span> Packet = {
                Zone_Engage = _initialMinDist/<span class="number">2</span> &gt; <span class="number">92600</span> <span class="keyword">and</span> _initialMinDist/<span class="number">2</span> <span class="keyword">or</span> <span class="number">92600</span>,
                OFFSET = <span class="number">1</span>,
                Coordinate_ = _defenseCOORD,
                Alt = UTILS.FeetToMeters(UTILS.Randomize(<span class="number">30000</span>, <span class="number">0.15</span>)),
                speed = UTILS.KnotsToMps(<span class="number">485</span>),
                heading = <span class="keyword">nil</span>,
                distance = <span class="keyword">nil</span>,
                airbaseCoord = AIRBASE:FindByName(_selectedAirbase):GetCoordinate(),
              }
              Packet = SPECTRE.AI.buildWaypoints.CAP(Packet)

              <span class="keyword">if</span> SPECTRE.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched PACKET | UPDATING | GROUP NAME   : "</span> ..  _SPAWNNAME .. <span class="string">"_"</span> .. tempCode)
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched PACKET | UPDATING | _bias        : "</span> ..  _bias)
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched PACKET | UPDATING | _min         : "</span> ..  _min)
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched PACKET | UPDATING | _max         : "</span> ..  _max)
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched PACKET | UPDATING | Zone_Engage  : "</span> ..  Packet.Zone_Engage)
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched PACKET | UPDATING | Alt          : "</span> ..  Packet.Alt)
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched PACKET | UPDATING | speed        : "</span> ..  Packet.speed)
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched PACKET | UPDATING | _vec2SMART   : x = "</span> ..  _vec2SMART.x .. <span class="string">" | y = "</span> ..  _vec2SMART.y)
                <span class="comment">--                local oppcoalt_ = {[0] = -1, [1] = 2, [2] = 1,} --2
</span>                <span class="comment">--                local color = {0.7, 0.46, 0.48, 0.9}
</span>                <span class="comment">--                local fillColor = {0.6, 0.66, 0.78, 0.5}
</span>                <span class="comment">--                local oppcoal = oppcoalt_[_coal]
</span>                <span class="comment">--                local _t = self.codeMarker_ + 1
</span>                <span class="comment">--                local _markID = _t
</span>                <span class="comment">--                self.codeMarker_= _markID
</span>                <span class="comment">--                trigger.action.circleToAll(-1 ,_markID , _defenseCOORD:GetVec3(),
</span>                <span class="comment">--                  (Packet.Zone_Engage), color, fillColor, 2, self.ReadOnly)
</span>              <span class="keyword">end</span>
              <span class="keyword">local</span> _CAPgroup = SPAWN:NewWithAlias(_spawnTemplate, _SPAWNNAME .. <span class="string">"_"</span> .. tempCode)
                :InitCoalition(_coal)
                :InitCountry(_spawnCountry)
                :InitCleanUp(<span class="number">120</span>)
                :InitAirbase(_selectedAirbase,SPAWN.Takeoff.Hot)
                :OnSpawnGroup(
                  <span class="keyword">function</span>(spawnGroup_)
                    <span class="comment">-- Build the CAP route using the spawn group and packet details
</span>                    <span class="keyword">local</span> route = SPECTRE.AI.buildRoute.CAP(spawnGroup_, Packet)
                    <span class="comment">-- Configure the spawn group for the CAP
</span>                    spawnGroup_ = SPECTRE.AI.configureCommonOptions(spawnGroup_)
                    <span class="comment">-- Set the route for the CAP group
</span>                    spawnGroup_:Route(route, <span class="global">math</span>.random(<span class="number">1</span>,<span class="number">5</span>))
                  <span class="keyword">end</span>, self)
                :Spawn()

              _CAPgroup.WIPE_ = <span class="keyword">false</span>
              <span class="comment">-- Common function to handle both landing and dead/crash events
</span>              <span class="keyword">local</span> <span class="keyword">function</span> handleEvent(_, eventData, message)
                <span class="keyword">local</span> coal = eventData.IniCoalition
                <span class="keyword">if</span> _CAPgroup:CountAliveUnits() == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> _CAPgroup.WIPE_ <span class="keyword">then</span>
                  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_CAPgroup handleEvent | UPDATING | GROUP WIPE  : "</span> ..  _SPAWNNAME .. <span class="string">"_"</span> .. tempCode )
                  _CAPgroup.WIPE_ = <span class="keyword">true</span>
                  <span class="keyword">local</span> _spawnIndex = SPECTRE.UTILS.getIndex(_Spawns, _CAPgroup)
                  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_CAPgroup.handleEvent | UPDATING | _spawnIndex  : "</span> ..  <span class="global">tostring</span>(_spawnIndex) )
                  <span class="keyword">local</span> _Restocktimer = TIMER:New(<span class="keyword">function</span>()
                    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_CAPgroup handleEvent | UPDATING | _Restocktimer  : "</span> ..  <span class="global">tostring</span>(_SPAWNNAME) .. <span class="string">"_"</span> .. tempCode )
                    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_CAPgroup handleEvent | UPDATING | REMOVING INDEX  : "</span> .. <span class="global">tostring</span>( _spawnIndex) .. <span class="string">" from "</span> .. _coal, _Spawns )
                    <span class="global">table</span>.remove(_Spawns,_spawnIndex)
                  <span class="keyword">end</span>, self)
                  _Restocktimer:Start(_Settings.RestockTime)

                <span class="keyword">end</span>
              <span class="keyword">end</span>

              _CAPgroup.onGroupLand = <span class="keyword">function</span>(_, eventData)
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_CAPgroup.onGroupLand | UPDATING | eventData  : "</span> , eventData )
                handleEvent(_, eventData)
              <span class="keyword">end</span>

              _CAPgroup.onGroupCrashOrDead = <span class="keyword">function</span>(_, eventData)
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_CAPgroup.onGroupCrashOrDead | UPDATING | eventData  : "</span> , eventData )
                handleEvent(_, eventData)
              <span class="keyword">end</span>

              _CAPgroup:HandleEvent(EVENTS.Land, _CAPgroup.onGroupLand)
              _CAPgroup:HandleEvent(EVENTS.Crash, _CAPgroup.onGroupCrashOrDead)
              _CAPgroup:HandleEvent(EVENTS.Dead, _CAPgroup.onGroupCrashOrDead)

              <span class="global">table</span>.insert(_Spawns, _CAPgroup)
              _FreeSpawns = _FreeSpawns - <span class="number">1</span>
            <span class="keyword">else</span>
              _FreeSpawns = <span class="number">0</span>
            <span class="keyword">end</span>
          <span class="keyword">end</span>
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPsched | END UPDATING | _coal: "</span> .. _coal .. <span class="string">" ~~~~~~~~~~"</span>)
        <span class="keyword">end</span>
        self.UpdatingCAP = <span class="keyword">false</span>
        <span class="comment">--return self
</span>      <span class="keyword">end</span>, self)
      _Timer:Start(<span class="global">math</span>.random(<span class="number">1</span>,<span class="number">5</span>))
    <span class="keyword">else</span>
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:CAPschedInit | UPDATES ALREADY IN PROG"</span>)
    <span class="keyword">end</span>
    <span class="keyword">return</span> self
  <span class="keyword">end</span>, {self}, <span class="global">math</span>.random(<span class="number">1</span>,<span class="number">5</span>), <span class="global">math</span>.random(self.schedulerCAPMin,self.schedulerCAPMax), self.schedulerCAPFactor)

  <span class="keyword">return</span> self
<span class="keyword">end</span>


<span class="comment">--- x - Setup.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with Zone Manager operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span>
<span class="comment">--- Adds a CAP group template for a specified coalition.
</span><span class="comment">--
</span><span class="comment">-- This function adds a new Combat Air Patrol (CAP) group template to the zone manager for a specific coalition, ensuring no duplicates.
</span><span class="comment">-- It updates the <code>_CAPtemplates</code> attribute by adding the specified group name if it's not already present.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self
</span><span class="comment">-- @param coalition The coalition identifier (0, 1, or 2).
</span><span class="comment">-- @param groupName The name of the CAP group to be added.
</span><span class="comment">-- @return #ZONEMGR self
</span><a id="1527"></a><span class="comment">-- @usage zoneManager:addCAP(1, "CAPGroup1") -- Adds "CAPGroup1" to the CAP templates for coalition 1.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:addCAP(coalition, groupName)
  <span class="keyword">if</span> <span class="keyword">not</span> SPECTRE.UTILS.table_hasValue( self._CAPtemplates[coalition], groupName) <span class="keyword">then</span>
    <span class="global">table</span>.insert(self._CAPtemplates[coalition],groupName )
    <span class="comment">-- self._CAPtemplates[coalition][#self._CAPtemplates[coalition] + 1] = groupName
</span>  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Removes a CAP group template from a specified coalition.
</span><span class="comment">--
</span><span class="comment">-- This function removes a specified Combat Air Patrol (CAP) group template from the zone manager for a given coalition.
</span><span class="comment">-- It locates the group name within the <code>_CAPtemplates</code> and removes it if found.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self
</span><span class="comment">-- @param coalition The coalition identifier (0, 1, or 2).
</span><span class="comment">-- @param groupName The name of the CAP group to be removed.
</span><span class="comment">-- @return #ZONEMGR self
</span><a id="1545"></a><span class="comment">-- @usage zoneManager:removeCAP(1, "CAPGroup1") -- Removes "CAPGroup1" from the CAP templates for coalition 1.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:removeCAP(coalition, groupName)
  <span class="keyword">local</span> _index = SPECTRE.UTILS.getIndex(self._CAPtemplates[coalition], groupName)
  <span class="keyword">if</span> _index <span class="keyword">then</span>
    <span class="global">table</span>.remove(self._CAPtemplates[coalition], _index)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Adds a player UCID to the admin list.
</span><span class="comment">--
</span><span class="comment">-- This function adds a specified player's UCID to the zone manager's admin list, allowing for administrative control or privileges within the game.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self
</span><span class="comment">-- @param ucid The player UCID to be added to the admin list.
</span><span class="comment">-- @return #ZONEMGR self
</span><a id="1561"></a><span class="comment">-- @usage zoneManager:addAdmin("PlayerUCID1234") -- Adds "PlayerUCID1234" to the admin list.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:addAdmin(ucid)
  self.AdminUCIDs[ucid] = ucid
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Removes a player UCID from the admin list.
</span><span class="comment">--
</span><span class="comment">-- This function removes a specified player's UCID from the zone manager's admin list, revoking any administrative control or privileges.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self
</span><span class="comment">-- @param ucid The player UCID to be removed from the admin list.
</span><span class="comment">-- @return #ZONEMGR self
</span><a id="1574"></a><span class="comment">-- @usage zoneManager:removeAdmin("PlayerUCID1234") -- Removes "PlayerUCID1234" from the admin list.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:removeAdmin(ucid)
  self.AdminUCIDs[ucid] = <span class="keyword">nil</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Sets the interval and nudge factor for periodic zone updates.
</span><span class="comment">--
</span><span class="comment">-- This function configures the time interval and nudge factor for periodic updates of zones within the ZONEMGR system. The interval
</span><span class="comment">-- determines how frequently the zone states are checked and potentially updated, while the nudge factor allows for slight adjustments
</span><span class="comment">-- in timing to ensure optimal performance. This configuration is important for balancing the need for timely zone updates with
</span><span class="comment">-- resource efficiency in the game environment.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param interval (optional) The time interval in seconds for zone updates. Defaults to 25 seconds if not specified.
</span><span class="comment">-- @param nudge (optional) A nudge factor to adjust the update timing. Defaults to 0.25 if not specified.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance with the updated interval settings.
</span><span class="comment">-- @usage local zoneManager = SPECTRE.ZONEMGR:New() -- Creates a new ZoneManager instance.
</span><a id="1592"></a><span class="comment">-- @usage zoneManager:setUpdateInterval(30, 0.5) -- Sets the update interval to 30 seconds with a nudge factor of 0.5.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:setUpdateInterval(interval, nudge)
  interval = interval <span class="keyword">or</span> <span class="number">25</span>
  nudge = nudge <span class="keyword">or</span> <span class="number">0.25</span>
  self.UpdateInterval = interval
  self.UpdateIntervalNudge = nudge
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Configures the ZoneManager with specified zones.
</span><span class="comment">--
</span><span class="comment">-- This function is essential for initializing the ZoneManager with a specific set of zones. It seeds the airbases,
</span><span class="comment">-- creates new Zone objects for each zone name provided, and determines the bordering zones. It also configures
</span><span class="comment">-- zone-specific properties like airbases, ownership, and SSB groups. This setup is crucial for ensuring that
</span><span class="comment">-- the ZoneManager is properly configured to manage the specified zones, facilitating strategic gameplay and zone
</span><span class="comment">-- interactions within the game environment.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param ZoneNames A list of strings representing the names of the zones to be managed (e.g., {"Zone1", "Zone2"}).
</span><span class="comment">-- @param SSBFarps Currently unused
</span><span class="comment">-- @param SSBAll Currently unused
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after setup with the specified zones.
</span><a id="1614"></a><span class="comment">-- @usage local setupZoneManager = SPECTRE.ZONEMGR:Setup({"Zone1", "Zone2"}) -- Sets up the ZoneManager with "Zone1" and "Zone2".
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:Setup(ZoneNames, SSBFarps, SSBAll)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:Setup | ---------------------"</span>)
  SSBFarps = SSBFarps <span class="keyword">or</span> <span class="keyword">false</span>
  SSBAll = SSBAll <span class="keyword">or</span> <span class="keyword">false</span>

  self:seedAirbase()
  <span class="keyword">for</span> _, zone <span class="keyword">in</span> <span class="global">ipairs</span>(ZoneNames) <span class="keyword">do</span>
    self.Zones[zone] = self.Zone:New(zone, self):enableZoneHotspot(self.Hotspots):enableHotspotIntel(self.Intel):enableAirfieldCaptureSpawns(self._AirfieldCaptureSpawns)
  <span class="keyword">end</span>
  self:determineBorderingZones()
  <span class="keyword">for</span> _, zone <span class="keyword">in</span> <span class="global">ipairs</span>(ZoneNames) <span class="keyword">do</span>
    <span class="keyword">local</span> currentZone = self.Zones[zone]

    currentZone:DetermineAirbasesInZone()
    currentZone:DetermineZoneOwnership()
    currentZone:DetermineAirbaseSSBGroups()
  <span class="keyword">end</span>
  <span class="comment">--    if SSBAll then
</span>  <span class="comment">--      currentZone:DetermineAirbaseSSBGroups_All()
</span>  <span class="comment">--    elseif SSBFarps then
</span>  <span class="comment">--      currentZone:DetermineAirbaseSSBGroups()
</span>  <span class="comment">--      currentZone:DetermineFARPSSBGroups()
</span>  <span class="comment">--    else
</span>  <span class="comment">--      currentZone:DetermineAirbaseSSBGroups()
</span>  <span class="comment">--    end
</span>  <span class="comment">--  end
</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- x - Internal.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with Zone Manager operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span>
<span class="comment">--- Identifies and defines the borders between adjacent zones.
</span><span class="comment">--
</span><span class="comment">-- This function plays a crucial role in the ZONEMGR system by identifying which zones border each other and determining
</span><span class="comment">-- the specific sides where these borders occur. It comprehensively assesses each zone in relation to others, ensuring
</span><span class="comment">-- that bordering zones are accurately recognized and their border details correctly established. This process is essential
</span><span class="comment">-- for strategic gameplay elements, as it impacts zone control, movement, and conflict dynamics within the game environment.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after determining the bordering zones.
</span><a id="1662"></a><span class="comment">-- @usage local zoneManagerWithBorders = SPECTRE.ZONEMGR:determineBorderingZones() -- Determines and defines the borders between adjacent zones in the ZoneManager.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:determineBorderingZones()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:determineBorderingZones | ---------------------"</span>)
  <span class="keyword">for</span> zoneName1, zone1 <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>
    <span class="keyword">for</span> zoneName2, zone2 <span class="keyword">in</span> <span class="global">pairs</span>(self.Zones) <span class="keyword">do</span>

      <span class="comment">-- Ensure we're not comparing a zone with itself
</span>      <span class="keyword">if</span> zoneName1 ~= zoneName2 <span class="keyword">then</span>
        <span class="keyword">local</span> borderIndex = <span class="number">0</span>  <span class="comment">-- Initialize index for potential borders
</span>
        <span class="comment">-- Compare borders of zone1 with zone2
</span>        <span class="keyword">for</span> _, lineA <span class="keyword">in</span> <span class="global">ipairs</span>(zone1.LinesVec2) <span class="keyword">do</span>
          <span class="keyword">for</span> _, lineB <span class="keyword">in</span> <span class="global">ipairs</span>(zone2.LinesVec2) <span class="keyword">do</span>

            <span class="comment">-- Check if two lines are close enough to be considered bordering
</span>            <span class="keyword">if</span> SPECTRE.POLY.isWithinOffset(lineA, lineB, zone1.BorderOffsetThreshold) <span class="keyword">then</span>
              borderIndex = borderIndex + <span class="number">1</span>  <span class="comment">-- Increment the index for borders found
</span>
              <span class="comment">-- Initialize border data structure if it doesn't exist
</span>              <span class="keyword">local</span> zoneBorder = self.Zones[zoneName1].BorderingZones[zoneName2] <span class="keyword">or</span> {}
              zoneBorder[borderIndex] = zoneBorder[borderIndex] <span class="keyword">or</span> {}

              <span class="comment">-- Populate border details
</span>              <span class="keyword">local</span> currentBorder = zoneBorder[borderIndex]
              currentBorder.OwnedByCoalition = <span class="number">0</span>
              currentBorder.ZoneLine = lineA
              currentBorder.ZoneLineLen = SPECTRE.POLY.lineLength(lineA)
              currentBorder.ZoneLineMidP = SPECTRE.POLY.getMidpoint(lineA)
              currentBorder.ZoneLineSlope = SPECTRE.POLY.calculateLineSlope(lineA)
              currentBorder.ZoneLinePerpendicularPoint = {}
              currentBorder.NeighborLine = lineB
              currentBorder.NeighborLineLen = SPECTRE.POLY.lineLength(lineB)
              currentBorder.NeighborLineMidP = SPECTRE.POLY.getMidpoint(lineB)
              currentBorder.NeighborLineSlope = SPECTRE.POLY.calculateLineSlope(lineB)
              currentBorder.NeighborLinePerpendicularPoint = {}
              currentBorder.MarkID = {
                [<span class="number">0</span>] = <span class="number">0</span>,
                [<span class="number">1</span>] = <span class="number">0</span>,
                [<span class="number">2</span>] = <span class="number">0</span>,
              }

              <span class="comment">-- Determine the perpendicular points and update them
</span>              <span class="keyword">local</span> ArrowMP, line_, NeighborLine_, length_, NeighborLength_
              <span class="keyword">if</span> currentBorder.ZoneLineLen &lt;= currentBorder.NeighborLineLen <span class="keyword">then</span>
                ArrowMP = currentBorder.ZoneLineMidP
                line_ = currentBorder.ZoneLine
                NeighborLine_ = {[<span class="number">1</span>] = line_[<span class="number">2</span>], [<span class="number">2</span>] = line_[<span class="number">1</span>]}
                length_ = self.Zones[zoneName1].ArrowLength
                NeighborLength_ = -(length_)
              <span class="keyword">else</span>
                ArrowMP = currentBorder.NeighborLineMidP
                line_ = currentBorder.NeighborLine
                NeighborLine_ = {[<span class="number">1</span>] = line_[<span class="number">2</span>], [<span class="number">2</span>] = line_[<span class="number">1</span>]}
                length_ = self.Zones[zoneName1].ArrowLength
                NeighborLength_ = -(length_)
              <span class="keyword">end</span>

              <span class="keyword">local</span> _ZoneLinePerpendicularPoint = SPECTRE.POLY.findPerpendicularEndpoints(ArrowMP, line_, length_)
              <span class="keyword">local</span> _NeighborLinePerpendicularPoint = SPECTRE.POLY.findPerpendicularEndpoints(ArrowMP, NeighborLine_, NeighborLength_)

              <span class="comment">-- Adjust perpendicular points if needed to ensure they are within the zone shape
</span>              <span class="keyword">if</span> SPECTRE.POLY.PointWithinShape(_ZoneLinePerpendicularPoint, self.Zones[zoneName1].Vertices2D) <span class="keyword">then</span>
                currentBorder.ZoneLinePerpendicularPoint = SPECTRE.POLY.findPerpendicularEndpoints(ArrowMP, line_, length_)
                currentBorder.NeighborLinePerpendicularPoint = SPECTRE.POLY.findPerpendicularEndpoints(ArrowMP, NeighborLine_, NeighborLength_)
              <span class="keyword">else</span>
                currentBorder.ZoneLinePerpendicularPoint = SPECTRE.POLY.findPerpendicularEndpoints(ArrowMP, NeighborLine_, NeighborLength_)
                currentBorder.NeighborLinePerpendicularPoint = SPECTRE.POLY.findPerpendicularEndpoints(ArrowMP, line_, length_)
              <span class="keyword">end</span>

              <span class="comment">-- Save back the updated border data
</span>              self.Zones[zoneName1].BorderingZones[zoneName2] = zoneBorder
            <span class="keyword">end</span>
          <span class="keyword">end</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Identifies the airbases relevant to the current map.
</span><span class="comment">--
</span><span class="comment">-- This function is crucial for establishing the correct context within the ZoneManager by identifying the airbases associated
</span><span class="comment">-- with the current map. It utilizes a pre-defined lookup table that maps map names to their respective airbases, ensuring that
</span><span class="comment">-- the ZoneManager is aware of the relevant airbases for zone management and related strategic decisions. This is essential for
</span><span class="comment">-- accurately reflecting the geographical and strategic realities of the game's environment.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after identifying the relevant airbases for the current map.
</span><a id="1752"></a><span class="comment">-- @usage local zoneManagerWithAirbase = SPECTRE.ZONEMGR:seedAirbase() -- Identifies and sets the airbases for the current map in the ZoneManager.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:seedAirbase()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:seedAirbase | ---------------------"</span>)
  <span class="comment">-- Define a lookup table to map map names to their respective airbases.
</span>  <span class="keyword">local</span> airbaseMap = {
    [<span class="string">"Syria"</span>] = AIRBASE.Syria,
    [<span class="string">"Persia"</span>] = AIRBASE.PersianGulf,
    [<span class="string">"Caucasus"</span>] = AIRBASE.Caucasus,
    [<span class="string">"Sinai"</span>] = AIRBASE.Sinai,
    [<span class="string">"MarianaIslands"</span>] = AIRBASE.MarianaIslands,
    [<span class="string">"Nevada"</span>] = AIRBASE.Nevada,
    [<span class="string">"Normandy"</span>] = AIRBASE.Normandy,
    [<span class="string">"SouthAtlantic"</span>] = AIRBASE.SouthAtlantic,
    [<span class="string">"TheChannel"</span>] = AIRBASE.TheChannel
  }

  <span class="comment">-- Set the AirbaseSeed property based on the current map name.
</span>  self.AirbaseSeed = airbaseMap[SPECTRE.MAPNAME]

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- x - Live Editor.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with Zone Manager operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span>
<span class="comment">--- Processes marker events for live editing in the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- This function handles marker events triggered by players, allowing for dynamic modifications to the game's zones.
</span><span class="comment">-- It distinguishes between deletion and spawning commands, dispatching the appropriate actions based on the marker's content.
</span><span class="comment">-- The function removes the original marker after processing the event to maintain a clean game environment.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param Packet Table containing details about the marker event, including the marker type and player information.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after processing the marker event.
</span><a id="1791"></a><span class="comment">-- @usage zoneManager:_EventMarker(packetData) -- Processes the marker event based on the provided packet data.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:_EventMarker(Packet)
  <span class="keyword">local</span> PlayerUCID = SPECTRE.UTILS.GetPlayerInfo(Packet.MarkInfo.author, <span class="string">"ucid"</span>) <span class="comment">-- Fetching the unique ID of the player who changed the mark
</span>
  <span class="keyword">if</span> SPECTRE.UTILS.table_contains(self.AdminUCIDs, PlayerUCID) <span class="keyword">then</span>
    <span class="keyword">local</span> markerType = <span class="global">string</span>.upper(Packet.MarkerType[<span class="number">1</span>])

    <span class="keyword">if</span> markerType == <span class="string">"DEL"</span> <span class="keyword">then</span>
      self:_DELmarkerDispatcher(Packet)
    <span class="keyword">elseif</span> markerType == <span class="string">"SPAWN"</span> <span class="keyword">then</span>
      self:_SPAWNmarkerDispatcher(Packet)
    <span class="keyword">end</span>

    SPECTRE.MARKERS.World.RemoveByID(Packet.MarkInfo.idx)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Dispatches delete operations based on marker events in the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- This function interprets marker events designated for deletion commands and routes them to the appropriate deletion functions.
</span><span class="comment">-- It can handle a variety of deletion types, including zones, airfields, all airfields, and circles, providing a comprehensive
</span><span class="comment">-- method for dynamically removing game elements via marker inputs.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param Packet Table containing details about the delete marker event, including the specific delete type and associated parameters.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after processing the delete marker event.
</span><a id="1818"></a><span class="comment">-- @usage zoneManager:_DELmarkerDispatcher(packetData) -- Dispatches the delete operation based on the marker event details.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:_DELmarkerDispatcher(Packet)
  <span class="keyword">local</span> _delType = <span class="global">string</span>.upper(Packet.MarkerType[<span class="number">2</span>])
  <span class="keyword">if</span> _delType == <span class="string">"ZONE"</span> <span class="keyword">then</span>
    self:_DELzone(Packet)
  <span class="keyword">elseif</span> _delType == <span class="string">"AIRFIELD"</span> <span class="keyword">then</span>
    self:_DELairfield(Packet)
  <span class="keyword">elseif</span> _delType == <span class="string">"ALLAIRFIELD"</span> <span class="keyword">then</span>
    self:_DELallAirfield(Packet)
  <span class="keyword">elseif</span> _delType == <span class="string">"CIRCLE"</span> <span class="keyword">then</span>
    self:_DELcircle(Packet)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Dispatches spawn operations based on marker events in the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- This function interprets marker events designated for spawning commands and directs them to the corresponding spawning functions.
</span><span class="comment">-- It is capable of handling various types of spawn requests, such as zones, airfields, all airfields, and circles,
</span><span class="comment">-- providing versatile options for adding new game elements dynamically through markers.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param Packet Table containing details about the spawn marker event, including the specific spawn type and related parameters.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after executing the spawn marker event.
</span><a id="1842"></a><span class="comment">-- @usage zoneManager:_SPAWNmarkerDispatcher(packetData) -- Executes the spawn operation according to the details in the marker event.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:_SPAWNmarkerDispatcher(Packet)
  <span class="keyword">local</span> _SPAWNType = <span class="global">string</span>.upper(Packet.MarkerType[<span class="number">2</span>])
  <span class="keyword">if</span> _SPAWNType == <span class="string">"ZONE"</span> <span class="keyword">then</span>
    self:_SPAWNzone(Packet)
  <span class="keyword">elseif</span> _SPAWNType == <span class="string">"AIRFIELD"</span> <span class="keyword">then</span>
    self:_SPAWNairfield(Packet)
  <span class="keyword">elseif</span> _SPAWNType == <span class="string">"ALLAIRFIELD"</span> <span class="keyword">then</span>
    self:_SPAWNallAirfield(Packet)
  <span class="keyword">elseif</span> _SPAWNType == <span class="string">"CIRCLE"</span> <span class="keyword">then</span>
    self:_SPAWNcircle(Packet)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Handles the deletion of a zone based on marker events in the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- This function processes a marker event designated for deleting a specific zone. It identifies the zone's location from the marker,
</span><span class="comment">-- finds the relevant zone, and proceeds to delete any units within that zone for the specified coalition. This allows for dynamic
</span><span class="comment">-- modification of the game environment in response to player inputs via markers.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param Packet Table containing details about the delete zone marker event, including marker type, position, and coalition.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after processing the delete zone marker event.
</span><a id="1866"></a><span class="comment">-- @usage zoneManager:_DELzone(packetData) -- Processes the deletion of a zone based on the marker event details.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:_DELzone(Packet)
  <span class="keyword">local</span> MarkerType = Packet.MarkerType
  <span class="keyword">local</span> MarkInfo = Packet.MarkInfo
  <span class="keyword">local</span> vec2 = mist.utils.makeVec2(MarkInfo.pos)
  <span class="keyword">local</span> _Zone = self:findZoneForVec2(vec2)
  <span class="keyword">local</span> _coalT = <span class="global">tonumber</span>(MarkerType[<span class="number">3</span>])
  <span class="keyword">local</span> temp_detectedUnits = self:FindUnitsInZone(_Zone.ZONEPOLYOBJ)
  <span class="keyword">local</span> _GroupNames = self:buildGroupsFromUnits(temp_detectedUnits, _coalT)
  SPECTRE.UTILS.deleteGroupsByName(_GroupNames)
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Handles spawning elements in a specific zone based on marker events in the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- This function processes a marker event designated for spawning elements within a specific zone. It identifies the zone's location from the marker,
</span><span class="comment">-- finds the relevant zone, and proceeds to spawn elements within that zone based on the specified coalition, country, and smart spawn parameters.
</span><span class="comment">-- This allows for dynamic and strategic gameplay interactions through player inputs via markers.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param Packet Table containing details about the spawn zone marker event, including marker type, position, coalition, country, and smart spawn parameters.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after processing the spawn zone marker event.
</span><a id="1888"></a><span class="comment">-- @usage zoneManager:_SPAWNzone(packetData) -- Processes the spawning of elements in a zone based on the marker event details.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:_SPAWNzone(Packet)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNzone | ---------------------"</span>)
  <span class="keyword">local</span> MarkerType = Packet.MarkerType
  <span class="keyword">local</span> MarkInfo = Packet.MarkInfo
  <span class="keyword">local</span> vec2 = mist.utils.makeVec2(MarkInfo.pos)
  <span class="keyword">local</span> _Zone = self:findZoneForVec2(vec2)
  <span class="keyword">local</span> _coalT = <span class="global">tonumber</span>(MarkerType[<span class="number">3</span>])
  <span class="keyword">local</span> _countryT = <span class="global">tonumber</span>(MarkerType[<span class="number">4</span>])
  <span class="keyword">local</span> _convCoal, _convCountry

  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNzone | _coalT     | "</span> .. MarkerType[<span class="number">3</span>])
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNzone | _countryT  | "</span> .. MarkerType[<span class="number">4</span>])

  <span class="keyword">if</span> _countryT == <span class="number">1</span> <span class="keyword">then</span> _convCountry = SPECTRE.Countries.Red
  <span class="keyword">elseif</span> _countryT == <span class="number">2</span> <span class="keyword">then</span> _convCountry = SPECTRE.Countries.Blue
  <span class="keyword">end</span>

  <span class="keyword">if</span> _coalT == <span class="number">1</span> <span class="keyword">then</span> _convCoal = SPECTRE.Coalitions.Red
  <span class="keyword">elseif</span> _coalT == <span class="number">2</span> <span class="keyword">then</span> _convCoal = SPECTRE.Coalitions.Blue
  <span class="keyword">end</span>
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNzone | ZoneName | ----- "</span> .. _Zone.ZoneName)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNzone | Coal     | "</span> .. _convCoal)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNzone | Country  | "</span> .. _convCountry)

  <span class="keyword">local</span> _smart = MarkerType[<span class="number">5</span>] <span class="keyword">or</span> <span class="number">0</span>
  <span class="keyword">if</span> _smart == <span class="number">0</span> <span class="keyword">then</span>
    self:spawnFillInZone(_Zone.ZoneName, _convCoal, _convCountry)
  <span class="keyword">else</span>
    <span class="keyword">local</span> _bias = MarkerType[<span class="number">6</span>] <span class="keyword">or</span> <span class="number">0</span>
    self:spawnFillInZoneSmart(_Zone.ZoneName, _convCoal, _convCountry, <span class="keyword">nil</span>, _bias)
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>
<span class="comment">--- Deletes an airfield and its associated elements based on a marker event in the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- This function processes a marker event designated for deleting an airfield within a specific zone. It identifies the closest airfield based on the marker's location,
</span><span class="comment">-- then finds and deletes all related groups within a defined radius of the airfield. This allows for dynamic changes in the game environment in response to player inputs via markers.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param Packet Table containing details about the delete airfield marker event, including marker type, position, and coalition.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after processing the delete airfield marker event.
</span><a id="1931"></a><span class="comment">-- @usage zoneManager:_DELairfield(packetData) -- Processes the deletion of an airfield and its associated elements based on the marker event details.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:_DELairfield(Packet)
  <span class="keyword">local</span> MarkerType = Packet.MarkerType
  <span class="keyword">local</span> MarkInfo = Packet.MarkInfo
  <span class="keyword">local</span> vec2 = mist.utils.makeVec2(MarkInfo.pos)
  <span class="keyword">local</span> _Zone = self:findZoneForVec2(vec2)
  <span class="keyword">local</span> _coalT = <span class="global">tonumber</span>(MarkerType[<span class="number">3</span>])

  <span class="keyword">local</span> tABList = {}
  <span class="keyword">for</span> _name, _ <span class="keyword">in</span> <span class="global">pairs</span> (_Zone.Airbases) <span class="keyword">do</span>
    <span class="global">table</span>.insert(tABList,_name)
  <span class="keyword">end</span>

  <span class="keyword">local</span> closestAB_ = SPECTRE.WORLD.FindNearestAirbaseToPointVec2(tABList, vec2)
  <span class="keyword">local</span> closestABVec3 = closestAB_[<span class="number">2</span>]
  <span class="keyword">local</span> t_ZOBJ = ZONE_RADIUS:New(<span class="string">"TEMPZ_"</span>, mist.utils.makeVec2(closestABVec3), <span class="number">15000</span>, <span class="keyword">true</span>)

  <span class="keyword">local</span> temp_detectedUnits = self:FindUnitsInZone(t_ZOBJ)
  <span class="keyword">local</span> _GroupNames = self:buildGroupsFromUnits(temp_detectedUnits, _coalT)

  SPECTRE.UTILS.deleteGroupsByName(_GroupNames)
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Spawns an airfield based on a marker event in the ZoneManager.
</span><span class="comment">--
</span><span class="comment">-- This function handles a marker event designated for spawning an airfield within a specific zone. It calculates the closest airfield to the marker's position,
</span><span class="comment">-- and then initiates the spawning of the airfield with the specified coalition and country parameters. This functionality allows for dynamic and strategic modifications
</span><span class="comment">-- to the game environment in response to player inputs via markers.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param Packet Table containing details about the spawn airfield marker event, including marker type, position, coalition, and country.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after processing the spawn airfield marker event.
</span><a id="1964"></a><span class="comment">-- @usage zoneManager:_SPAWNairfield(packetData) -- Processes the spawning of an airfield based on the marker event details.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:_SPAWNairfield(Packet)
  <span class="keyword">local</span> MarkerType = Packet.MarkerType
  <span class="keyword">local</span> MarkInfo = Packet.MarkInfo
  <span class="keyword">local</span> vec2 = mist.utils.makeVec2(MarkInfo.pos)
  <span class="keyword">local</span> _Zone = self:findZoneForVec2(vec2)
  <span class="keyword">local</span> _coalT = <span class="global">tonumber</span>(MarkerType[<span class="number">3</span>])
  <span class="keyword">local</span> _countryT = <span class="global">tonumber</span>(MarkerType[<span class="number">4</span>])
  <span class="keyword">local</span> _convCoal, _convCountry

  <span class="keyword">if</span> _countryT == <span class="number">1</span> <span class="keyword">then</span> _convCountry = SPECTRE.Countries.Red
  <span class="keyword">elseif</span> _countryT == <span class="number">2</span> <span class="keyword">then</span> _convCountry = SPECTRE.Countries.Blue
  <span class="keyword">end</span>

  <span class="keyword">if</span> _coalT == <span class="number">1</span> <span class="keyword">then</span> _convCoal = SPECTRE.Coalitions.Red
  <span class="keyword">elseif</span> _coalT == <span class="number">2</span> <span class="keyword">then</span> _convCoal = SPECTRE.Coalitions.Blue
  <span class="keyword">end</span>


  <span class="keyword">local</span> tABList = {}
  <span class="keyword">for</span> _name, _ <span class="keyword">in</span> <span class="global">pairs</span> (_Zone.Airbases) <span class="keyword">do</span>
    <span class="global">table</span>.insert(tABList,_name)
  <span class="keyword">end</span>

  <span class="keyword">local</span> closestAB_ = SPECTRE.WORLD.FindNearestAirbaseToPointVec2(tABList, vec2)
  self:spawnAirbase(closestAB_[<span class="number">1</span>], _convCoal, _convCountry )
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Deletes all airfields within a specific zone based on a marker event.
</span><span class="comment">--
</span><span class="comment">-- This function is responsible for handling a marker event that signals the deletion of all airfields within a designated zone.
</span><span class="comment">-- It identifies the airbases within the zone specified by the marker's position and then proceeds to remove any related units
</span><span class="comment">-- for the specified coalition. This function allows for dynamic and strategic control of airfield availability in the game environment,
</span><span class="comment">-- offering an advanced level of interactivity and adaptability in response to player inputs.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param Packet Table containing details about the delete all airfield marker event, including marker type, position, and coalition.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after processing the delete all airfield marker event.
</span><a id="2003"></a><span class="comment">-- @usage zoneManager:_DELallAirfield(packetData) -- Processes the deletion of all airfields in a specified zone based on the marker event.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:_DELallAirfield(Packet)
  <span class="keyword">local</span> MarkerType = Packet.MarkerType
  <span class="keyword">local</span> MarkInfo = Packet.MarkInfo
  <span class="keyword">local</span> vec2 = mist.utils.makeVec2(MarkInfo.pos)
  <span class="keyword">local</span> _Zone = self:findZoneForVec2(vec2)
  <span class="keyword">local</span> _coalT = <span class="global">tonumber</span>(MarkerType[<span class="number">3</span>])

  <span class="keyword">for</span> _name, _airbase <span class="keyword">in</span> <span class="global">pairs</span> (_Zone.Airbases) <span class="keyword">do</span>
    <span class="comment">--table.insert(tABList,_name)
</span>    <span class="keyword">local</span> closestAB_ = _airbase.Object
    <span class="keyword">local</span> closestABVec2 = closestAB_:GetVec2()
    <span class="keyword">local</span> t_ZOBJ = ZONE_RADIUS:New(<span class="string">"TEMPZ_"</span>, closestABVec2, <span class="number">15000</span>, <span class="keyword">true</span>)

    <span class="keyword">local</span> temp_detectedUnits = self:FindUnitsInZone(t_ZOBJ)
    <span class="keyword">local</span> _GroupNames = self:buildGroupsFromUnits(temp_detectedUnits, _coalT)

    SPECTRE.UTILS.deleteGroupsByName(_GroupNames)

  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Spawns all airfields within a specific zone based on a marker event.
</span><span class="comment">--
</span><span class="comment">-- This function handles a marker event that instructs the spawning of all airfields within a designated zone. It determines
</span><span class="comment">-- the airbases within the zone specified by the marker's position and spawns them for the specified coalition and country. This function
</span><span class="comment">-- offers a dynamic approach to manage airfield availability within the game environment, responding to player inputs to adaptively modify
</span><span class="comment">-- the strategic landscape.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param Packet Table containing details about the spawn all airfield marker event, including marker type, position, coalition, and country.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after processing the spawn all airfield marker event.
</span><a id="2036"></a><span class="comment">-- @usage zoneManager:_SPAWNallAirfield(packetData) -- Processes the spawning of all airfields in a specified zone based on the marker event.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:_SPAWNallAirfield(Packet)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNallAirfield | ---------------------"</span>)
  <span class="keyword">local</span> MarkerType = Packet.MarkerType
  <span class="keyword">local</span> MarkInfo = Packet.MarkInfo
  <span class="keyword">local</span> vec2 = mist.utils.makeVec2(MarkInfo.pos)
  <span class="keyword">local</span> _Zone = self:findZoneForVec2(vec2)
  <span class="keyword">local</span> _coalT = <span class="global">tonumber</span>(MarkerType[<span class="number">3</span>])
  <span class="keyword">local</span> _countryT = <span class="global">tonumber</span>(MarkerType[<span class="number">4</span>])
  <span class="keyword">local</span> _convCoal, _convCountry

  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNallAirfield | _coalT     | "</span> .. MarkerType[<span class="number">3</span>])
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNallAirfield | _countryT  | "</span> .. MarkerType[<span class="number">4</span>])


  <span class="keyword">if</span> _countryT == <span class="number">1</span> <span class="keyword">then</span> _convCountry = SPECTRE.Countries.Red
  <span class="keyword">elseif</span> _countryT == <span class="number">2</span> <span class="keyword">then</span> _convCountry = SPECTRE.Countries.Blue
  <span class="keyword">end</span>

  <span class="keyword">if</span> _coalT == <span class="number">1</span> <span class="keyword">then</span> _convCoal = SPECTRE.Coalitions.Red
  <span class="keyword">elseif</span> _coalT == <span class="number">2</span> <span class="keyword">then</span> _convCoal = SPECTRE.Coalitions.Blue
  <span class="keyword">end</span>
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNallAirfield | ZoneName | ----- "</span> .. _Zone.ZoneName)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNallAirfield | Coal     | "</span> .. _convCoal)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:_SPAWNallAirfield | Country  | "</span> .. _convCountry)

  self:spawnAirbasesInZone(_Zone.ZoneName, _convCoal, _convCountry )
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Deletes units within a specified circular area based on a marker event.
</span><span class="comment">--
</span><span class="comment">-- This function processes a marker event that indicates the deletion of units within a circular area. It identifies the center
</span><span class="comment">-- and radius of the circle from the marker's position and the additional parameters specified in the marker. The function then finds all units
</span><span class="comment">-- within this area belonging to the specified coalition and removes them. This offers a precise and dynamic way to modify the game environment
</span><span class="comment">-- based on player inputs, allowing for flexible manipulation of unit distributions within a defined radius.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param Packet Table containing details about the delete circle marker event, including the marker type, position, coalition, and radius.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after processing the delete circle marker event.
</span><a id="2076"></a><span class="comment">-- @usage zoneManager:_DELcircle(packetData) -- Processes the deletion of units within a circular area based on the marker event.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:_DELcircle(Packet)
  <span class="keyword">local</span> MarkerType = Packet.MarkerType
  <span class="keyword">local</span> MarkInfo = Packet.MarkInfo
  <span class="keyword">local</span> vec2 = mist.utils.makeVec2(MarkInfo.pos)
  <span class="keyword">local</span> _Zone = self:findZoneForVec2(vec2)
  <span class="keyword">local</span> _coalT = <span class="global">tonumber</span>(MarkerType[<span class="number">3</span>])
  <span class="keyword">local</span> _radT = <span class="global">tonumber</span>(MarkerType[<span class="number">4</span>])/<span class="number">2</span>

  <span class="keyword">local</span> t_ZOBJ = ZONE_RADIUS:New(<span class="string">"TEMPZ_"</span>, vec2, _radT, <span class="keyword">true</span>)
  <span class="keyword">local</span> temp_detectedUnits = self:FindUnitsInZone(t_ZOBJ)

  <span class="keyword">local</span> _GroupNames = self:buildGroupsFromUnits(temp_detectedUnits, _coalT)

  SPECTRE.UTILS.deleteGroupsByName(_GroupNames)
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Spawns units within a specified circular area based on a marker event.
</span><span class="comment">--
</span><span class="comment">-- This function processes a marker event that indicates the spawning of units within a circular area. It identifies the center,
</span><span class="comment">-- radius, coalition, and country for the spawn area from the marker's details. The function then spawns units accordingly within this
</span><span class="comment">-- circular zone, offering dynamic gameplay changes based on player inputs. This enables the creation of new units in specific areas,
</span><span class="comment">-- allowing for flexible and strategic gameplay alterations.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR self The instance of the zone manager.
</span><span class="comment">-- @param Packet Table containing details about the spawn circle marker event, including the marker type, position, coalition, radius, and country.
</span><span class="comment">-- @return #ZONEMGR self The zone manager instance after processing the spawn circle marker event.
</span><a id="2104"></a><span class="comment">-- @usage zoneManager:_SPAWNcircle(packetData) -- Processes the spawning of units within a circular area based on the marker event.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR:_SPAWNcircle(Packet)
  <span class="keyword">local</span> MarkerType = Packet.MarkerType
  <span class="keyword">local</span> MarkInfo = Packet.MarkInfo
  <span class="keyword">local</span> vec2 = mist.utils.makeVec2(MarkInfo.pos)
  <span class="keyword">local</span> _coalT = <span class="global">tonumber</span>(MarkerType[<span class="number">3</span>])
  <span class="keyword">local</span> _diaT = <span class="global">tonumber</span>(MarkerType[<span class="number">4</span>])
  <span class="keyword">local</span> _countryT = <span class="global">tonumber</span>(MarkerType[<span class="number">5</span>])
  <span class="keyword">local</span> _nameT = MarkerType[<span class="number">6</span>] <span class="keyword">or</span> <span class="string">"TESTZONE"</span> .. <span class="global">os</span>.time()
  <span class="keyword">local</span> _convCoal, _convCountry
  <span class="keyword">if</span> _countryT == <span class="number">1</span> <span class="keyword">then</span> _convCountry = SPECTRE.Countries.Red
  <span class="keyword">elseif</span> _countryT == <span class="number">2</span> <span class="keyword">then</span> _convCountry = SPECTRE.Countries.Blue
  <span class="keyword">end</span>
  <span class="keyword">if</span> _coalT == <span class="number">1</span> <span class="keyword">then</span> _convCoal = SPECTRE.Coalitions.Red
  <span class="keyword">elseif</span> _coalT == <span class="number">2</span> <span class="keyword">then</span> _convCoal = SPECTRE.Coalitions.Blue
  <span class="keyword">end</span>
  self:spawnFillAtVec2(vec2, _diaT, _convCoal, _convCountry, _nameT )
  <span class="keyword">return</span> self
<span class="keyword">end</span>


<span class="comment">--- x - Live Edit Cfg.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with Zone Manager operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span>
<span class="comment">--- Marker settings for the SPECTRE.ZONEMGR module.
</span><a id="2134"></a><span class="comment">-- @field #SPECTRE.ZONEMGR.MARKERS
</span>SPECTRE.ZONEMGR.MARKERS = {}

<span class="comment">---.
</span><a id="2138"></a><span class="comment">--@field #SPECTRE.ZONEMGR.MARKERS.Settings
</span>SPECTRE.ZONEMGR.MARKERS.Settings = {}
<span class="comment">--- Marker settings for deletion commands.
</span><a id="2141"></a><span class="comment">-- @field #SPECTRE.ZONEMGR.MARKERS.Settings.DEL
</span>SPECTRE.ZONEMGR.MARKERS.Settings.DEL = {}
SPECTRE.ZONEMGR.MARKERS.Settings.DEL.TagName = <span class="string">"/del"</span>
SPECTRE.ZONEMGR.MARKERS.Settings.DEL.KeyWords = {<span class="string">"zone"</span>, <span class="string">"airfield"</span>, <span class="string">"circle"</span>, <span class="string">"allairfield"</span>} <span class="comment">--must update event handler hard code if changed
</span>SPECTRE.ZONEMGR.MARKERS.Settings.DEL.CaseSensitive = <span class="keyword">false</span>
SPECTRE.ZONEMGR.MARKERS.Settings.DEL.MarkerEnum = <span class="string">"DEL"</span>

<span class="comment">--- Marker settings for spawn commands.
</span><a id="2149"></a><span class="comment">-- @field #SPECTRE.ZONEMGR.MARKERS.Settings.SPAWN
</span>SPECTRE.ZONEMGR.MARKERS.Settings.SPAWN = {}
SPECTRE.ZONEMGR.MARKERS.Settings.SPAWN.TagName = <span class="string">"/spawn"</span>
SPECTRE.ZONEMGR.MARKERS.Settings.SPAWN.KeyWords = {<span class="string">"zone"</span>, <span class="string">"airfield"</span>, <span class="string">"circle"</span>, <span class="string">"allairfield"</span>} <span class="comment">--must update event handler hard code if changed
</span>SPECTRE.ZONEMGR.MARKERS.Settings.SPAWN.CaseSensitive = <span class="keyword">false</span>
SPECTRE.ZONEMGR.MARKERS.Settings.SPAWN.MarkerEnum = <span class="string">"SPAWN"</span>

<span class="comment">--- Tracker for marker events.
</span><a id="2157"></a><span class="comment">-- @field #SPECTRE.ZONEMGR.MARKERS.TRACKERS
</span>SPECTRE.ZONEMGR.MARKERS.TRACKERS = {}

<a id="2160"></a><span class="comment">--- Settings for the SPECTRE.ZONEMGR module.
</span>SPECTRE.ZONEMGR.Settings = {}
<a id="2162"></a><span class="comment">--- Settings for edit functionalities.
</span>SPECTRE.ZONEMGR.Settings.Edit = {}
SPECTRE.ZONEMGR.Settings.Edit.DEL = <span class="keyword">true</span>
SPECTRE.ZONEMGR.Settings.Edit.SPAWN = <span class="keyword">true</span>

<span class="comment">--- Zone TypeDef.
</span><span class="comment">--
</span><span class="comment">-- Defines and manages properties and attributes associated with a Zone in the SPECTRE.ZONEMGR system.
</span><span class="comment">--
</span><span class="comment">-- This class is responsible for:
</span><span class="comment">--
</span><span class="comment">-- * Defining properties of a zone such as its shape, coalition, color, and more.
</span><span class="comment">-- * Handling interactions with airbases and neighboring zones.
</span><span class="comment">-- * Managing event handling and related attributes.
</span><span class="comment">--
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span><span class="comment">-- @field #ZONEMGR.Zone
</span>SPECTRE.ZONEMGR.Zone = {}
<a id="2180"></a><span class="comment">--- Flag to indicate if _AirfieldCaptureSpawns.
</span>SPECTRE.ZONEMGR.Zone._AirfieldCaptureSpawns = <span class="keyword">false</span>
<a id="2182"></a><span class="comment">--- Specifies the name of the zone.
</span>SPECTRE.ZONEMGR.Zone.ZoneName = <span class="string">""</span>
<span class="comment">--- Moose ZonePoly.
</span><a id="2185"></a><span class="comment">-- @field #ZONEMGR.Zone.ZONEPOLYOBJ
</span>SPECTRE.ZONEMGR.Zone.ZONEPOLYOBJ = {}
<span class="comment">--- Detected ground units in zone.
</span><a id="2188"></a><span class="comment">-- @field #ZONEMGR.Zone._detectedUnits
</span>SPECTRE.ZONEMGR.Zone._detectedUnits = {}
<span class="comment">--- Density-based clustering for ground units in zone.
</span><a id="2191"></a><span class="comment">-- @field #ZONEMGR.Zone._DBScan
</span>SPECTRE.ZONEMGR.Zone._DBScan = {}
<a id="2193"></a><span class="comment">---.
</span>SPECTRE.ZONEMGR.Zone._DBScanInProg = <span class="keyword">false</span>
<span class="comment">--- Processed DB clusters for ground units in zone.
</span><a id="2196"></a><span class="comment">-- @field #ZONEMGR.Zone.HotspotClusters
</span>SPECTRE.ZONEMGR.Zone.HotspotClusters = {}
<span class="comment">--- Marker storage for DB clusters.
</span><a id="2199"></a><span class="comment">-- @field #ZONEMGR.Zone.HotspotMarkers
</span>SPECTRE.ZONEMGR.Zone.HotspotMarkers = {}
<span class="comment">--- Intel Marker storage for DB clusters.
</span><a id="2202"></a><span class="comment">-- @field #ZONEMGR.Zone.IntelMarkers
</span>SPECTRE.ZONEMGR.Zone.IntelMarkers = {}
<a id="2204"></a><span class="comment">--- Added to calculated radius for hotspot, extends radius of drawn circle, meters.
</span>SPECTRE.ZONEMGR.Zone._hotspotDrawExtension = <span class="number">1000</span>
<span class="comment">--- Area of Zone.
</span><a id="2207"></a><span class="comment">-- Hotspots
</span>SPECTRE.ZONEMGR.Zone.Area = <span class="number">0</span>
<span class="comment">--- Epsilon value for DBSCAN clustering.
</span><a id="2210"></a><span class="comment">-- Hotspots
</span>SPECTRE.ZONEMGR.Zone.epsilon = <span class="number">0</span>
<span class="comment">--- Minimum sample size for DBSCAN clustering.
</span><a id="2213"></a><span class="comment">-- Hotspots
</span>SPECTRE.ZONEMGR.Zone.min_samples = <span class="number">0</span>
<span class="comment">--- Adjust this factor based on desired granularity for hotspots.
</span><a id="2216"></a><span class="comment">-- Hotspots
</span>SPECTRE.ZONEMGR.Zone.f = <span class="number">2</span> <span class="comment">-- 1.5
</span><span class="comment">--- Percentage of total units (adjust based on your use case).
</span><span class="comment">-- Hotspots
</span>SPECTRE.ZONEMGR.Zone.p = <span class="number">0.1</span> <span class="comment">-- 0.02
</span><span class="comment">--- Flag to indicate if the zone is currently being updated.
</span>SPECTRE.ZONEMGR.Zone.UpdatingZone = <span class="keyword">false</span>
<a id="2223"></a><span class="comment">--- Counter to track pending updates for the zone.
</span>SPECTRE.ZONEMGR.Zone.UpdateQueue = <span class="number">0</span>
<span class="comment">--- Reference to the ZoneManager managing this Zone.
</span><a id="2226"></a><span class="comment">-- @field #ZONEMGR.Zone.ZoneManager
</span>SPECTRE.ZONEMGR.Zone.ZoneManager = {}
<a id="2228"></a><span class="comment">--- UpdatingHotSpots Flag indicating if hotspots are currently being updated.
</span>SPECTRE.ZONEMGR.Zone.UpdatingHotspots = <span class="keyword">false</span>
<span class="comment">--- HotspotSched Scheduler for periodic unit hotspot drawing updates.
</span><a id="2231"></a><span class="comment">-- @field #ZONEMGR.Zone.HotspotSched
</span>SPECTRE.ZONEMGR.Zone.HotspotSched = {}
<a id="2233"></a><span class="comment">--- Boolean Toggle for drawing unit hotspots (default false).
</span>SPECTRE.ZONEMGR.Zone.Hotspots = <span class="keyword">false</span>
<a id="2235"></a><span class="comment">--- Boolean Toggle for giving hotspot Intel (default false).
</span>SPECTRE.ZONEMGR.Zone.Intel = <span class="keyword">false</span>
<a id="2237"></a><span class="comment">--- Specifies the shape of the zone (Default: 7=Freeform).
</span>SPECTRE.ZONEMGR.Zone.shapeId = <span class="number">7</span>
<a id="2239"></a><span class="comment">--- Specifies the coalition ownership of the zone (Default: All=-1).
</span>SPECTRE.ZONEMGR.Zone.Coalition = -<span class="number">1</span>
<span class="comment">--- RGB values defining the color of the zone (Default: Black).
</span><a id="2242"></a><span class="comment">-- @field #ZONEMGR.Zone.Color
</span>SPECTRE.ZONEMGR.Zone.Color = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>}
<span class="comment">--- Transparency of the zone (Default: 0.80).
</span><a id="2245"></a><span class="comment">-- @field #ZONEMGR.Zone.Alpha
</span>SPECTRE.ZONEMGR.Zone.Alpha = <span class="number">0.80</span>
<span class="comment">--- RGB values defining the fill color of the zone (Default: Black).
</span><a id="2248"></a><span class="comment">-- @field #ZONEMGR.Zone.FillColor
</span>SPECTRE.ZONEMGR.Zone.FillColor = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>}
<span class="comment">--- Lookup table for RGB values based on coalition ownership.
</span><a id="2251"></a><span class="comment">-- @field #ZONEMGR.Zone._Colors
</span>SPECTRE.ZONEMGR.Zone._Colors = {
  [<span class="number">0</span>] = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>},
  [<span class="number">1</span>] = {<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>},
  [<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>}
}
<span class="comment">--- Lookup table for RGB fill colors based on coalition ownership.
</span><a id="2258"></a><span class="comment">-- @field #ZONEMGR.Zone._FillColors
</span>SPECTRE.ZONEMGR.Zone._FillColors = {
  [<span class="number">0</span>] = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>},
  [<span class="number">1</span>] = {<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>},
  [<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>}
}
<span class="comment">--- Lookup table for RGB arrow colors with transparency based on coalition ownership.
</span><a id="2265"></a><span class="comment">-- @field #ZONEMGR.Zone._ArrowColors
</span>SPECTRE.ZONEMGR.Zone._ArrowColors = {
  [<span class="number">0</span>] = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.80</span>},
  [<span class="number">1</span>] = {<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.80</span>},
  [<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.80</span>}
}
<span class="comment">--- Specifies the transparency of the zone's fill color (Default: 0.20).
</span><a id="2272"></a><span class="comment">-- @field #ZONEMGR.Zone.FillAlpha
</span>SPECTRE.ZONEMGR.Zone.FillAlpha = <span class="number">0.20</span>
<span class="comment">--- Specifies the line type of the zone's border (Default: 4=Dot dash).
</span><a id="2275"></a><span class="comment">-- @field #ZONEMGR.Zone.LineType
</span>SPECTRE.ZONEMGR.Zone.LineType = <span class="number">4</span>
<span class="comment">--- Flag indicating if the zone marker is read-only (Default: true).
</span><a id="2278"></a><span class="comment">-- @field #ZONEMGR.Zone.ReadOnly
</span>SPECTRE.ZONEMGR.Zone.ReadOnly = <span class="keyword">true</span>
<span class="comment">--- List of airbases contained within the zone.
</span><a id="2281"></a><span class="comment">-- @field #ZONEMGR.Zone.Airbases
</span>SPECTRE.ZONEMGR.Zone.Airbases = {}
<span class="comment">--- Event handler for the zone.
</span><a id="2284"></a><span class="comment">-- @field #ZONEMGR.Zone.Handler_
</span>SPECTRE.ZONEMGR.Zone.Handler_ = EVENT:New()
<span class="comment">--- Event handler for base capture events within the zone.
</span><a id="2287"></a><span class="comment">-- @field #ZONEMGR.Zone.BaseCapturedHandler_
</span>SPECTRE.ZONEMGR.Zone.BaseCapturedHandler_ = {}
<span class="comment">--- List of Static Shore-Based (SSB) entities within the zone.
</span><a id="2290"></a><span class="comment">-- @field #ZONEMGR.Zone.SSBList
</span>SPECTRE.ZONEMGR.Zone.SSBList = {}
<span class="comment">--- Specifies the coalition that owns the zone (Default: 0=Neutral).
</span><a id="2293"></a><span class="comment">-- @field #ZONEMGR.Zone.OwnedByCoalition
</span>SPECTRE.ZONEMGR.Zone.OwnedByCoalition = <span class="number">0</span>
<span class="comment">--- Specifies the coalition that previously owned the zone (Default: 0=Neutral).
</span><a id="2296"></a><span class="comment">-- @field #ZONEMGR.Zone.OldOwnedByCoalition
</span>SPECTRE.ZONEMGR.Zone.OldOwnedByCoalition = <span class="number">0</span>
<span class="comment">--- ID representing the drawn zone marker.
</span><a id="2299"></a><span class="comment">-- @field #ZONEMGR.Zone.DrawnZoneMarkID
</span>SPECTRE.ZONEMGR.Zone.DrawnZoneMarkID = <span class="number">0</span>
<span class="comment">--- Value indicating the threshold for border offsets (Default: 800).
</span><a id="2302"></a><span class="comment">-- @field #ZONEMGR.Zone.BorderOffsetThreshold
</span>SPECTRE.ZONEMGR.Zone.BorderOffsetThreshold = <span class="number">800</span>
<span class="comment">--- Specifies the length of arrows for the zone (Default: 20000).
</span><a id="2305"></a><span class="comment">-- @field #ZONEMGR.Zone.ArrowLength
</span>SPECTRE.ZONEMGR.Zone.ArrowLength = <span class="number">20000</span>
<span class="comment">--- List of zones that share a border with the current zone.
</span><a id="2308"></a><span class="comment">-- @field #ZONEMGR.Zone.BorderingZones
</span>SPECTRE.ZONEMGR.Zone.BorderingZones = {}
<span class="comment">--- 2D vertices that define the boundaries of the zone.
</span><a id="2311"></a><span class="comment">-- @field #ZONEMGR.Zone.Vertices2D
</span>SPECTRE.ZONEMGR.Zone.Vertices2D = {
  [<span class="number">1</span>] = {x = <span class="number">0</span>, y = <span class="number">0</span>},
  [<span class="number">2</span>] = {x = <span class="number">0</span>, y = <span class="number">0</span>},
  [<span class="number">3</span>] = {x = <span class="number">0</span>, y = <span class="number">0</span>},
  [<span class="number">4</span>] = {x = <span class="number">0</span>, y = <span class="number">0</span>},
}
<span class="comment">--- 3D vertices that define the boundaries of the zone.
</span><a id="2319"></a><span class="comment">-- @field #ZONEMGR.Zone.Vertices3D
</span>SPECTRE.ZONEMGR.Zone.Vertices3D = {
  [<span class="number">1</span>] = {x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>},
  [<span class="number">2</span>] = {x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>},
  [<span class="number">3</span>] = {x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>},
  [<span class="number">4</span>] = {x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>},
}
<span class="comment">--- Lines that define the boundaries of the zone in vector format.
</span><a id="2327"></a><span class="comment">-- @field #ZONEMGR.Zone.LinesVec2
</span>SPECTRE.ZONEMGR.Zone.LinesVec2 = {}


<span class="comment">--- Create a new Zone object.
</span><span class="comment">--
</span><span class="comment">-- This function initializes a new Zone object within the SPECTRE.ZONEMGR system. It involves inheriting properties from the BASE class,
</span><span class="comment">-- setting essential attributes like ZoneManager and ZoneName, and performing geometric conversions. The function handles the transformation
</span><span class="comment">-- of the zone's 2D vertices into lines and 3D coordinates, essential for zone manipulation and management in a 3D environment.
</span><span class="comment">-- This method is vital for creating zones with accurately defined boundaries and properties.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone self The base instance from which the new Zone object is derived.
</span><span class="comment">-- @param ZoneName The name of the quadpoint zone to be transformed into a Zone object.
</span><span class="comment">-- @param #ZONEMGR ZoneManager The parent ZoneManager managing this Zone.
</span><span class="comment">-- @return #ZONEMGR.Zone self The newly created and initialized Zone object.
</span><a id="2342"></a><span class="comment">-- @usage local newZone = SPECTRE.ZONEMGR.Zone:New("SomeZoneName", someZoneManager) -- Creates a new Zone object with the specified name and ZoneManager.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:New(ZoneName, ZoneManager)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:New | ---------------------"</span>)
  <span class="comment">-- Inherit properties from the BASE class.
</span>  <span class="keyword">local</span> self = BASE:Inherit(self, SPECTRE:New())

  <span class="comment">-- Set the ZoneManager and ZoneName properties.
</span>  self.ZoneManager = ZoneManager
  self.ZoneName = ZoneName
  self.ZONEPOLYOBJ = ZONE_POLYGON:FindByName(ZoneName)
  <span class="comment">-- Get the 2D vertices of the zone, ensuring they form a convex shape.
</span>  self.Vertices2D = SPECTRE.POLY.ensureConvex(mist.DBs.zonesByName[ZoneName].verticies)
  self.Area = SPECTRE.POLY.polygonArea(self.Vertices2D)
  <span class="comment">-- Convert the 2D vertices to lines.
</span>  self.LinesVec2 = SPECTRE.POLY.convertZoneToLines(self.Vertices2D)

  <span class="comment">-- Convert the 2D vertices to 3D coordinates.
</span>  self.Vertices3D = {}
  <span class="keyword">for</span> index, vertex2D <span class="keyword">in</span> <span class="global">ipairs</span>(self.Vertices2D) <span class="keyword">do</span>
    self.Vertices3D[index] = mist.utils.makeVec3(vertex2D)
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- x - Zone Functions.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with Zone operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.ZONEMGR
</span>
<span class="comment">--- Handle base capture events.
</span><span class="comment">--
</span><span class="comment">-- This function is triggered when a base capture event occurs within the game. It plays a crucial role in updating the zone's state
</span><span class="comment">-- in response to these events. Specifically, it increments the UpdateQueue each time a base is captured. Additionally, if the captured
</span><span class="comment">-- airbase lies within the current zone and the SSB system is enabled in the ZoneManager, it updates
</span><span class="comment">-- the SSB airfield configuration accordingly. This ensures that changes in base control are accurately reflected within the zone's operational context.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone self The Zone instance handling the base capture event.
</span><span class="comment">-- @param eventData Table containing the base captured event data.
</span><a id="2384"></a><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after processing the base capture event.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:BaseCapturedHandler_(eventData)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:BaseCapturedHandler_ | ---------------------"</span>)
  <span class="comment">-- Increment the UpdateQueue.
</span>  self.UpdateQueue = self.UpdateQueue + <span class="number">1</span>

  <span class="comment">-- Check if the captured airbase is within this zone.
</span>  <span class="keyword">local</span> capturedAirbase = self.Airbases[eventData.PlaceName]

  <span class="keyword">if</span> capturedAirbase <span class="keyword">then</span>
    capturedAirbase.oldOwnedBy = capturedAirbase.ownedBy
    capturedAirbase.ownedBy = capturedAirbase.Object:GetCoalition()<span class="comment">--eventData.initiator.getCoalition(eventData.initiator)
</span>  <span class="keyword">end</span>

  <span class="keyword">if</span> capturedAirbase <span class="keyword">and</span> self.ZoneManager.SSB <span class="keyword">then</span>
    self:UpdateSSBAirfield(eventData.PlaceName)
  <span class="keyword">end</span>

  <span class="keyword">if</span> self._AirfieldCaptureSpawns == <span class="keyword">true</span> <span class="keyword">then</span>


    <span class="keyword">if</span> capturedAirbase <span class="keyword">and</span>
      <span class="comment">-- self._AirfieldCaptureSpawns == true and
</span>      capturedAirbase.oldOwnedBy ~= capturedAirbase.ownedBy
      <span class="keyword">and</span> capturedAirbase.oldOwnedBy ~= <span class="number">3</span>
    <span class="keyword">then</span>
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:BaseCapturedHandler_ | ---------------------"</span>)
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:BaseCapturedHandler_ | CaptureSPAWN: "</span> .. <span class="global">tostring</span>(self._AirfieldCaptureSpawns))
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:BaseCapturedHandler_ | Airfield    : "</span> .. <span class="global">tostring</span>(eventData.PlaceName))
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:BaseCapturedHandler_ | Initiator   : "</span> , eventData.initiator)
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:BaseCapturedHandler_ | eventData   : "</span> , eventData)
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:BaseCapturedHandler_ | IniCoal     : "</span> .. <span class="global">tostring</span>(eventData.initiator.getCoalition(eventData.initiator)))
      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:BaseCapturedHandler_ | IniCountry  : "</span> .. <span class="global">tostring</span>(eventData.initiator.getCountry(eventData.initiator)))
      self.ZoneManager:spawnAirbase(eventData.PlaceName, eventData.initiator.getCoalition(eventData.initiator), eventData.initiator.getCountry(eventData.initiator))
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> capturedAirbase <span class="keyword">and</span>
    self._AirfieldCaptureClean
  <span class="keyword">then</span>
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:_AirfieldCaptureClean | ---------------------"</span>)

    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:_AirfieldCaptureClean | removeJunk"</span>)
    <span class="keyword">local</span> _vec2Clean = self.Airbases[eventData.PlaceName].vec2
    <span class="keyword">local</span> _height = land.getHeight(_vec2Clean)
    <span class="keyword">local</span> volS = {
      id = world.VolumeType.SPHERE,
      params = {
        point = {x = _vec2Clean.x, y = _height, z = _vec2Clean.y},
        radius = <span class="number">5000</span>
      }
    }
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:_AirfieldCaptureClean | _vec2Clean"</span>, _vec2Clean)
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:_AirfieldCaptureClean | _height"</span>, _height)
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:_AirfieldCaptureClean | volS"</span>, volS)
    world.removeJunk(volS)

    <span class="comment">--    SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:_AirfieldCaptureClean | removeDeadUnits")
</span>    <span class="comment">--    local t_ZOBJ = ZONE_RADIUS:New(tostring(os.time()) .. "_TEMP",_vec2Clean,volS.params.radius)
</span>    <span class="comment">--    local foundUnits = self.ZoneManager:FindUnitsInZone(t_ZOBJ)
</span>    <span class="comment">--
</span>    <span class="comment">--    SPECTRE.IO.PersistenceToFile("TEST/MISTDBs/deadObjects.lua", mist.DBs.deadObjects)
</span>    <span class="comment">--
</span>    <span class="comment">--    --Clean dead units
</span>    <span class="comment">--
</span>    <span class="comment">--    for _indexID, _Object in pairs (mist.DBs.deadObjects) do
</span>    <span class="comment">--
</span>    <span class="comment">--      if _Object.objectData then
</span>    <span class="comment">--        local _vec2 = {x = _Object.objectData.pos.x, y = _Object.objectData.pos.z}
</span>    <span class="comment">--
</span>    <span class="comment">--        if SPECTRE.POLY.distance(_vec2Clean, _vec2) &lt; 5000 then
</span>    <span class="comment">--          SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:_AirfieldCaptureClean | Determined at airfield : " ..  _Object.objectData.unitName)
</span>    <span class="comment">--          trigger.action.explosion(_Object.objectData.pos , 1000 )
</span>    <span class="comment">--          --        local _unit = Unit.getByName(_Object.objectData.unitName)
</span>    <span class="comment">--          --        _unit:destroy()
</span>    <span class="comment">--        end
</span>    <span class="comment">--      end
</span>    <span class="comment">--
</span>    <span class="comment">--    end
</span>    <span class="comment">--
</span>    <span class="comment">--
</span>    <span class="comment">--    for _i = 0, 2, 1 do
</span>    <span class="comment">--      if foundUnits[_i] and #foundUnits[_i] &gt; 0 then
</span>    <span class="comment">--        SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:_AirfieldCaptureClean | removeDeadUnits - Found Units to remove for: " .. _i)
</span>    <span class="comment">--        for _index, unit in ipairs (foundUnits[_i]) do
</span>    <span class="comment">--          SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:_AirfieldCaptureClean | Unit Name: ".. tostring( unit.name))
</span>    <span class="comment">--          SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:_AirfieldCaptureClean | Unit Life: ".. tostring( unit.life))
</span>    <span class="comment">--          SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:_AirfieldCaptureClean | Unit: ", unit)
</span>    <span class="comment">--          if unit.life &lt;= 2 then
</span>    <span class="comment">--            unit.unitObj:destroy(false)
</span>    <span class="comment">--          end
</span>    <span class="comment">--        end
</span>    <span class="comment">--      end
</span>    <span class="comment">--    end
</span>  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Bind the event handler for base capture events.
</span><span class="comment">--
</span><span class="comment">-- This function is crucial for integrating the zone with the game's event system, specifically for base capture events.
</span><span class="comment">-- It binds the <code>BaseCapturedHandler_</code> function to the <code>BaseCaptured</code> event, allowing the zone to appropriately respond
</span><span class="comment">-- and handle situations when a base within its boundaries is captured. This binding ensures that the zone's state and behavior
</span><span class="comment">-- are dynamically updated in response to in-game actions and changes, particularly those involving base control.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after binding the event handler.
</span><a id="2491"></a><span class="comment">-- @usage local zoneWithHandler = someZone:InitHandlers() -- Binds the <code>BaseCapturedHandler_</code> to handle base capture events for the specified zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:InitHandlers()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:InitHandlers | ---------------------"</span>)
  <span class="comment">-- Bind the BaseCapturedHandler_ function to the BaseCaptured event.
</span>  self:HandleEvent(EVENTS.BaseCaptured, self.BaseCapturedHandler_)

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Determine the ownership of the zone.
</span><span class="comment">--
</span><span class="comment">-- This function assesses which coalition currently owns a particular zone based on the count of airbases under the control of each coalition within the zone.
</span><span class="comment">-- It iterates through the airbases, tallying those controlled by the red and blue coalitions. The ownership of the zone is then determined by the coalition
</span><span class="comment">-- with the majority of airbases. This function is essential for dynamically reflecting the shifting control of territories within the game environment.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after determining its ownership.
</span><a id="2508"></a><span class="comment">-- @usage local zoneWithOwnership = someZone:DetermineZoneOwnership() -- Determines the ownership of the specified zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:DetermineZoneOwnership()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DetermineZoneOwnership | ---------------------"</span>)
  <span class="comment">-- Initialize counters for each coalition.
</span>  <span class="keyword">local</span> blueCount = <span class="number">0</span>
  <span class="keyword">local</span> redCount = <span class="number">0</span>

  <span class="comment">-- Count the number of airbases owned by each coalition.
</span>  <span class="keyword">for</span> AirbaseName, _ <span class="keyword">in</span> <span class="global">pairs</span>(self.Airbases) <span class="keyword">do</span>
    <span class="keyword">local</span> airbase = AIRBASE:FindByName(AirbaseName)
    <span class="keyword">local</span> coalition = airbase:GetCoalition()

    <span class="keyword">if</span> coalition == <span class="number">1</span> <span class="keyword">then</span>
      redCount = redCount + <span class="number">1</span>
    <span class="keyword">elseif</span> coalition == <span class="number">2</span> <span class="keyword">then</span>
      blueCount = blueCount + <span class="number">1</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">local</span> _tx = self.OwnedByCoalition
  self.OldOwnedByCoalition = _tx

  <span class="comment">-- Determine the zone ownership based on the counts.
</span>  <span class="keyword">if</span> redCount &gt; blueCount <span class="keyword">then</span>
    self.OwnedByCoalition = <span class="number">1</span>  <span class="comment">-- Red coalition
</span>  <span class="keyword">elseif</span> blueCount &gt; redCount <span class="keyword">then</span>
    self.OwnedByCoalition = <span class="number">2</span>  <span class="comment">-- Blue coalition
</span>  <span class="keyword">else</span>
    self.OwnedByCoalition = <span class="number">0</span>  <span class="comment">-- Neutral or no clear ownership
</span>  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Update the coalition ownership of each bordering zone.
</span><span class="comment">--
</span><span class="comment">-- This function is vital for maintaining the dynamic and interconnected nature of territorial control within the game.
</span><span class="comment">-- It iterates over each zone that borders the current zone and updates its coalition ownership to reflect the coalition status
</span><span class="comment">-- of the main zone's bordering zones. This approach ensures that changes in territorial control ripple out appropriately to
</span><span class="comment">-- neighboring zones, reflecting a more realistic and strategic environment.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after updating the ownership of its bordering zones.
</span><a id="2551"></a><span class="comment">-- @usage local zoneWithUpdatedBorders = someZone:UpdateBorderOwnership() -- Updates the coalition ownership of each bordering zone for the specified zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:UpdateBorderOwnership()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:UpdateBorderOwnership | ---------------------"</span>)
  <span class="comment">-- Iterate over each bordering zone and update its coalition ownership.
</span>  <span class="keyword">for</span> BorderZoneName, BorderZone <span class="keyword">in</span> <span class="global">pairs</span>(self.BorderingZones) <span class="keyword">do</span>
    BorderZone.OwnedByCoalition = self.ZoneManager.Zones[BorderZoneName].OwnedByCoalition
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Determine the drawing color for the zone.
</span><span class="comment">--
</span><span class="comment">-- This function assigns a drawing color to the zone based on its current coalition ownership. It checks the zone's coalition status
</span><span class="comment">-- and selects a corresponding color from predefined color sets (_Colors and _FillColors). If no matching color is found in these sets,
</span><span class="comment">-- the zone retains its existing color. This functionality is crucial for visually representing the dynamic control of different coalitions
</span><span class="comment">-- over zones, enhancing the player's understanding and strategic decision-making based on territorial control.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after determining and setting the drawing color.
</span><a id="2571"></a><span class="comment">-- @usage local zoneWithDrawColor = someZone:DetermineDrawColor() -- Determines the drawing color for the specified zone based on its coalition ownership.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:DetermineDrawColor()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DetermineDrawColor | ---------------------"</span>)
  <span class="comment">-- Determine the drawing color based on the coalition ownership.
</span>  self.Color = self._Colors[self.OwnedByCoalition] <span class="keyword">or</span> self.Color
  self.FillColor = self._FillColors[self.OwnedByCoalition] <span class="keyword">or</span> self.FillColor

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Draw the zone on the map.
</span><span class="comment">--
</span><span class="comment">-- This function is responsible for visually representing the zone on the map using its defined color properties. It first checks if a marker
</span><span class="comment">-- for the zone already exists and removes it to avoid duplication. The function then draws the new zone using its current color and fill color,
</span><span class="comment">-- along with other defined properties. This visual representation is key for players to easily identify and differentiate zones based on their
</span><span class="comment">-- current status and coalition control, enhancing the strategic aspect of the game.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after being drawn on the map.
</span><a id="2590"></a><span class="comment">-- @usage local drawnZone = someZone:DrawZone() -- Draws the specified zone on the map using its color properties.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:DrawZone()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DrawZone | ---------------------"</span>)
  <span class="comment">-- If a zone marker already exists, remove it.
</span>  <span class="keyword">if</span> self.DrawnZoneMarkID ~= <span class="number">0</span> <span class="keyword">then</span>
    trigger.action.removeMark(self.DrawnZoneMarkID)
  <span class="keyword">end</span>

  <span class="comment">-- Assign a new mark ID and increment the global marker counter.
</span>  self.DrawnZoneMarkID = self.ZoneManager.codeMarker_
  self.ZoneManager.codeMarker_ = self.ZoneManager.codeMarker_ + <span class="number">1</span>

  <span class="comment">-- Set default alpha values for the zone's color and fill color, if not already defined.
</span>  <span class="keyword">local</span> color = self.Color
  color[<span class="number">4</span>] = color[<span class="number">4</span>] <span class="keyword">or</span> self.Alpha

  <span class="keyword">local</span> fillColor = self.FillColor
  fillColor[<span class="number">4</span>] = fillColor[<span class="number">4</span>] <span class="keyword">or</span> self.FillAlpha

  <span class="comment">-- Draw the zone using the defined properties.
</span>  trigger.action.markupToAll(self.shapeId, -<span class="number">1</span>, self.DrawnZoneMarkID, self.Vertices3D[<span class="number">4</span>], self.Vertices3D[<span class="number">3</span>], self.Vertices3D[<span class="number">2</span>], self.Vertices3D[<span class="number">1</span>], color, fillColor, self.LineType, self.ReadOnly)

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Draw arrows from the zone to its bordering zones.
</span><span class="comment">--
</span><span class="comment">-- This function graphically represents the territorial dynamics between the current zone and its bordering zones.
</span><span class="comment">-- It draws arrows pointing from the current zone to adjacent zones whenever there is a difference in coalition ownership.
</span><span class="comment">-- This visual indication helps to illustrate the direction of territorial influence or contention, enhancing the strategic
</span><span class="comment">-- comprehension of the game's geopolitical landscape for players. The function ensures that previous markers are cleared
</span><span class="comment">-- before drawing new arrows to reflect the current state accurately.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after drawing arrows to its bordering zones.
</span><a id="2625"></a><span class="comment">-- @usage local zoneWithArrows = someZone:DrawArrows() -- Draws arrows from the specified zone to its bordering zones based on coalition differences.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:DrawArrows()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DrawArrows | ---------------------"</span>)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DrawArrows | Zone: "</span> .. self.ZoneName)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DrawArrows | COAL: "</span> .. self.OwnedByCoalition)
  <span class="comment">-- Retrieve the current coalition owning the zone.
</span>  <span class="keyword">local</span> currentCoalition = self.OwnedByCoalition

  <span class="comment">-- Clear existing markers for both coalitions
</span>  <span class="keyword">for</span> BorderZoneName, BorderObject <span class="keyword">in</span> <span class="global">pairs</span>(self.BorderingZones) <span class="keyword">do</span>
    <span class="keyword">for</span> _, borderDetail <span class="keyword">in</span> <span class="global">ipairs</span>(BorderObject) <span class="keyword">do</span>
      <span class="comment">-- Check and remove markers for coalition "1"
</span>      <span class="keyword">if</span> borderDetail.MarkID[<span class="number">1</span>] ~= <span class="number">0</span> <span class="keyword">then</span>
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DrawArrows | removeMark | "</span> .. borderDetail.MarkID[<span class="number">1</span>])
        trigger.action.removeMark(borderDetail.MarkID[<span class="number">1</span>])
        borderDetail.MarkID[<span class="number">1</span>] = <span class="number">0</span>
      <span class="keyword">end</span>
      <span class="comment">-- Check and remove markers for coalition "2"
</span>      <span class="keyword">if</span> borderDetail.MarkID[<span class="number">2</span>] ~= <span class="number">0</span> <span class="keyword">then</span>
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DrawArrows | removeMark | "</span> .. borderDetail.MarkID[<span class="number">2</span>])
        trigger.action.removeMark(borderDetail.MarkID[<span class="number">2</span>])
        borderDetail.MarkID[<span class="number">2</span>] = <span class="number">0</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="comment">-- Draw new arrows based on current ownership
</span>  <span class="keyword">for</span> BorderZoneName, BorderObject <span class="keyword">in</span> <span class="global">pairs</span>(self.BorderingZones) <span class="keyword">do</span>
    <span class="keyword">local</span> borderCoalition = BorderObject.OwnedByCoalition
    <span class="keyword">if</span> borderCoalition ~= currentCoalition <span class="keyword">then</span>
      <span class="keyword">for</span> _, borderDetail <span class="keyword">in</span> <span class="global">ipairs</span>(BorderObject) <span class="keyword">do</span>
        <span class="comment">-- Assign a new mark ID and increment the global counter.
</span>        borderDetail.MarkID[currentCoalition] = self.ZoneManager.codeMarker_
        self.ZoneManager.codeMarker_ = self.ZoneManager.codeMarker_ + <span class="number">1</span>

        <span class="comment">-- Define the start and end points of the arrow.
</span>        <span class="keyword">local</span> ArrowTip = mist.utils.makeVec3(borderDetail.NeighborLinePerpendicularPoint)
        <span class="keyword">local</span> ArrowEnd = mist.utils.makeVec3(borderDetail.ZoneLinePerpendicularPoint)

        <span class="comment">-- Retrieve the appropriate arrow color.
</span>        <span class="keyword">local</span> arrowColors_ = self._ArrowColors[currentCoalition]

        <span class="comment">-- Draw the arrow using the defined properties.
</span>        trigger.action.markupToAll(<span class="number">4</span>, currentCoalition, borderDetail.MarkID[currentCoalition], ArrowTip, ArrowEnd, arrowColors_, arrowColors_, <span class="number">1</span>, <span class="keyword">true</span>)
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Update SSB flags at an Airfield.
</span><span class="comment">--
</span><span class="comment">-- This function plays a critical role in updating the user flags for each airfield within a zone, based on its coalition ownership and
</span><span class="comment">-- its relationship to the SSB list. The function ensures that the correct flags are set for each airfield,
</span><span class="comment">-- accurately indicating its current operational state. This is essential for managing airfield control and player spawns.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone self The Zone instance within which the airfield flags are to be updated.
</span><span class="comment">-- @param Airfield The name of the airfield, part of the self[Airbases] table.
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after updating the SSB flags at the specified airfield.
</span><a id="2685"></a><span class="comment">-- @usage local updatedZone = someZone:UpdateSSBAirfield("SomeAirfield") -- Updates the SSB flags for the specified airfield in the zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:UpdateSSBAirfield(Airfield)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:UpdateSSBAirfield | ---------------------"</span>)
  <span class="comment">-- Get the object associated with the specified airbase.
</span>  <span class="keyword">local</span> ABobject = self.Airbases[Airfield]
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:UpdateSSBAirfield | ABobject"</span> , ABobject)
  <span class="comment">-- Retrieve flags associated with the zone manager.
</span>  <span class="keyword">local</span> flagOn = self.ZoneManager.SSBon
  <span class="keyword">local</span> flagOff = self.ZoneManager.SSBoff
  <span class="keyword">local</span> currentFlag


  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:UpdateSSBAirfield | flagOn  :"</span> .. flagOn)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:UpdateSSBAirfield | flagOff :"</span> .. flagOff)

  <span class="comment">-- Iterate over each airbase and its group array in the SSBList.
</span>  <span class="keyword">for</span> airbaseName, groupArray <span class="keyword">in</span> <span class="global">pairs</span>(self.SSBList) <span class="keyword">do</span>
    <span class="comment">-- Determine the coalition owning the airbase.
</span>    <span class="keyword">local</span> airbaseOwner = AIRBASE:FindByName(airbaseName):GetCoalition()

    <span class="keyword">if</span> airbaseOwner == <span class="number">1</span> <span class="keyword">then</span>
      airbaseOwner = <span class="string">"red"</span>
    <span class="keyword">elseif</span> airbaseOwner == <span class="number">2</span> <span class="keyword">then</span>
      airbaseOwner = <span class="string">"blue"</span>
    <span class="keyword">else</span>
      airbaseOwner = <span class="string">"neutral"</span>
    <span class="keyword">end</span>

    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:UpdateSSBAirfield | airbaseName :"</span> .. airbaseName)
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:UpdateSSBAirfield | airbaseOwner :"</span> .. airbaseOwner)

    <span class="comment">-- Set user flags based on coalition ownership.
</span>    <span class="keyword">for</span> _, groupDetails <span class="keyword">in</span> <span class="global">ipairs</span>(groupArray) <span class="keyword">do</span>
      <span class="keyword">if</span> airbaseOwner == groupDetails.coal <span class="keyword">then</span>
        currentFlag = flagOn
      <span class="keyword">else</span>
        currentFlag = flagOff
      <span class="keyword">end</span>
      trigger.action.setUserFlag(groupDetails.name, currentFlag)
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Create a table associating airbases with their client units for Simple Slot Block (SSB) handling.
</span><span class="comment">--
</span><span class="comment">--  Detects all client spawn slots at airfields (airfield spawn) and all client slots within 5 Km of the airfield's vec2 (ground spawns)
</span><span class="comment">--
</span><span class="comment">--  Adds these units to the SSB manager for automatic toggling when the airfield changes coalition.
</span><span class="comment">--
</span><span class="comment">-- This function constructs a mapping between airbases and their client units for managing Simple Slot Blocks (SSB) in the game.
</span><span class="comment">-- SSB is responsible for enabling or disabling player spawn slots. The function identifies client units at each airbase and
</span><span class="comment">-- creates associations necessary for the strategic control of player spawn points. This mapping is essential for effectively
</span><span class="comment">-- managing player access to specific airbases, reflecting real-time conditions and strategic decisions within the zone.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after creating the SSB airbase-client unit mapping.
</span><a id="2743"></a><span class="comment">-- @usage local zoneWithSSBGroups = someZone:DetermineAirbaseSSBGroups() -- Creates a mapping for airbases and client units for SSB handling.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:DetermineAirbaseSSBGroups()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DetermineAirbaseSSBGroups | ---------------------"</span>)

  <span class="comment">-- DETECT AND ADD SPAWNS AT ALL AIRFIELDS TO THE AIRFIELD SSB MANAGER
</span>  <span class="comment">-- Create a table to store airbases and their associated client units.
</span>  <span class="keyword">local</span> AirbasesClients = {}
  <span class="keyword">local</span> _SSBAirfieldArrays = {}

  <span class="comment">-- Iterate over each airbase.
</span>  <span class="keyword">for</span> airbase, ABobject <span class="keyword">in</span> <span class="global">pairs</span>(self.Airbases) <span class="keyword">do</span>
    <span class="keyword">local</span> airbaseUnitNames = {}
    <span class="comment">-- Gather client names from the airbase's parking spots.
</span>    <span class="keyword">for</span> _, parkingSpot <span class="keyword">in</span> <span class="global">ipairs</span>(ABobject.Object.parking) <span class="keyword">do</span>
      <span class="keyword">if</span> parkingSpot.ClientSpot <span class="keyword">then</span> SPECTRE.UTILS.safeInsert(airbaseUnitNames, parkingSpot.ClientName) <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="comment">-- If the airbase has client names, store them in the AirbasesClients table.
</span>    <span class="keyword">if</span> #airbaseUnitNames &gt; <span class="number">0</span> <span class="keyword">then</span> AirbasesClients[airbase] = airbaseUnitNames <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="comment">-- Iterate over all groups.
</span>  <span class="keyword">local</span> allGroups = mist.DBs.groupsByName
  <span class="keyword">for</span> groupName, groupData <span class="keyword">in</span> <span class="global">pairs</span>(allGroups) <span class="keyword">do</span>
    <span class="keyword">if</span> groupData <span class="keyword">and</span> groupData.units <span class="keyword">then</span>
      <span class="comment">-- Iterate over each unit in the group.
</span>      <span class="keyword">for</span> _, unitData <span class="keyword">in</span> <span class="global">ipairs</span>(groupData.units) <span class="keyword">do</span>
        <span class="keyword">if</span> (unitData.skill == <span class="string">"Client"</span> <span class="keyword">or</span> unitData.skill == <span class="string">"Player"</span>) <span class="keyword">then</span>
          <span class="comment">-- Check if the unit's name matches any of the client names.
</span>          <span class="keyword">for</span> airbase, unitNames <span class="keyword">in</span> <span class="global">pairs</span>(AirbasesClients) <span class="keyword">do</span>
            <span class="keyword">local</span> _airbaseVec2 = self.Airbases[airbase].vec2
            <span class="keyword">for</span> _, clientName <span class="keyword">in</span> <span class="global">pairs</span>(unitNames) <span class="keyword">do</span>
              <span class="keyword">local</span> _flagAddUnit = <span class="keyword">false</span>
              <span class="keyword">if</span> clientName == unitData.unitName <span class="keyword">then</span>
                _flagAddUnit = <span class="keyword">true</span>
              <span class="keyword">end</span>
              <span class="keyword">if</span> _flagAddUnit == <span class="keyword">true</span> <span class="keyword">then</span>
                <span class="comment">-- If a match is found, store the group data.
</span>                <span class="keyword">if</span> <span class="keyword">not</span> SPECTRE.UTILS.table_contains(_SSBAirfieldArrays, airbase) <span class="keyword">then</span> _SSBAirfieldArrays[airbase] = {} <span class="keyword">end</span>
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE:DetermineAirbaseSSBGroups | ADDING: "</span>..   unitData.unitName .. <span class="string">" | TO: "</span> .. <span class="global">tostring</span>(airbase) .. <span class="string">" | COAL: "</span> .. groupData.coalition.. <span class="string">" | GROUP: "</span> .. groupData.groupName)
                SPECTRE.UTILS.safeInsert(_SSBAirfieldArrays[airbase], {
                  name = groupData.groupName,
                  coal = groupData.coalition
                })
                <span class="keyword">break</span>
              <span class="keyword">end</span>
            <span class="keyword">end</span>
          <span class="keyword">end</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> SPECTRE.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    <span class="keyword">local</span> force = <span class="keyword">true</span>
    <span class="keyword">local</span> _Randname = <span class="string">"SSBList_Airfield"</span>
    <span class="keyword">local</span> _filename = SPECTRE._persistenceLocations.ZONEMGR.path .. <span class="string">"DEBUG/"</span>  .. self.ZoneName .. <span class="string">"/"</span> .. _Randname .. <span class="string">".lua"</span>
    SPECTRE.IO.PersistenceToFile(_filename, _SSBAirfieldArrays, force)
  <span class="keyword">end</span>
  <span class="comment">-- DETECT AND ADD GROUND SPAWNS WITHIN 5000 METERS OF AIRFIELDS TO THE AIRFIELD SSB MANAGER
</span>  <span class="keyword">for</span> groupName, groupData <span class="keyword">in</span> <span class="global">pairs</span>(allGroups) <span class="keyword">do</span>
    <span class="keyword">if</span> groupData <span class="keyword">and</span> groupData.units <span class="keyword">then</span>
      <span class="comment">-- Iterate over each unit in the group.
</span>      <span class="keyword">for</span> _, unitData <span class="keyword">in</span> <span class="global">ipairs</span>(groupData.units) <span class="keyword">do</span>
        <span class="comment">-- Check if the unit's name matches any of the client names.
</span>        <span class="keyword">if</span> (unitData.skill == <span class="string">"Client"</span> <span class="keyword">or</span> unitData.skill == <span class="string">"Player"</span>) <span class="keyword">then</span>
          <span class="keyword">for</span> airbase, ABobject <span class="keyword">in</span> <span class="global">pairs</span>(self.Airbases) <span class="keyword">do</span>
            <span class="keyword">local</span> _airbaseVec2 = ABobject.vec2
            <span class="keyword">local</span> _flagAddUnit = <span class="keyword">false</span>
            <span class="keyword">if</span> SPECTRE.POLY.distance({x = unitData.x, y = unitData.y}, _airbaseVec2) &lt;= <span class="number">5000</span> <span class="keyword">then</span>
              <span class="keyword">local</span> _flagfound = <span class="keyword">false</span>
              <span class="keyword">if</span> SPECTRE.UTILS.table_contains(_SSBAirfieldArrays, airbase) <span class="keyword">then</span>
                <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="global">ipairs</span>(_SSBAirfieldArrays[airbase]) <span class="keyword">do</span>
                  <span class="keyword">if</span> v.name == groupData.groupName <span class="keyword">then</span>
                    _flagfound = <span class="keyword">true</span>
                    <span class="keyword">break</span>
                  <span class="keyword">end</span>
                <span class="keyword">end</span>
              <span class="keyword">end</span>
              <span class="keyword">if</span> <span class="keyword">not</span> _flagfound <span class="keyword">then</span> _flagAddUnit = <span class="keyword">true</span> <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> _flagAddUnit == <span class="keyword">true</span> <span class="keyword">then</span>
              <span class="keyword">if</span> <span class="keyword">not</span> SPECTRE.UTILS.table_contains(_SSBAirfieldArrays, airbase) <span class="keyword">then</span> _SSBAirfieldArrays[airbase] = {} <span class="keyword">end</span>
              SPECTRE.UTILS.safeInsert(_SSBAirfieldArrays[airbase], {
                name = groupData.groupName,
                coal = groupData.coalition
              })
              <span class="keyword">break</span>
            <span class="keyword">end</span>
          <span class="keyword">end</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="comment">-- Update the instance's SSBList with the gathered data.
</span>  self.SSBList = _SSBAirfieldArrays

  <span class="keyword">if</span> SPECTRE.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    <span class="keyword">local</span> force = <span class="keyword">true</span>
    <span class="keyword">local</span> _Randname =  <span class="string">"SSBList_Ground"</span>
    <span class="keyword">local</span> _filename = SPECTRE._persistenceLocations.ZONEMGR.path .. <span class="string">"DEBUG/"</span> .. self.ZoneName .. <span class="string">"/"</span> .. _Randname .. <span class="string">".lua"</span>
    SPECTRE.IO.PersistenceToFile(_filename, _SSBAirfieldArrays, force)
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>


<span class="comment">--- DO NOT USE THIS YET.
</span><span class="comment">--
</span><span class="comment">-- The Airfield and FARP methods are efficient for their specific purpose. This does them both but faster.
</span><span class="comment">--
</span><span class="comment">-- Create a table associating airbases with their client units for Simple Slot Block (SSB) handling.
</span><span class="comment">--
</span><span class="comment">--  Detects all client spawn slots at airfields (airfield spawn) and all client slots within 5 Km of the airfield's vec2 (ground spawns)
</span><span class="comment">--
</span><span class="comment">--  Adds these units to the SSB manager for automatic toggling when the airfield changes coalition.
</span><span class="comment">--
</span><span class="comment">-- This function constructs a mapping between airbases and their client units for managing Simple Slot Blocks (SSB) in the game.
</span><span class="comment">-- SSB is responsible for enabling or disabling player spawn slots. The function identifies client units at each airbase and
</span><span class="comment">-- creates associations necessary for the strategic control of player spawn points. This mapping is essential for effectively
</span><span class="comment">-- managing player access to specific airbases, reflecting real-time conditions and strategic decisions within the zone.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after creating the SSB airbase-client unit mapping.
</span><a id="2866"></a><span class="comment">-- @usage local zoneWithSSBGroups = someZone:DetermineAirbaseSSBGroups() -- Creates a mapping for airbases and client units for SSB handling.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:DetermineAirbaseSSBGroups_All()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DetermineAirbaseSSBGroups_All | ---------------------"</span>)
  <span class="keyword">local</span> _SSBAirfieldArrays = {}
  <span class="keyword">local</span> airbaseNames = {}
  <span class="keyword">for</span> airbase, ABobject <span class="keyword">in</span> <span class="global">pairs</span>(self.Airbases) <span class="keyword">do</span>
    airbaseNames[#airbaseNames + <span class="number">1</span>] = airbase
  <span class="keyword">end</span>
  <span class="keyword">local</span> allGroups = mist.DBs.groupsByName
  <span class="comment">-- DETECT AND ADD GROUND SPAWNS IN ZONE TO THE FARP SSB MANAGER. OMITS ALREADY ASSIGNED AIRFIELD SPAWNS
</span>  <span class="keyword">for</span> groupName, groupData <span class="keyword">in</span> <span class="global">pairs</span>(allGroups) <span class="keyword">do</span>
    <span class="keyword">if</span> groupData <span class="keyword">and</span> groupData.units <span class="keyword">then</span>
      <span class="comment">-- Iterate over each unit in the group.
</span>      <span class="keyword">for</span> _, unitData <span class="keyword">in</span> <span class="global">ipairs</span>(groupData.units) <span class="keyword">do</span>
        <span class="keyword">if</span> (unitData.skill == <span class="string">"Client"</span> <span class="keyword">or</span> unitData.skill == <span class="string">"Player"</span>) <span class="keyword">then</span>
          <span class="keyword">local</span> _flagAddUnit = <span class="keyword">true</span>
          <span class="keyword">local</span> _vec2 = {x = unitData.x, y = unitData.y}
          <span class="keyword">local</span> _nearestAB = SPECTRE.WORLD.FindNearestAirbaseToPointVec2(airbaseNames, _vec2)
          <span class="keyword">local</span> _nearestABname = _nearestAB[<span class="number">1</span>]
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DetermineAirbaseSSBGroups_All | groupData.groupName : "</span> .. groupData.groupName)
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DetermineAirbaseSSBGroups_All | _nearestABname      : "</span> ..  _nearestABname)
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DetermineAirbaseSSBGroups_All | _SSBAirfieldArrays  : "</span> , _SSBAirfieldArrays)
          <span class="keyword">if</span> SPECTRE.UTILS.table_contains(_SSBAirfieldArrays, _nearestABname) <span class="keyword">then</span>
            <span class="keyword">for</span> _, _group <span class="keyword">in</span> <span class="global">ipairs</span>(_SSBAirfieldArrays[_nearestABname]) <span class="keyword">do</span>
              <span class="keyword">if</span> _group.name == groupData.groupName <span class="keyword">then</span>
                SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DetermineAirbaseSSBGroups_All | Already Exists, Do not add"</span>)
                _flagAddUnit = <span class="keyword">false</span>
                <span class="keyword">break</span>
              <span class="keyword">end</span>
            <span class="keyword">end</span>
          <span class="keyword">end</span>
          <span class="keyword">if</span> _flagAddUnit == <span class="keyword">true</span> <span class="keyword">then</span>
            <span class="keyword">if</span> <span class="keyword">not</span> SPECTRE.UTILS.table_contains(_SSBAirfieldArrays, _nearestABname) <span class="keyword">then</span> _SSBAirfieldArrays[_nearestABname] = {} <span class="keyword">end</span>
            SPECTRE.UTILS.safeInsert(_SSBAirfieldArrays[_nearestABname], {
              name = groupData.groupName,
              coal = groupData.coalition,
            })
            <span class="keyword">break</span>
          <span class="keyword">end</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="comment">-- Update the instance's SSBList with the gathered data.
</span>  self.SSBList = _SSBAirfieldArrays
  <span class="keyword">if</span> SPECTRE.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
    <span class="keyword">local</span> force = <span class="keyword">true</span>
    <span class="keyword">local</span> _Randname =  <span class="string">"SSBList_All"</span>
    <span class="keyword">local</span> _filename = SPECTRE._persistenceLocations.ZONEMGR.path .. <span class="string">"DEBUG/"</span>  .. self.ZoneName .. <span class="string">"/"</span> .. _Randname .. <span class="string">".lua"</span>
    SPECTRE.IO.PersistenceToFile(_filename, _SSBAirfieldArrays, force)
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- FARP usage mainly, or "ground" spawns.
</span><span class="comment">--
</span><span class="comment">--  Detects all ground spawns in a Zone not assigned to an airfield and adds it to the Airfield SSB Manager for the closest airfield.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after creating the SSB airbase-client unit mapping.
</span><a id="2926"></a><span class="comment">-- @usage local zoneWithSSBGroups = someZone:DetermineAirbaseSSBGroups() -- Creates a mapping for airbases and client units for SSB handling.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups()
  <span class="comment">--  SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups | ---------------------")
</span>  <span class="comment">--  local airbaseNames = {}
</span>  <span class="comment">--  for airbase, ABobject in pairs(self.Airbases) do
</span>  <span class="comment">--    airbaseNames[#airbaseNames + 1] = airbase
</span>  <span class="comment">--  end
</span>  <span class="comment">--  local allGroups = mist.DBs.groupsByName
</span>  <span class="comment">--
</span>  <span class="comment">--  for groupName, groupData in pairs(allGroups) do
</span>  <span class="comment">--    if groupData and groupData.units then
</span>  <span class="comment">--      local _flagAddUnit = false
</span>  <span class="comment">--      for _, unitData in ipairs(groupData.units) do
</span>  <span class="comment">--
</span>  <span class="comment">--        if (unitData.skill == "Client" or unitData.skill == "Player") then
</span>  <span class="comment">--          local _vec2 = {x = unitData.x, y = unitData.y}
</span>  <span class="comment">--          if self.zoneManager:findZoneForVec2(coordinates)
</span>  <span class="comment">--          local _nearestAB = SPECTRE.WORLD.FindNearestAirbaseToPointVec2(airbaseNames, _vec2)
</span>  <span class="comment">--          local _nearestABname = _nearestAB[1]
</span>  <span class="comment">--
</span>  <span class="comment">--          if self.Airbases[_nearestABname] then
</span>  <span class="comment">--
</span>  <span class="comment">--
</span>  <span class="comment">--            SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups | _nearestAB: " .. _nearestABname)
</span>  <span class="comment">--
</span>  <span class="comment">--            -- Refactored Duplicate Check
</span>  <span class="comment">--            if self.SSBList[_nearestABname] ~= nil then
</span>  <span class="comment">--              SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups | self.SSBList[_nearestABname] EXIST ")
</span>  <span class="comment">--              for _, existingGroup in ipairs(self.SSBList[_nearestABname]) do
</span>  <span class="comment">--                _flagAddUnit = true
</span>  <span class="comment">--                SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups | existingGroup.name :" .. existingGroup.name)
</span>  <span class="comment">--                SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups | groupData.groupName :" .. groupData.groupName)
</span>  <span class="comment">--                if existingGroup.name == groupData.groupName then
</span>  <span class="comment">--                  SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups | _flagAddUnit = false")
</span>  <span class="comment">--                  _flagAddUnit = false
</span>  <span class="comment">--                  break
</span>  <span class="comment">--                end
</span>  <span class="comment">--              end
</span>  <span class="comment">--            else
</span>  <span class="comment">--              --self.SSBList[_nearestABname] = {}
</span>  <span class="comment">--              self.SSBList[_nearestABname] = {}
</span>  <span class="comment">--              _flagAddUnit = true
</span>  <span class="comment">--              SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups | _flagAddUnit = false")
</span>  <span class="comment">--            end
</span>  <span class="comment">--
</span>  <span class="comment">--            if _flagAddUnit then
</span>  <span class="comment">--              SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups | _flagAddUnit = true")
</span>  <span class="comment">--              SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups | groupData.groupName :" .. groupData.groupName)
</span>  <span class="comment">--              --self.SSBList[_nearestABname][#self.SSBList[_nearestABname] + 1] = {
</span>  <span class="comment">--              local data_ = {
</span>  <span class="comment">--                name = groupData.groupName,
</span>  <span class="comment">--                coal = groupData.coalition,
</span>  <span class="comment">--              }
</span>  <span class="comment">--              table.insert(self.SSBList[_nearestABname],data_)
</span>  <span class="comment">--            end
</span>  <span class="comment">--
</span>  <span class="comment">--
</span>  <span class="comment">--          end
</span>  <span class="comment">--
</span>  <span class="comment">--
</span>  <span class="comment">--        end
</span>  <span class="comment">--
</span>  <span class="comment">--      end
</span>  <span class="comment">--
</span>  <span class="comment">--    end
</span>  <span class="comment">--  end
</span>  <span class="comment">--
</span>  <span class="comment">--  if SPECTRE.DebugEnabled == 1 then
</span>  <span class="comment">--    local force = true
</span>  <span class="comment">--    local _Randname =  "SSBList_FARP"
</span>  <span class="comment">--    local _filename = SPECTRE._persistenceLocations.ZONEMGR.path .. "DEBUG/"  .. self.ZoneName .. "/" .. _Randname .. ".lua"
</span>  <span class="comment">--    SPECTRE.IO.PersistenceToFile(_filename, self.SSBList, force)
</span>  <span class="comment">--  end
</span>  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--function SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups()
</span><span class="comment">--  SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:DetermineFARPSSBGroups | ---------------------")
</span><span class="comment">--  local airbaseNames = {}
</span><span class="comment">--  for airbase, ABobject in pairs(self.Airbases) do
</span><span class="comment">--    airbaseNames[#airbaseNames + 1] = airbase
</span><span class="comment">--  end
</span><span class="comment">--  local allGroups = mist.DBs.groupsByName
</span><span class="comment">--  -- DETECT AND ADD GROUND SPAWNS IN ZONE TO THE FARP SSB MANAGER. OMITS ALREADY ASSIGNED AIRFIELD SPAWNS
</span><span class="comment">--  for groupName, groupData in pairs(allGroups) do
</span><span class="comment">--    if groupData and groupData.units then
</span><span class="comment">--      -- Iterate over each unit in the group.
</span><span class="comment">--      for _, unitData in ipairs(groupData.units) do
</span><span class="comment">--        if (unitData.skill == "Client" or unitData.skill == "Player") then
</span><span class="comment">--          local _flagAddUnit = true
</span><span class="comment">--          local _vec2 = {x = unitData.x, y = unitData.y}
</span><span class="comment">--          local _nearestAB = SPECTRE.WORLD.FindNearestAirbaseToPointVec2(airbaseNames, _vec2)
</span><span class="comment">--          local _nearestABname = _nearestAB[1]
</span><span class="comment">--          if SPECTRE.UTILS.table_contains(self.SSBList, _nearestABname) then
</span><span class="comment">--            for _, _group in ipairs(self.SSBList[_nearestABname]) do
</span><span class="comment">--              if _group.name == groupData.groupName then
</span><span class="comment">--                _flagAddUnit = false
</span><span class="comment">--                break
</span><span class="comment">--              end
</span><span class="comment">--            end
</span><span class="comment">--          end
</span><span class="comment">--          if _flagAddUnit == true then
</span><span class="comment">--            if not SPECTRE.UTILS.table_contains(self.SSBList, _nearestABname) then self.SSBList[_nearestABname] = {} end
</span><span class="comment">--            SPECTRE.UTILS.safeInsert(self.SSBList[_nearestABname], {
</span><span class="comment">--              name = groupData.groupName,
</span><span class="comment">--              coal = groupData.coalition,
</span><span class="comment">--            })
</span><span class="comment">--            break
</span><span class="comment">--          end
</span><span class="comment">--        end
</span><span class="comment">--      end
</span><span class="comment">--    end
</span><span class="comment">--  end
</span><span class="comment">--  if SPECTRE.DebugEnabled == 1 then
</span><span class="comment">--    local force = true
</span><span class="comment">--    local _Randname =  "SSBList_FARP"
</span><span class="comment">--    local _filename = SPECTRE._persistenceLocations.ZONEMGR.path .. "DEBUG/"  .. self.ZoneName .. "/" .. _Randname .. ".lua"
</span><span class="comment">--    SPECTRE.IO.PersistenceToFile(_filename, self.SSBList, force)
</span><span class="comment">--  end
</span><span class="comment">--  return self
</span><span class="comment">--end
</span>

<span class="comment">--- Identify and list all airbases within the specified zone.
</span><span class="comment">--
</span><span class="comment">-- This function is essential for understanding the strategic layout of the zone by identifying all airbases within its boundaries.
</span><span class="comment">-- It scans each airbase from the ZoneManager's list, checking if it is located within the zone's defined area. The function
</span><span class="comment">-- ensures that only airbases lying within the zone are considered for further operations and strategies, thereby aligning
</span><span class="comment">-- in-game elements with the zone's geographical constraints and characteristics.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after identifying and listing all airbases within it.
</span><a id="3058"></a><span class="comment">-- @usage local zoneWithIdentifiedAirbases = someZone:DetermineAirbasesInZone() -- Identifies and lists all the airbases located within the given zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:DetermineAirbasesInZone()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DetermineAirbasesInZone | ---------------------"</span>)
  <span class="comment">-- Get the list of airbases from the ZoneManager.
</span>  <span class="keyword">local</span> _AirbaseListTheatre = self.ZoneManager.AirbaseSeed

  <span class="comment">-- Iterate over each airbase in the list.
</span>  <span class="keyword">for</span> _, airbaseName <span class="keyword">in</span> <span class="global">pairs</span>(_AirbaseListTheatre) <span class="keyword">do</span>
    <span class="comment">-- Find the airbase by its name.
</span>    <span class="keyword">local</span> airbase_ = AIRBASE:FindByName(airbaseName)

    <span class="comment">-- Check if the airbase is within the specified zone.
</span>    <span class="keyword">local</span> isInZone = SPECTRE.POLY.PointWithinShape(airbase_:GetVec2(), self.Vertices2D)

    <span class="comment">-- If the airbase is within the zone, add it to the Airbases table.
</span>    <span class="keyword">if</span> isInZone <span class="keyword">then</span>
      self.Airbases[airbaseName] = {
        Object = airbase_,
        SPAWNER = {},
        ownedBy = airbase_:GetCoalition(),
        oldOwnedBy = airbase_:GetCoalition(),
        vec2 = airbase_:GetVec2(),
        name = airbaseName,
      }
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Identify and return all units within the specified Quadpoint zone.
</span><span class="comment">--
</span><span class="comment">-- This function is designed to identify all units within the boundaries of the current zone. It scans through each unit from
</span><span class="comment">-- the ZoneManager's list, checking if they are located within the zone's defined area. The function is crucial for gathering
</span><span class="comment">-- comprehensive data about the units present in the zone, which can be used for various strategic and management purposes
</span><span class="comment">-- within the game. It adds an additional layer of situational awareness by providing detailed information about the ground,
</span><span class="comment">-- structure, and ship units present in the zone.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after identifying all units within it.
</span><a id="3098"></a><span class="comment">-- @usage local zoneWithIdentifiedUnits = someZone:FindUnitsInZone() -- Identifies and returns all units located within the given zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:FindUnitsInZone()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | -------------------------------------------- "</span>)

  self._detectedUnits = {}
  self._detectedUnits[<span class="number">0</span>] = {}
  self._detectedUnits[<span class="number">1</span>] = {}
  self._detectedUnits[<span class="number">2</span>] = {}

  self.ZONEPOLYOBJ:Scan({Object.Category.UNIT}, {Unit.Category.GROUND_UNIT, Unit.Category.STRUCTURE, Unit.Category.SHIP})

  <span class="keyword">local</span> scanData = self.ZONEPOLYOBJ.ScanData
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | scanData     | "</span> , scanData)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | SPECTRE.SPAWNER.TEMPLATETYPES_     | "</span> , SPECTRE.SPAWNER.TEMPLATETYPES_)
  <span class="keyword">if</span> scanData <span class="keyword">then</span>
    <span class="comment">-- Units
</span>    <span class="keyword">if</span> scanData.Units <span class="keyword">then</span>
      <span class="keyword">for</span> _, unit <span class="keyword">in</span> <span class="global">pairs</span>(scanData.Units) <span class="keyword">do</span>
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | FOUND UNIT ------------------------ "</span>, unit)
        <span class="keyword">local</span> _unitCoal = unit:getCoalition()
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | _unitCoal   | "</span> .. _unitCoal)
        <span class="keyword">local</span> _unitName = unit:getName()
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | _unitName   | "</span> .. _unitName)
        <span class="keyword">local</span> unit_ = UNIT:FindByName(_unitName)
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | _unitName   | "</span> , unit_)

        <span class="keyword">if</span> unit_ <span class="keyword">then</span>
          <span class="keyword">local</span> _unitVec2 = {}
          <span class="keyword">local</span> _tVecBuilderUNIT = unit_:GetPosition()
          _unitVec2.x = _tVecBuilderUNIT.p.x
          _unitVec2.y = _tVecBuilderUNIT.p.z
          <span class="keyword">local</span> _unitid = unit.id_

          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | _unitVec2.x | "</span> .. _unitVec2.x)
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | _unitVec2.y | "</span> .. _unitVec2.y)
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | _unitid     | "</span> .. _unitid)

          <span class="keyword">local</span> matchedType
          <span class="keyword">if</span> self.Intel == <span class="keyword">true</span> <span class="keyword">then</span>
            SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | INTEL DESIRED  ------------------------ "</span>)
            <span class="comment">-- Nested function to find the template type with the highest priority
</span>            <span class="keyword">local</span> <span class="keyword">function</span> findTypeIndex(<span class="global">table</span>, input)
              <span class="keyword">local</span> highestPriority = -<span class="number">1</span>
              <span class="keyword">local</span> matchingType = <span class="keyword">nil</span>
              <span class="comment">-- Iterate through the TEMPLATETYPES_ table to find the matching type with highest priority
</span>              <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="global">pairs</span>(<span class="global">table</span>) <span class="keyword">do</span>
                <span class="keyword">for</span> _, _attr <span class="keyword">in</span> <span class="global">ipairs</span>(input) <span class="keyword">do</span>
                  <span class="keyword">if</span> _attr == key <span class="keyword">and</span> value._Priority <span class="keyword">and</span> value._Priority &gt; highestPriority <span class="keyword">then</span>
                    highestPriority = value._Priority
                    matchingType = key
                  <span class="keyword">end</span>
                <span class="keyword">end</span>
              <span class="keyword">end</span>
              SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:FindUnitsInZone | matchedType | "</span> .. matchingType)
              <span class="keyword">return</span> matchingType
            <span class="keyword">end</span>
            <span class="keyword">local</span> _UNITAttributes = SPECTRE.UTILS.GetUnitAttributes(_unitName)
            <span class="keyword">local</span> _tempAttri = {}
            <span class="keyword">for</span> _k, _v <span class="keyword">in</span> <span class="global">pairs</span> (_UNITAttributes) <span class="keyword">do</span>
              <span class="comment">--SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR.Zone:getHotspotsIntel | ATRB | " .. _k)
</span>              SPECTRE.UTILS.safeInsert(_tempAttri, _k)
            <span class="keyword">end</span>
            matchedType = findTypeIndex(SPECTRE.SPAWNER.TEMPLATETYPES_, _tempAttri)
          <span class="keyword">end</span>
          self._detectedUnits[_unitCoal][#self._detectedUnits[_unitCoal] + <span class="number">1</span>] = {
            name = _unitName,
            vec2 = _unitVec2,
            unit = _unitid,
            matchedType = matchedType <span class="keyword">or</span> <span class="keyword">nil</span>,
          }
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Enable or disable the hotspot feature for the zone.
</span><span class="comment">--
</span><span class="comment">-- This function allows for toggling the hotspot feature of a zone on or off. A hotspot is typically an area of
</span><span class="comment">-- strategic interest within the zone. Enabling the hotspot feature could be used to trigger specific behaviors
</span><span class="comment">-- or responses related to the zone. The ability to enable or disable this feature programmatically adds flexibility
</span><span class="comment">-- in how the zone is interacted with and managed during gameplay.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone self The Zone instance for which the hotspot feature is to be enabled or disabled.
</span><span class="comment">-- @param enabled (Optional) A boolean value to enable (true) or disable (false) the hotspot feature. Defaults to false if not specified.
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after toggling the hotspot feature.
</span><a id="3185"></a><span class="comment">-- @usage local updatedZone = someZone:enableZoneHotspot(true) -- Enables the hotspot feature for the specified zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:enableZoneHotspot(enabled)
  enabled = enabled <span class="keyword">or</span> <span class="keyword">false</span>
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:enableZoneHotspot | ---------------------"</span>)
  self.Hotspots = enabled
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Initialize a scheduler for managing hotspots within the zone.
</span><span class="comment">--
</span><span class="comment">-- This function sets up a scheduler to periodically check and update hotspots within the zone. It ensures that the hotspots
</span><span class="comment">-- and any related intelligence data are refreshed at regular intervals. The scheduler also accounts for ongoing updates,
</span><span class="comment">-- avoiding overlaps in processing. This systematic approach to managing hotspots enhances the zone's dynamics, ensuring
</span><span class="comment">-- that changes in game conditions are regularly reflected in hotspot statuses and information.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after initializing the hotspot scheduler.
</span><a id="3202"></a><span class="comment">-- @usage local zoneWithScheduler = someZone:_HotspotSchedInit() -- Initializes the hotspot scheduler for the specified zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:_HotspotSchedInit()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR:HotspotSchedInit | ---------------------"</span>)
  <span class="comment">-- Initialize a scheduler to periodically check and update zones
</span>  <span class="comment">--self.ZoneManager._HotspotSched[self.ZoneName] = {}
</span>  <span class="comment">--self.ZoneManager._HotspotSched[self.ZoneName] = SCHEDULER:New(nil, function()
</span>  <span class="comment">--  self.HotspotSched = SCHEDULER:New(self, function()
</span>  <span class="comment">--    SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR:self.HotspotSched | ZONE: " .. self.ZoneName)
</span>  <span class="comment">--    -- Only proceed if zones are not already being updated
</span>  <span class="comment">--    if not self.UpdatingHotspots then
</span>  <span class="comment">--      SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR:HotspotSched | UPDATES NOT IN PROG, STARTING")
</span>  <span class="comment">--      self.UpdatingHotspots = true
</span>  <span class="comment">--
</span>  <span class="comment">--      local _Timer = TIMER:New(function()
</span>  <span class="comment">--        SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR:HotspotSched | UPDATING | " .. self.ZoneName .. " ~~~~~~~~~~")
</span>  <span class="comment">--        if self.Hotspots == true then
</span>  <span class="comment">--          self:getHotspotGroups()
</span>  <span class="comment">--          self:ClearHotspots()
</span>  <span class="comment">--          self:DrawHotspots()
</span>  <span class="comment">--        end
</span>  <span class="comment">--        if self.Intel == true then
</span>  <span class="comment">--          self:ClearIntel()
</span>  <span class="comment">--          self:getHotspotsIntel()
</span>  <span class="comment">--          --zoneObject:DrawHotspotsIntel()
</span>  <span class="comment">--        end
</span>  <span class="comment">--        SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR:HotspotSched | END UPDATING | " .. self.ZoneName .. " ~~~~~~~~~~")
</span>  <span class="comment">--        self.UpdatingHotspots = false
</span>  <span class="comment">----        return self
</span>  <span class="comment">--      end, self)
</span>  <span class="comment">--      _Timer:Start(math.random(1,5))
</span>  <span class="comment">--    else
</span>  <span class="comment">--      SPECTRE.UTILS.debugInfo("SPECTRE.ZONEMGR:HotspotSched | UPDATES ALREADY IN PROG")
</span>  <span class="comment">--    end
</span>  <span class="comment">--    return self
</span>  <span class="comment">--  end, {self}, math.random(1,20), self.UpdateInterval, self.UpdateIntervalNudge)
</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>
<span class="comment">--- Enable or disable hotspot intelligence for the zone.
</span><span class="comment">--
</span><span class="comment">-- This function toggles the intelligence feature related to hotspots within the zone. When enabled, it allows for the collection
</span><span class="comment">-- and processing of additional intelligence data associated with hotspots. This feature is essential for enhancing strategic
</span><span class="comment">-- decision-making by providing more detailed insights into areas of interest within the zone.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone self The Zone instance for which the hotspot intelligence feature is to be toggled.
</span><span class="comment">-- @param enabled (Optional) A boolean value to enable (true) or disable (false) the hotspot intelligence feature. Defaults to false if not specified.
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after toggling the hotspot intelligence feature.
</span><a id="3249"></a><span class="comment">-- @usage local zoneWithHotspotIntel = someZone:enableHotspotIntel(true) -- Enables the hotspot intelligence feature for the specified zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:enableHotspotIntel(enabled)
  enabled = enabled <span class="keyword">or</span> <span class="keyword">false</span>
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:enableZoneHotspotIntel | ---------------------"</span>)
  self.Intel = enabled
  <span class="keyword">return</span> self
<span class="keyword">end</span>


<span class="comment">--- Enable or disable automatic spawns for the coalition that captures an airfield for the SPECTRE.ZONEMGR instance.
</span><span class="comment">--
</span><span class="comment">--  EX: If enabled, when Blue captures an airfield, will pull a random AIRFIELDSPAWNER template from ZONEMGR db and spawn friendly blue units at the field.
</span><span class="comment">--
</span><span class="comment">--  does not spawn units if old ownership coalition value was contested or same as new ownership.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone self The instance of the zone manager to adjust the persistence setting.
</span><span class="comment">-- @param enabled A boolean value (true or false) to enable or disable the persistence system respectively. Defaults to true if not specified.
</span><span class="comment">-- @return #ZONEMGR.Zone self The zone manager instance with the updated persistence setting.
</span><span class="comment">-- @usage zoneManager.Zones[ZONE NAME]:enableAirfieldCaptureSpawns(true) -- Enables automatic spawns for the coalition that captures an airfield at the airfield.
</span><a id="3268"></a><span class="comment">-- @usage zoneManager.Zones[ZONE NAME]:enableAirfieldCaptureSpawns(false) -- Disables automatic spawns for the coalition that captures an airfield at the airfield.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:enableAirfieldCaptureSpawns(enabled)
  <span class="comment">-- Default to true if no value is provided
</span>  <span class="keyword">if</span> enabled == <span class="keyword">nil</span> <span class="keyword">then</span> enabled = <span class="keyword">true</span> <span class="keyword">end</span>
  <span class="comment">--  enabled = enabled or true
</span>  self._AirfieldCaptureSpawns = enabled
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- WIP. Non Functional
</span><span class="comment">--
</span><span class="comment">-- Enable or disable automatic airfield cleanup on base capture.
</span><span class="comment">--
</span><span class="comment">--  EX: If enabled, when .
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone self The instance of the zone manager to adjust the persistence setting.
</span><span class="comment">-- @param enabled A boolean value (true or false) to enable or disable the persistence system respectively. Defaults to true if not specified.
</span><span class="comment">-- @return #ZONEMGR.Zone self The zone manager instance with the updated persistence setting.
</span><span class="comment">-- @usage zoneManager.Zones[ZONE NAME]:enableAirfieldCaptureSpawns(true) -- Enables automatic spawns for the coalition that captures an airfield at the airfield.
</span><a id="3287"></a><span class="comment">-- @usage zoneManager.Zones[ZONE NAME]:enableAirfieldCaptureSpawns(false) -- Disables automatic spawns for the coalition that captures an airfield at the airfield.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:enableAirfieldCaptureClean(enabled)
  <span class="comment">-- Default to true if no value is provided
</span>  <span class="keyword">if</span> enabled == <span class="keyword">nil</span> <span class="keyword">then</span> enabled = <span class="keyword">true</span> <span class="keyword">end</span>
  <span class="comment">--enabled = enabled or true
</span>  self._AirfieldCaptureClean = enabled
  <span class="keyword">return</span> self
<span class="keyword">end</span>


<span class="comment">--- Retrieve and organize groups of units as hotspots within the zone.
</span><span class="comment">--
</span><span class="comment">-- This function plays a key role in identifying and categorizing groups of units within the zone as hotspots. It first locates all units
</span><span class="comment">-- in the zone and then applies a clustering algorithm (DBSCAN) to group these units based on proximity and coalition. This process results
</span><span class="comment">-- in the formation of hotspots, which are clusters of units representing areas of strategic interest or activity within the zone. This organized
</span><span class="comment">-- approach to identifying hotspots is crucial for understanding the distribution and concentration of forces or resources within the zone.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after identifying and organizing hotspot groups.
</span><a id="3306"></a><span class="comment">-- @usage local zoneWithHotspots = someZone:getHotspotGroups() -- Retrieves and organizes groups of units as hotspots within the zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:getHotspotGroups()
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:getHotspotGroups | ------------------------ "</span>)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:getHotspotGroups | FindUnitsInZone: "</span> .. self.ZoneName)
  self:FindUnitsInZone()
  self.HotspotClusters = {}
  self._DBScan = {}

  <span class="keyword">for</span> _coal = <span class="number">0</span>, <span class="number">2</span> , <span class="number">1</span> <span class="keyword">do</span>
    <span class="keyword">if</span> self._detectedUnits[_coal] <span class="keyword">and</span> #self._detectedUnits[_coal] &gt; <span class="number">0</span> <span class="keyword">then</span>
      <span class="keyword">local</span> _DBscanner = SPECTRE.BRAIN.DBSCANNER:New(self._detectedUnits[_coal],self.Area, self._hotspotDrawExtension):Scan()
      self.HotspotClusters[_coal] = _DBscanner.Clusters

      <span class="keyword">if</span> SPECTRE.DebugEnabled == <span class="number">1</span> <span class="keyword">then</span>
        <span class="keyword">local</span> force = <span class="keyword">true</span>
        <span class="keyword">local</span> _Randname = <span class="string">"Hotspot_DetectedUnits_"</span> .. _coal
        <span class="keyword">local</span> _filename = SPECTRE._persistenceLocations.ZONEMGR.path .. <span class="string">"DEBUG/"</span>  .. self.ZoneName .. <span class="string">"/"</span> .. _Randname .. <span class="string">".lua"</span>
        SPECTRE.IO.PersistenceToFile(_filename, self._detectedUnits[_coal], force)
        _Randname = <span class="string">"Hotspot_Clusters_"</span> .. _coal
        _filename = SPECTRE._persistenceLocations.ZONEMGR.path .. <span class="string">"DEBUG/"</span>  .. self.ZoneName .. <span class="string">"/"</span> .. _Randname .. <span class="string">".lua"</span>
        SPECTRE.IO.PersistenceToFile(_filename, self.HotspotClusters[_coal], force)
      <span class="keyword">end</span>

    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>


<span class="comment">--- Draw hotspot circles on the map for each coalition.
</span><span class="comment">--
</span><span class="comment">-- This function visualizes hotspots on the map by drawing circles representing their locations and extents.
</span><span class="comment">-- It iterates through hotspots identified for each coalition and draws a circle for each, using a specific color and fill color.
</span><span class="comment">-- The function plays a crucial role in providing a visual representation of areas of high activity or strategic importance within the zone,
</span><span class="comment">-- enhancing situational awareness and strategic planning.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after drawing the hotspots on the map.
</span><a id="3344"></a><span class="comment">-- @usage local zoneWithDrawnHotspots = someZone:DrawHotspots() -- Draws hotspot circles for each coalition in the zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:DrawHotspots()
  <span class="comment">-- Define constants
</span>  <span class="comment">-- local _coal = 1
</span>  <span class="keyword">local</span> oppcoalt_ = {[<span class="number">0</span>] = -<span class="number">1</span>, [<span class="number">1</span>] = <span class="number">2</span>, [<span class="number">2</span>] = <span class="number">1</span>,} <span class="comment">--2
</span>  <span class="keyword">local</span> color = {<span class="number">0.36</span>, <span class="number">0.36</span>, <span class="number">0.36</span>, <span class="number">0.60</span>}<span class="comment">--0.6}
</span>  <span class="keyword">local</span> fillColor = {<span class="number">0.99</span>, <span class="number">0.847</span>, <span class="number">1</span>,<span class="number">0.25</span>}<span class="comment">-- 0.25}
</span>  <span class="keyword">for</span> _coal = <span class="number">0</span>, <span class="number">2</span> , <span class="number">1</span> <span class="keyword">do</span>
    <span class="keyword">local</span> oppcoal = oppcoalt_[_coal]
    <span class="comment">-- Check if there are hotspots to draw
</span>    <span class="keyword">if</span> self.HotspotClusters[_coal] <span class="keyword">and</span> #self.HotspotClusters[_coal] &gt; <span class="number">0</span> <span class="keyword">then</span>
      <span class="comment">-- Debug information consolidated
</span>      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:DrawHotspots | ------------------------\n"</span> ..
        <span class="string">"| Number of Hotspots | "</span> .. #self.HotspotClusters[_coal])

      <span class="comment">-- Draw each hotspot
</span>      <span class="keyword">for</span> _hotspotIndex, _Hotspot <span class="keyword">in</span> <span class="global">ipairs</span>(self.HotspotClusters[_coal]) <span class="keyword">do</span>
        <span class="comment">-- Assign a new mark ID and increment the global marker counter.
</span>        <span class="keyword">local</span> _tLength = #self.HotspotMarkers[_coal] + <span class="number">1</span>
        self.HotspotMarkers[_coal][_tLength] = {}
        self.HotspotMarkers[_coal][_tLength].MarkerID = self.ZoneManager.codeMarker_
        self.ZoneManager.codeMarker_ = self.ZoneManager.codeMarker_ + <span class="number">1</span>


        <span class="keyword">local</span> markerTable_ = {
          MarkerID = self.HotspotMarkers[_coal][_tLength].MarkerID,
          Vec3 = _Hotspot.CenterVec3,
          coal = oppcoal,
          radius = (_Hotspot.Radius),
          color = color,
          fillColor = fillColor,
          num = <span class="number">2</span>,
          ReadOnly = self.ReadOnly,
        }
        <span class="global">table</span>.insert(self.ZoneManager._hotspotQueue, markerTable_)

        <span class="comment">-- Draw the zone using the defined properties.
</span>        <span class="comment">--        trigger.action.circleToAll(oppcoal, self.HotspotMarkers[_coal][_tLength].MarkerID, _Hotspot.CenterVec3,
</span>        <span class="comment">--          (_Hotspot.Radius), color, fillColor, 2, self.ReadOnly)
</span>      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Clear all drawn hotspots from the map for each coalition.
</span><span class="comment">--
</span><span class="comment">-- This function removes the visual representation of all hotspots previously drawn on the map for each coalition.
</span><span class="comment">-- It ensures that the map reflects the current state of hotspots, allowing for updates or changes in strategic situations.
</span><span class="comment">-- This clearing process is essential for maintaining an accurate and up-to-date visual depiction of the zone's hotspots.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after clearing the hotspots from the map.
</span><a id="3397"></a><span class="comment">-- @usage local zoneWithClearedHotspots = someZone:ClearHotspots() -- Clears all hotspot markers for each coalition in the zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:ClearHotspots()
  <span class="comment">-- local _coal = 1
</span>  <span class="keyword">for</span> _coal = <span class="number">0</span>, <span class="number">2</span> , <span class="number">1</span> <span class="keyword">do</span>
    <span class="comment">-- Check if there are hotspots to clear
</span>    <span class="keyword">if</span> self.HotspotMarkers[_coal] <span class="keyword">and</span> #self.HotspotMarkers[_coal] &gt; <span class="number">0</span> <span class="keyword">then</span>
      <span class="comment">-- Debug information consolidated
</span>      SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:ClearHotspots | ------------------------\n"</span> ..
        <span class="string">"| Number of Hotspots to Clear | "</span> .. #self.HotspotMarkers[_coal])

      <span class="comment">-- Clear each hotspot
</span>      <span class="keyword">for</span> _hotspotIndex, _Hotspot <span class="keyword">in</span> <span class="global">ipairs</span>(self.HotspotMarkers[_coal]) <span class="keyword">do</span>
        <span class="keyword">if</span> _Hotspot.MarkerID ~= <span class="number">0</span> <span class="keyword">then</span>
          SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:ClearHotspots | Removing Marker | "</span> .. _Hotspot.MarkerID)
          <span class="keyword">local</span> markerTable_ = {
            MarkerID = _Hotspot.MarkerID,
          }
          <span class="global">table</span>.insert(self.ZoneManager._removeMarkerQueue, markerTable_)
          <span class="comment">-- trigger.action.removeMark(_Hotspot.MarkerID)
</span>        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    self.HotspotMarkers[_coal] = {}
  <span class="keyword">end</span>
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Gathers and displays intelligence information for hotspots in the zone.
</span><span class="comment">-- This function compiles intelligence data for each hotspot in the zone, summarizing the types of units present within each hotspot.
</span><span class="comment">-- It then visually represents this intelligence on the map, providing insights into the composition of forces or resources at strategic locations.
</span><span class="comment">-- This information is valuable for tactical decision-making and understanding the nature of the opposition within different hotspots.
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after gathering and displaying intelligence information for its hotspots.
</span><a id="3430"></a><span class="comment">-- @usage local zoneWithIntel = someZone:getHotspotsIntel() -- Gathers and displays intelligence data for hotspots in the zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:getHotspotsIntel()
  <span class="keyword">local</span> _coalitionMap = {[<span class="number">0</span>] = -<span class="number">1</span>, [<span class="number">1</span>] = <span class="number">2</span>, [<span class="number">2</span>] = <span class="number">1</span>}

  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:getHotspotsIntel | START ------------------------"</span>)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:getHotspotsIntel | Zone: "</span> .. self.ZoneName)
  <span class="keyword">for</span> _coalition = <span class="number">1</span>, <span class="number">2</span> <span class="keyword">do</span>
    <span class="keyword">local</span> opposingCoalition = _coalitionMap[_coalition]
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:getHotspotsIntel | Coal: "</span> .. _coalition)
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:getHotspotsIntel | Opposing Coal: "</span> .. opposingCoalition)

    <span class="keyword">if</span> self.HotspotClusters[_coalition] <span class="keyword">and</span> #self.HotspotClusters[_coalition] &gt; <span class="number">0</span> <span class="keyword">then</span>
      <span class="keyword">for</span> _hotspotIndex, _Hotspot <span class="keyword">in</span> <span class="global">ipairs</span>(self.HotspotClusters[_coalition]) <span class="keyword">do</span>
        <span class="keyword">local</span> _hotspotAttributes = {}
        <span class="keyword">for</span> _, _unitDetails <span class="keyword">in</span> <span class="global">ipairs</span>(_Hotspot.Units) <span class="keyword">do</span>
          <span class="keyword">if</span> _unitDetails.matchedType <span class="keyword">then</span>
            <span class="global">table</span>.insert(_hotspotAttributes, _unitDetails.matchedType)
          <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">local</span> _countedAttributes = SPECTRE.UTILS.CountValues(_hotspotAttributes)
        <span class="keyword">local</span> totalTypes = <span class="number">0</span>
        <span class="keyword">for</span> _, _numTypes <span class="keyword">in</span> <span class="global">pairs</span>(_countedAttributes) <span class="keyword">do</span>
          totalTypes = totalTypes + _numTypes
        <span class="keyword">end</span>

        <span class="keyword">local</span> intelString = <span class="string">"Intel: "</span>
        <span class="keyword">for</span> _Type, _numTypes <span class="keyword">in</span> <span class="global">pairs</span>(_countedAttributes) <span class="keyword">do</span>
          intelString = intelString .. _Type .. <span class="string">", "</span>
        <span class="keyword">end</span>
        intelString = intelString:sub(<span class="number">1</span>, -<span class="number">3</span>) <span class="comment">-- Remove trailing comma and space.
</span>
        <span class="comment">-- Assign a new mark ID and increment the global marker counter.
</span>        self.IntelMarkers[_coalition] = self.IntelMarkers[_coalition] <span class="keyword">or</span> {}
        <span class="keyword">local</span> _tLength = #self.IntelMarkers[_coalition] + <span class="number">1</span>
        self.IntelMarkers[_coalition][_tLength] = {
          MarkerID = self.ZoneManager.codeMarker_,
          intelString = intelString
        }
        self.ZoneManager.codeMarker_ = self.ZoneManager.codeMarker_ + <span class="number">1</span>
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:getHotspotsIntel | intelString: "</span> .. intelString)
        SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:getHotspotsIntel | MarkerID: "</span> .. <span class="global">tostring</span>(self.IntelMarkers[_coalition][_tLength].MarkerID))

        <span class="keyword">local</span> markerTable_ = {
          MarkerID = self.IntelMarkers[_coalition][_tLength].MarkerID,
          intelString = intelString,
          Vec3 = _Hotspot.CenterVec3,
          coal = opposingCoalition,
          ReadOnly = self.ReadOnly
        }
        <span class="global">table</span>.insert(self.ZoneManager._markerQueue, markerTable_)
        <span class="comment">--trigger.action.markToCoalition(self.IntelMarkers[_coalition][_tLength].MarkerID, intelString, _Hotspot.CenterVec3, opposingCoalition, self.ReadOnly)
</span>      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.ZONEMGR.Zone:getHotspotsIntel | END ------------------------"</span>)
  <span class="keyword">return</span> self
<span class="keyword">end</span>

<span class="comment">--- Clear all intelligence markers from the map for each coalition.
</span><span class="comment">--
</span><span class="comment">-- This function is responsible for removing all intelligence markers related to hotspots from the map.
</span><span class="comment">-- It iterates through each coalition's intel markers and clears them, ensuring that the map reflects the most current intelligence information.
</span><span class="comment">-- This action is crucial for maintaining an accurate and up-to-date strategic view of the zone, especially when situations change rapidly.
</span><span class="comment">--
</span><span class="comment">-- @param #ZONEMGR.Zone
</span><span class="comment">-- @return #ZONEMGR.Zone self The Zone instance after clearing all intelligence markers.
</span><a id="3497"></a><span class="comment">-- @usage local zoneWithClearedIntel = someZone:ClearIntel() -- Clears all intelligence markers for each coalition in the zone.
</span><span class="keyword">function</span> SPECTRE.ZONEMGR.Zone:ClearIntel()
  <span class="comment">-- Debug information consolidated
</span>  <span class="keyword">local</span> debugInfo = <span class="string">"SPECTRE.ZONEMGR.Zone:ClearIntel | ------------------------\n"</span>
  <span class="comment">--local _coalt = {[0] = -1, [1] = 2, [2] = 1,}
</span>  <span class="keyword">for</span> _coal = <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span> <span class="keyword">do</span>

    <span class="comment">--local oppcoal = _coalt[_coal]
</span>    <span class="keyword">if</span> self.IntelMarkers[_coal] <span class="keyword">and</span> #self.IntelMarkers[_coal] &gt; <span class="number">0</span> <span class="keyword">then</span>
      debugInfo = debugInfo .. <span class="string">"| Coal: "</span> .. _coal .. <span class="string">" | Number of Intel to Clear: "</span> .. #self.IntelMarkers[_coal] .. <span class="string">"\n"</span>
      <span class="keyword">for</span> _, _Hotspot <span class="keyword">in</span> <span class="global">ipairs</span>(self.IntelMarkers[_coal]) <span class="keyword">do</span>
        <span class="keyword">if</span> _Hotspot.MarkerID ~= <span class="number">0</span> <span class="keyword">then</span>
          debugInfo = debugInfo .. <span class="string">"| Removing Intel Marker: "</span> .. _Hotspot.MarkerID .. <span class="string">"\n"</span>

          <span class="keyword">local</span> markerTable_ = {
            MarkerID = _Hotspot.MarkerID,
          }
          <span class="global">table</span>.insert(self.ZoneManager._removeMarkerQueue, markerTable_)
          <span class="comment">-- trigger.action.removeMark(_Hotspot.MarkerID)
</span>        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    self.IntelMarkers[_coal] = {}
  <span class="keyword">end</span>
  SPECTRE.UTILS.debugInfo(debugInfo)
  <span class="keyword">return</span> self
<span class="keyword">end</span></pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2023-12-13 21:00:14 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
