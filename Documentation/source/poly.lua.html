<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>S.P.E.C.T.R.E.</h1>


<ul>
  <li><a href="../manual.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="nowrap">
  <li><a href="../source/ai.lua.html">ai.lua</a></li>
  <li><a href="../source/brain.lua.html">brain.lua</a></li>
  <li><a href="../source/handlers.lua.html">handlers.lua</a></li>
  <li><a href="../source/iads.lua.html">iads.lua</a></li>
  <li><a href="../source/io.lua.html">io.lua</a></li>
  <li><a href="../source/markers.lua.html">markers.lua</a></li>
  <li><a href="../source/menu.lua.html">menu.lua</a></li>
  <li><a href="../source/plyrmgr.lua.html">plyrmgr.lua</a></li>
  <li><strong>poly.lua</strong></li>
  <li><a href="../source/rewards.lua.html">rewards.lua</a></li>
  <li><a href="../source/spawner.lua.html">spawner.lua</a></li>
  <li><a href="../source/spectre.lua.html">spectre.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/world.lua.html">world.lua</a></li>
  <li><a href="../source/zonemgr.lua.html">zonemgr.lua</a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/AI.html">AI</a></li>
  <li><a href="../modules/BRAIN.html">BRAIN</a></li>
  <li><a href="../modules/HANDLERS.html">HANDLERS</a></li>
  <li><a href="../modules/IADS.html">IADS</a></li>
  <li><a href="../modules/IO.html">IO</a></li>
  <li><a href="../modules/MARKERS.html">MARKERS</a></li>
  <li><a href="../modules/MENU.html">MENU</a></li>
  <li><a href="../modules/PLYRMGR.html">PLYRMGR</a></li>
  <li><a href="../modules/POLY.html">POLY</a></li>
  <li><a href="../modules/REWARDS.html">REWARDS</a></li>
  <li><a href="../modules/SPAWNER.html">SPAWNER</a></li>
  <li><a href="../modules/SPECTRE.html">SPECTRE</a></li>
  <li><a href="../modules/UTILS.html">UTILS</a></li>
  <li><a href="../modules/WORLD.html">WORLD</a></li>
  <li><a href="../modules/ZONEMGR.html">ZONEMGR</a></li>
</ul>
<h2>Topics</h2>
<ul class="">
  <li><a href="../topics/readme.md.html">readme</a></li>
</ul>

</div>

<div id="content">

    <h2>poly.lua</h2>
<pre>
<span class="comment">--- **POLY**
</span><span class="comment">--
</span><span class="comment">-- Shape manipulation and analytical geometry.
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- @module POLY
</span><span class="comment">-- @extends SPECTRE
</span>
<span class="comment">--- SPECTRE.POLY.
</span><span class="comment">--
</span><span class="comment">-- Shape manipulation and analytical geometry.
</span><span class="comment">--
</span><span class="comment">-- @section POLY
</span><span class="comment">-- @field #POLY
</span>SPECTRE.POLY = {}

<span class="comment">--- Line.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with line operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.POLY
</span>

<span class="comment">--- Extend a Line.
</span><span class="comment">--
</span><span class="comment">-- Extends both ends of a given line by a specified length.
</span><span class="comment">--
</span><span class="comment">-- @param line A table containing two points, each having 'x' and 'y' attributes.
</span><span class="comment">-- @param extension The length by which both ends of the line will be extended.
</span><span class="comment">-- @return The extended line with modified points.
</span><a id="35"></a><span class="comment">-- @usage local extended = SPECTRE.POLY.extendLine({{x=0, y=0}, {x=1, y=1}}, 1) -- Extends the line by 1 unit on both ends.
</span><span class="keyword">function</span> SPECTRE.POLY.extendLine(line, extension)
  <span class="comment">-- Calculate the differences in x and y coordinates between the two points
</span>  <span class="keyword">local</span> dx = line[<span class="number">2</span>].x - line[<span class="number">1</span>].x
  <span class="keyword">local</span> dy = line[<span class="number">2</span>].y - line[<span class="number">1</span>].y
  <span class="comment">-- Calculate the length of the line
</span>  <span class="keyword">local</span> length = <span class="global">math</span>.sqrt(dx^<span class="number">2</span> + dy^<span class="number">2</span>)
  <span class="comment">-- If the length is 0, simply return the line as it is
</span>  <span class="keyword">if</span> length == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> line <span class="keyword">end</span>
  <span class="comment">-- Normalize the direction vector
</span>  <span class="keyword">local</span> nx = dx / length
  <span class="keyword">local</span> ny = dy / length
  <span class="comment">-- Extend the starting point of the line
</span>  line[<span class="number">1</span>].x = line[<span class="number">1</span>].x - nx * extension
  line[<span class="number">1</span>].y = line[<span class="number">1</span>].y - ny * extension
  <span class="comment">-- Extend the ending point of the line
</span>  line[<span class="number">2</span>].x = line[<span class="number">2</span>].x + nx * extension
  line[<span class="number">2</span>].y = line[<span class="number">2</span>].y + ny * extension
  <span class="keyword">return</span> line
<span class="keyword">end</span>

<span class="comment">--- Find Perpendicular Endpoint.
</span><span class="comment">--
</span><span class="comment">-- Calculates the endpoint of a line segment that is perpendicular to a given line, originates from a given point, and has a given length.
</span><span class="comment">--
</span><span class="comment">-- @param Point A table containing an 'x' and 'y' attribute representing the starting point of the perpendicular line segment.
</span><span class="comment">-- @param line A table containing two points, each having 'x' and 'y' attributes, representing the original line.
</span><span class="comment">-- @param length The length of the perpendicular line segment.
</span><span class="comment">-- @return A table with 'x' and 'y' attributes representing the endpoint of the perpendicular line segment.
</span><a id="64"></a><span class="comment">-- @usage local endpoint = SPECTRE.POLY.findPerpendicularEndpoints({x=1, y=1}, {{x=0, y=0}, {x=1, y=1}}, 1) -- Finds the endpoint of a 1 unit long perpendicular line segment.
</span><span class="keyword">function</span> SPECTRE.POLY.findPerpendicularEndpoints(Point, line, length)
  <span class="comment">-- Calculate the differences in x and y coordinates between the two points of the line
</span>  <span class="keyword">local</span> dx = line[<span class="number">2</span>].x - line[<span class="number">1</span>].x
  <span class="keyword">local</span> dy = line[<span class="number">2</span>].y - line[<span class="number">1</span>].y
  <span class="comment">-- If the dx is 0, then the line is vertical and the perpendicular line is horizontal
</span>  <span class="keyword">if</span> dx == <span class="number">0</span> <span class="keyword">then</span>
    <span class="keyword">return</span> {x = Point.x, y = Point.y + length}
  <span class="keyword">end</span>
  <span class="comment">-- Calculate the slope of the line
</span>  <span class="keyword">local</span> m = dy / dx
  <span class="comment">-- Calculate the slope of the perpendicular line
</span>  <span class="keyword">local</span> m_perpendicular = -<span class="number">1</span> / m
  <span class="comment">-- Find the x-coordinate of the endpoint of the perpendicular line segment
</span>  <span class="keyword">local</span> x = Point.x + length / <span class="global">math</span>.sqrt(<span class="number">1</span> + m_perpendicular^<span class="number">2</span>)
  <span class="comment">-- Using the point-slope form of a line equation, calculate the y-coordinate of the endpoint
</span>  <span class="keyword">local</span> y = Point.y + m_perpendicular * (x - Point.x)
  <span class="keyword">return</span> {x = x, y = y}
<span class="keyword">end</span>

<span class="comment">--- Calculate Line Slope.
</span><span class="comment">--
</span><span class="comment">-- Calculates the slope of a given line.
</span><span class="comment">--
</span><span class="comment">-- @param line A table containing two points, each having 'x' and 'y' attributes.
</span><span class="comment">-- @return The slope of the line, or 'math.huge' if the line is vertical.
</span><a id="90"></a><span class="comment">-- @usage local slope = SPECTRE.POLY.calculateLineSlope({{x=0, y=0}, {x=1, y=1}}) -- Calculates the slope of the line.
</span><span class="keyword">function</span> SPECTRE.POLY.calculateLineSlope(line)
  <span class="comment">-- Calculate the differences in x and y coordinates between the two points of the line
</span>  <span class="keyword">local</span> dx = line[<span class="number">2</span>].x - line[<span class="number">1</span>].x
  <span class="keyword">local</span> dy = line[<span class="number">2</span>].y - line[<span class="number">1</span>].y
  <span class="comment">-- If dx is 0, the line is vertical and slope is infinite
</span>  <span class="keyword">if</span> dx == <span class="number">0</span> <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="global">math</span>.huge
  <span class="keyword">end</span>
  <span class="comment">-- Calculate the slope of the line using the formula (change in y) / (change in x)
</span>  <span class="keyword">local</span> slope = dy/dx
  <span class="keyword">return</span> slope
<span class="keyword">end</span>

<span class="comment">--- Find Other Endpoint of a Line Segment.
</span><span class="comment">--
</span><span class="comment">-- Calculates the other endpoint of a line segment given one endpoint, the slope, and the length of the segment.
</span><span class="comment">--
</span><span class="comment">-- @param endpoint A table containing an 'x' and 'y' attribute representing one endpoint of the line segment.
</span><span class="comment">-- @param slope The slope of the line segment.
</span><span class="comment">-- @param length The length of the line segment.
</span><span class="comment">-- @return A table with 'x' and 'y' attributes representing the other endpoint of the line segment.
</span><a id="112"></a><span class="comment">-- @usage local otherEndpoint = SPECTRE.POLY.findOtherEndpoint({x=1, y=1}, 1, 1) -- Finds the other endpoint of the line segment.
</span><span class="keyword">function</span> SPECTRE.POLY.findOtherEndpoint(endpoint, slope, length)
  <span class="comment">-- If slope is infinite (i.e., the line is vertical)
</span>  <span class="keyword">if</span> slope == <span class="global">math</span>.huge <span class="keyword">then</span>
    <span class="keyword">return</span> {x = endpoint.x, y = endpoint.y + length}
  <span class="keyword">end</span>
  <span class="comment">-- Calculate the magnitude of the direction vector of the line
</span>  <span class="keyword">local</span> magnitude = <span class="global">math</span>.sqrt(<span class="number">1</span> + slope^<span class="number">2</span>)
  <span class="comment">-- Normalize the direction vector to get unit vector components
</span>  <span class="keyword">local</span> unit_dx = <span class="number">1</span> / magnitude
  <span class="keyword">local</span> unit_dy = slope / magnitude
  <span class="comment">-- Calculate the x and y components of the displacement from the given endpoint to the other endpoint
</span>  <span class="keyword">local</span> dx = unit_dx * length
  <span class="keyword">local</span> dy = unit_dy * length
  <span class="comment">-- Compute the coordinates of the other endpoint
</span>  <span class="keyword">local</span> OtherEnd = {
    x = endpoint.x + dx,
    y = endpoint.y + dy
  }
  <span class="keyword">return</span> OtherEnd
<span class="keyword">end</span>

<span class="comment">--- Calculate Midpoint of a Line Segment.
</span><span class="comment">--
</span><span class="comment">-- Computes the midpoint of a given line segment.
</span><span class="comment">--
</span><span class="comment">-- @param line A table containing two points, each having 'x' and 'y' attributes.
</span><span class="comment">-- @return A table with 'x' and 'y' attributes representing the midpoint of the line segment.
</span><a id="140"></a><span class="comment">-- @usage local midpoint = SPECTRE.POLY.getMidpoint({{x=0, y=0}, {x=2, y=2}}) -- Calculates the midpoint of the line segment.
</span><span class="keyword">function</span> SPECTRE.POLY.getMidpoint(line)
  <span class="comment">-- Calculate the x and y coordinates of the midpoint using the average of the endpoints' coordinates
</span>  <span class="keyword">return</span> {
    x = (line[<span class="number">1</span>].x + line[<span class="number">2</span>].x) / <span class="number">2</span>,
    y = (line[<span class="number">1</span>].y + line[<span class="number">2</span>].y) / <span class="number">2</span>
  }
<span class="keyword">end</span>

<span class="comment">--- Check if Two Lines are Within a Specified Offset.
</span><span class="comment">--
</span><span class="comment">-- Determines if two line segments are within a certain offset from each other by sampling points on the lines.
</span><span class="comment">--
</span><span class="comment">-- @param LineA A table containing two points of the first line segment, each having 'x' and 'y' attributes.
</span><span class="comment">-- @param LineB A table containing two points of the second line segment, each having 'x' and 'y' attributes.
</span><span class="comment">-- @param Offset The distance threshold for the points on the lines.
</span><span class="comment">-- @return True if the lines are within the offset, false otherwise.
</span><a id="157"></a><span class="comment">-- @usage local result = SPECTRE.POLY.isWithinOffset(line1, line2, 10) -- Checks if line1 and line2 are within an offset of 10 units from each other.
</span><span class="keyword">function</span> SPECTRE.POLY.isWithinOffset(LineA, LineB, Offset)
  <span class="keyword">local</span> DesiredPoints = <span class="number">11</span>
  <span class="comment">-- Compute the ratio of the lengths of LineA and LineB
</span>  <span class="keyword">local</span> PointConfirmRate = SPECTRE.UTILS.computeRatio(SPECTRE.POLY.lineLength(LineA), SPECTRE.POLY.lineLength(LineB))
  <span class="comment">-- Compute the number of confirmation points needed based on the desired points and the computed ratio
</span>  <span class="keyword">local</span> threshold = DesiredPoints * PointConfirmRate
  <span class="comment">-- Nested function to check if the sampled points on one line are within the offset of the other line
</span>  <span class="keyword">local</span> <span class="keyword">function</span> checkPointsWithinOffset(lineToSample, lineToCheckAgainst)
    <span class="keyword">local</span> ticker = <span class="number">0</span>
    <span class="comment">-- Sample equally spaced points from the line
</span>    <span class="keyword">local</span> points = SPECTRE.POLY.getEquallySpacedPoints(lineToSample, DesiredPoints)
    <span class="comment">-- Check each sampled point against the other line to determine proximity
</span>    <span class="keyword">for</span> _, point <span class="keyword">in</span> <span class="global">ipairs</span>(points) <span class="keyword">do</span>
      <span class="keyword">if</span> <span class="global">math</span>.sqrt(SPECTRE.POLY.pointToSegmentSquared(point.x, point.y, lineToCheckAgainst[<span class="number">1</span>].x, lineToCheckAgainst[<span class="number">1</span>].y, lineToCheckAgainst[<span class="number">2</span>].x, lineToCheckAgainst[<span class="number">2</span>].y)) &lt;= Offset <span class="keyword">then</span>
        ticker = ticker + <span class="number">1</span>
        <span class="keyword">if</span> ticker &gt;= threshold <span class="keyword">then</span>
          <span class="keyword">return</span> <span class="keyword">true</span>
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> <span class="keyword">false</span>
  <span class="keyword">end</span>
  <span class="comment">-- Check both LineA against LineB and LineB against LineA to account for both possibilities
</span>  <span class="keyword">return</span> checkPointsWithinOffset(LineA, LineB) <span class="keyword">or</span> checkPointsWithinOffset(LineB, LineA)
<span class="keyword">end</span>

<span class="comment">--- Calculate Length of a Line Segment.
</span><span class="comment">--
</span><span class="comment">-- Computes the length of a given line segment using the Pythagorean theorem.
</span><span class="comment">--
</span><span class="comment">-- @param line A table containing two points, each having 'x' and 'y' attributes.
</span><span class="comment">-- @return The length of the line segment.
</span><a id="190"></a><span class="comment">-- @usage local length = SPECTRE.POLY.lineLength({{x=0, y=0}, {x=3, y=4}}) -- Calculates the length of the line segment (should return 5 in this example).
</span><span class="keyword">function</span> SPECTRE.POLY.lineLength(line)
  <span class="comment">-- Calculate the differences in x and y coordinates between the two endpoints of the line
</span>  <span class="keyword">local</span> dx = line[<span class="number">2</span>].x - line[<span class="number">1</span>].x
  <span class="keyword">local</span> dy = line[<span class="number">2</span>].y - line[<span class="number">1</span>].y
  <span class="comment">-- Use the Pythagorean theorem to compute the length of the line segment
</span>  <span class="keyword">return</span> <span class="global">math</span>.sqrt(dx^<span class="number">2</span> + dy^<span class="number">2</span>)
<span class="keyword">end</span>

<span class="comment">--- Generate a Random Point on a Line Segment.
</span><span class="comment">--
</span><span class="comment">-- Computes a random point on a given line segment using linear interpolation.
</span><span class="comment">--
</span><span class="comment">-- @param inputLine A table containing two points, each having 'x' and 'y' attributes.
</span><span class="comment">-- @return A table with 'x' and 'y' attributes representing the randomly generated point on the line segment.
</span><a id="205"></a><span class="comment">-- @usage local randomPoint = SPECTRE.POLY.randomPointOnLine({{x=0, y=0}, {x=10, y=10}}) -- Gets a random point on the line segment.
</span><span class="keyword">function</span> SPECTRE.POLY.randomPointOnLine(inputLine)
  <span class="keyword">local</span> p1, p2 = inputLine[<span class="number">1</span>], inputLine[<span class="number">2</span>]
  <span class="comment">-- Generate a random parameter t in [0, 1]
</span>  <span class="keyword">local</span> t = <span class="global">math</span>.random()
  <span class="comment">-- Compute the x and y coordinates of the random point using linear interpolation
</span>  <span class="keyword">return</span> {
    x = p1.x + t * (p2.x - p1.x),
    y = p1.y + t * (p2.y - p1.y)
  }
<span class="keyword">end</span>

<span class="comment">--- Generate Equally Spaced Points on a Line Segment.
</span><span class="comment">--
</span><span class="comment">-- Computes a set of equally spaced points on a given line segment using linear interpolation.
</span><span class="comment">--
</span><span class="comment">-- @param InputLine A table containing two points, each having 'x' and 'y' attributes.
</span><span class="comment">-- @param DesiredPoints The number of equally spaced points to generate.
</span><span class="comment">-- @return A table of tables, each with 'x' and 'y' attributes, representing the equally spaced points on the line segment.
</span><a id="224"></a><span class="comment">-- @usage local points = SPECTRE.POLY.getEquallySpacedPoints({{x=0, y=0}, {x=10, y=10}}, 5) -- Gets 5 equally spaced points on the line segment.
</span><span class="keyword">function</span> SPECTRE.POLY.getEquallySpacedPoints(InputLine, DesiredPoints)
  <span class="keyword">local</span> P1, P2 = InputLine[<span class="number">1</span>], InputLine[<span class="number">2</span>]
  <span class="keyword">local</span> OutputPoints = {}
  <span class="comment">-- Iterate from 1 to DesiredPoints to compute each equally spaced point
</span>  <span class="keyword">for</span> i = <span class="number">1</span>, DesiredPoints <span class="keyword">do</span>
    <span class="comment">-- Calculate the parameter t based on the current iteration and total number of desired points
</span>    <span class="keyword">local</span> t = i / (DesiredPoints + <span class="number">1</span>)
    <span class="comment">-- Compute the x and y coordinates of each point using linear interpolation
</span>    <span class="global">table</span>.insert(OutputPoints, {
      x = (<span class="number">1</span> - t) * P1.x + t * P2.x,
      y = (<span class="number">1</span> - t) * P1.y + t * P2.y
    })
  <span class="keyword">end</span>
  <span class="keyword">return</span> OutputPoints
<span class="keyword">end</span>

<span class="comment">--- Compute Intersection Point of Two Line Segments.
</span><span class="comment">--
</span><span class="comment">-- Computes the intersection point of two given line segments. Returns (0, 0) if the line segments don't intersect.
</span><span class="comment">--
</span><span class="comment">-- @param points A table containing four points, each having 'x' and 'y' attributes. The first two points represent the first line segment and the next two represent the second line segment.
</span><span class="comment">-- @return xk,yk The x and y coordinates of the intersection point.
</span><a id="247"></a><span class="comment">-- @usage local x, y = SPECTRE.POLY.GetIntersect({{x=0, y=0}, {x=10, y=10}, {x=0, y=10}, {x=10, y=0}}) -- Gets the intersection point of the two line segments.
</span><span class="keyword">function</span> SPECTRE.POLY.GetIntersect(points)
  <span class="comment">-- Extract points for clarity
</span>  <span class="keyword">local</span> p1, p2, p3, p4 = points[<span class="number">1</span>], points[<span class="number">2</span>], points[<span class="number">3</span>], points[<span class="number">4</span>]
  <span class="comment">-- Initialize intersection point coordinates
</span>  <span class="keyword">local</span> xk, yk = <span class="number">0</span>, <span class="number">0</span>
  <span class="comment">-- Check if the two line segments intersect
</span>  <span class="keyword">if</span> SPECTRE.POLY.checkIntersect(p1, p2, p3, p4) <span class="keyword">then</span>
    <span class="comment">-- Compute line parameters for the line formed by points p1 and p2
</span>    <span class="keyword">local</span> a = p2.y - p1.y
    <span class="keyword">local</span> b = p2.x - p1.x
    <span class="keyword">local</span> v = a * p1.x - b * p1.y
    <span class="comment">-- Compute line parameters for the line formed by points p3 and p4
</span>    <span class="keyword">local</span> c = p4.y - p3.y
    <span class="keyword">local</span> d = p4.x - p3.x
    <span class="keyword">local</span> w = c * p3.x - d * p3.y
    <span class="comment">-- Compute intersection point using determinants
</span>    <span class="keyword">local</span> denom = a * d - b * c
    <span class="keyword">if</span> denom ~= <span class="number">0</span> <span class="keyword">then</span>
      xk = (d * v - b * w) / denom
      yk = (-a * w + c * v) / denom
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="comment">-- Return intersection point
</span>  <span class="keyword">return</span> xk, yk
<span class="keyword">end</span>

<span class="comment">--- Check if Two Line Segments Intersect.
</span><span class="comment">--
</span><span class="comment">-- Determines if two given line segments intersect using orientation values.
</span><span class="comment">--
</span><span class="comment">-- @param l1 A table containing two points (p1 and p2) representing the first line segment, each having 'x' and 'y' attributes.
</span><span class="comment">-- @param l2 A table containing two points (p1 and p2) representing the second line segment, each having 'x' and 'y' attributes.
</span><span class="comment">-- @return bool  True if the line segments intersect, false otherwise.
</span><a id="281"></a><span class="comment">-- @usage local intersect = SPECTRE.POLY.isIntersect({p1={x=0, y=0}, p2={x=10, y=10}}, {p1={x=0, y=10}, p2={x=10, y=0}}) -- Checks if the two line segments intersect.
</span><span class="keyword">function</span> SPECTRE.POLY.isIntersect(l1, l2)
  <span class="comment">-- Calculate orientation values for each pair of points from the two lines
</span>  <span class="keyword">local</span> dir1 = SPECTRE.POLY.direction(l1.p1, l1.p2, l2.p1)
  <span class="keyword">local</span> dir2 = SPECTRE.POLY.direction(l1.p1, l1.p2, l2.p2)
  <span class="keyword">local</span> dir3 = SPECTRE.POLY.direction(l2.p1, l2.p2, l1.p1)
  <span class="keyword">local</span> dir4 = SPECTRE.POLY.direction(l2.p1, l2.p2, l1.p2)
  <span class="comment">-- If orientations of the endpoints with respect to each line are different, the lines intersect
</span>  <span class="keyword">if</span> dir1 ~= dir2 <span class="keyword">and</span> dir3 ~= dir4 <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
  <span class="keyword">end</span>
  <span class="comment">-- Check for colinearity and if a point of one line lies on the other line
</span>  <span class="keyword">if</span> dir1 == <span class="number">0</span> <span class="keyword">and</span> SPECTRE.POLY.onLine(l1, l2.p1) <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> dir2 == <span class="number">0</span> <span class="keyword">and</span> SPECTRE.POLY.onLine(l1, l2.p2) <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> dir3 == <span class="number">0</span> <span class="keyword">and</span> SPECTRE.POLY.onLine(l2, l1.p1) <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
  <span class="keyword">end</span>
  <span class="keyword">if</span> dir4 == <span class="number">0</span> <span class="keyword">and</span> SPECTRE.POLY.onLine(l2, l1.p2) <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
  <span class="keyword">end</span>
  <span class="comment">-- If none of the above conditions are met, lines do not intersect
</span>  <span class="keyword">return</span> <span class="keyword">false</span>
<span class="keyword">end</span>


<span class="comment">--- Point.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with vertex operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.POLY
</span>
<span class="comment">--- Calculate Distance Between Two Points.
</span><span class="comment">--
</span><span class="comment">-- Computes the distance between two given points using the Pythagorean theorem.
</span><span class="comment">--
</span><span class="comment">-- @param point1 A table having 'x' and 'y' attributes representing the first point.
</span><span class="comment">-- @param point2 A table having 'x' and 'y' attributes representing the second point.
</span><span class="comment">-- @return The distance between the two points.
</span><a id="325"></a><span class="comment">-- @usage local dist = SPECTRE.POLY.distance({x=0, y=0}, {x=3, y=4}) -- Calculates the distance between the two points (should return 5 in this example).
</span><span class="keyword">function</span> SPECTRE.POLY.distance(point1, point2)
  <span class="comment">-- Calculate the differences in x and y coordinates between the two points
</span>  <span class="keyword">local</span> dx = point1.x - point2.x
  <span class="keyword">local</span> dy = point1.y - point2.y

  <span class="comment">-- Use the Pythagorean theorem to compute the distance
</span>  <span class="keyword">return</span> <span class="global">math</span>.sqrt(dx^<span class="number">2</span> + dy^<span class="number">2</span>)
<span class="keyword">end</span>

<span class="comment">--- Calculate Squared Distance from a Point to a Line Segment.
</span><span class="comment">--
</span><span class="comment">-- Computes the squared distance from a given point to a line segment.
</span><span class="comment">--
</span><span class="comment">-- @param px x-coordinate of the point.
</span><span class="comment">-- @param py y-coordinate of the point.
</span><span class="comment">-- @param ax x-coordinate of the first endpoint of the line segment.
</span><span class="comment">-- @param ay y-coordinate of the first endpoint of the line segment.
</span><span class="comment">-- @param bx x-coordinate of the second endpoint of the line segment.
</span><span class="comment">-- @param by y-coordinate of the second endpoint of the line segment.
</span><span class="comment">-- @return number The squared distance from the point to the line segment.
</span><a id="346"></a><span class="comment">-- @usage local squaredDist = SPECTRE.POLY.pointToSegmentSquared(1, 1, 0, 0, 2, 2) -- Calculates the squared distance from the point to the line segment.
</span><span class="keyword">function</span> SPECTRE.POLY.pointToSegmentSquared(px, py, ax, ay, bx, by)
  <span class="comment">-- Calculate the squared distance between the endpoints of the segment
</span>  <span class="keyword">local</span> l2 = SPECTRE.POLY.distanceSquared(ax, ay, bx, by)

  <span class="comment">-- If the segment is a point, return the squared distance to the point
</span>  <span class="keyword">if</span> l2 == <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> SPECTRE.POLY.distanceSquared(px, py, ax, ay) <span class="keyword">end</span>

  <span class="comment">-- Project the point onto the line segment and find the parameter t
</span>  <span class="keyword">local</span> t = SPECTRE.POLY.dot(px - ax, py - ay, bx - ax, by - ay) / l2

  <span class="comment">-- If t is outside [0, 1], the point lies outside the segment, so return the squared distance to the nearest endpoint
</span>  <span class="keyword">if</span> t &lt; <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> SPECTRE.POLY.distanceSquared(px, py, ax, ay) <span class="keyword">end</span>
  <span class="keyword">if</span> t &gt; <span class="number">1</span> <span class="keyword">then</span> <span class="keyword">return</span> SPECTRE.POLY.distanceSquared(px, py, bx, by) <span class="keyword">end</span>

  <span class="comment">-- Compute the squared distance from the point to its projection on the segment
</span>  <span class="keyword">return</span> SPECTRE.POLY.distanceSquared(px, py, ax + t * (bx - ax), ay + t * (by - ay))
<span class="keyword">end</span>

<span class="comment">--- Calculate Squared Distance Between Two Points.
</span><span class="comment">--
</span><span class="comment">-- Computes the squared distance between two given points using the Pythagorean theorem.
</span><span class="comment">--
</span><span class="comment">-- @param ax x-coordinate of the first point.
</span><span class="comment">-- @param ay y-coordinate of the first point.
</span><span class="comment">-- @param bx x-coordinate of the second point.
</span><span class="comment">-- @param by y-coordinate of the second point.
</span><span class="comment">-- @return number The squared distance between the two points.
</span><a id="374"></a><span class="comment">-- @usage local squaredDist = SPECTRE.POLY.distanceSquared(0, 0, 3, 4) -- Calculates the squared distance between the two points (should return 25 in this example).
</span><span class="keyword">function</span> SPECTRE.POLY.distanceSquared(ax, ay, bx, by)
  <span class="comment">-- Calculate the differences in x and y coordinates between the two points
</span>  <span class="keyword">local</span> dx = ax - bx
  <span class="keyword">local</span> dy = ay - by

  <span class="comment">-- Return the squared distance using the Pythagorean theorem
</span>  <span class="keyword">return</span> dx * dx + dy * dy
<span class="keyword">end</span>

<span class="comment">--- Calculate Cross Product of Vectors Formed by Three Points.
</span><span class="comment">--
</span><span class="comment">-- Computes the cross product (determinant) of the vectors formed by three given points.
</span><span class="comment">--
</span><span class="comment">-- @param p1 A table having 'x' and 'y' attributes representing the first point.
</span><span class="comment">-- @param p2 A table having 'x' and 'y' attributes representing the second point.
</span><span class="comment">-- @param p3 A table having 'x' and 'y' attributes representing the third point.
</span><span class="comment">-- @return number The cross product of the vectors formed by the three points.
</span><a id="392"></a><span class="comment">-- @usage local crossProd = SPECTRE.POLY:crossProduct({x=0, y=0}, {x=1, y=1}, {x=0, y=2}) -- Calculates the cross product of the vectors formed by the three points.
</span><span class="keyword">function</span> SPECTRE.POLY:crossProduct(p1, p2, p3)
  <span class="comment">-- Calculate and return the cross product (determinant) of the vectors formed by the three points
</span>  <span class="keyword">return</span> (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)
<span class="keyword">end</span>

<span class="comment">--- Check if Point is Colinear with a Line Segment.
</span><span class="comment">--
</span><span class="comment">-- Determines if a given point is colinear with a line segment within a specified tolerance.
</span><span class="comment">--
</span><span class="comment">-- @param line A table containing two points, each having 'x' and 'y' attributes, representing the line segment.
</span><span class="comment">-- @param x x-coordinate of the test point.
</span><span class="comment">-- @param y y-coordinate of the test point.
</span><span class="comment">-- @param e Tolerance value for colinearity check. Defaults to 0.1 if not provided.
</span><span class="comment">-- @return boolean True if the point is colinear with the line segment within the tolerance, false otherwise.
</span><a id="407"></a><span class="comment">-- @usage local isColinear = SPECTRE.POLY.colinear({{x=0, y=0}, {x=10, y=10}}, 5, 5) -- Checks if the point (5,5) is colinear with the line segment.
</span><span class="keyword">function</span> SPECTRE.POLY.colinear(line, x, y, e)
  e = e <span class="keyword">or</span> <span class="number">0.1</span>  <span class="comment">-- Default tolerance
</span>
  <span class="comment">-- If the line segment is vertical
</span>  <span class="keyword">if</span> line[<span class="number">2</span>].x - line[<span class="number">1</span>].x == <span class="number">0</span> <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="global">math</span>.abs(x - line[<span class="number">1</span>].x) &lt;= e
  <span class="keyword">end</span>

  <span class="comment">-- Calculate the slope of the line
</span>  <span class="keyword">local</span> m = (line[<span class="number">2</span>].y - line[<span class="number">1</span>].y) / (line[<span class="number">2</span>].x - line[<span class="number">1</span>].x)

  <span class="comment">-- Compute the expected y-coordinate for the given x using the line equation
</span>  <span class="keyword">local</span> expectedY = line[<span class="number">1</span>].y + m * (x - line[<span class="number">1</span>].x)

  <span class="comment">-- Check if the actual y is close enough to the expected y within the tolerance
</span>  <span class="keyword">return</span> <span class="global">math</span>.abs(y - expectedY) &lt;= e
<span class="keyword">end</span>

<span class="comment">--- Check if Point is On or Within Bounds of a Line Segment.
</span><span class="comment">--
</span><span class="comment">-- Determines if a given point lies on or within the bounds of a line segment.
</span><span class="comment">--
</span><span class="comment">-- @param l1 A table containing two points (p1 and p2) representing the line segment, each having 'x' and 'y' attributes.
</span><span class="comment">-- @param p A table having 'x' and 'y' attributes representing the test point.
</span><span class="comment">-- @return boolean True if the point lies on or within the bounds of the line segment, false otherwise.
</span><a id="433"></a><span class="comment">-- @usage local isOnLine = SPECTRE.POLY.onLine({p1={x=0, y=0}, p2={x=10, y=10}}, {x=5, y=5}) -- Checks if the point (5,5) lies on the line segment.
</span><span class="keyword">function</span> SPECTRE.POLY.onLine(l1, p)
  <span class="comment">-- Check if the x and y coordinates of the point are within the bounds of the line segment's endpoints
</span>  <span class="keyword">if</span> (p.x &gt;= <span class="global">math</span>.min(l1.p1.x, l1.p2.x) <span class="keyword">and</span> p.x &lt;= <span class="global">math</span>.max(l1.p1.x, l1.p2.x)
    <span class="keyword">and</span> p.y &gt;= <span class="global">math</span>.min(l1.p1.y, l1.p2.y) <span class="keyword">and</span> p.y &lt;= <span class="global">math</span>.max(l1.p1.y, l1.p2.y)) <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="keyword">true</span>
  <span class="keyword">end</span>

  <span class="keyword">return</span> <span class="keyword">false</span>
<span class="keyword">end</span>

<span class="comment">--- Check if a Point is Within a Polygon.
</span><span class="comment">--
</span><span class="comment">-- Determines if a given point lies inside a polygon using the ray casting method.
</span><span class="comment">--
</span><span class="comment">-- @param P A table having 'x' and 'y' attributes representing the point to check.
</span><span class="comment">-- @param Polygon A table containing vertices of the polygon, each vertex is a table with 'x' and 'y' attributes.
</span><span class="comment">-- @return boolean True if the point lies inside the polygon, false otherwise.
</span><a id="451"></a><span class="comment">-- @usage local isWithin = SPECTRE.POLY.PointWithinShape({x=5, y=5}, {{x=0, y=0}, {x=10, y=0}, {x=10, y=10}, {x=0, y=10}}) -- Checks if the point (5,5) lies inside the square polygon.
</span><span class="keyword">function</span> SPECTRE.POLY.PointWithinShape(P, Polygon)
  <span class="keyword">local</span> n = #Polygon

  <span class="comment">-- A polygon must have at least 3 vertices to enclose a space
</span>  <span class="keyword">if</span> n &lt; <span class="number">3</span> <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="keyword">false</span>
  <span class="keyword">end</span>

  <span class="comment">-- Create a point for line segment from P to infinite
</span>  <span class="keyword">local</span> extreme = {x = <span class="number">99999999</span>, y = P.y}

  <span class="comment">-- Count intersections of the above line with sides of polygon
</span>  <span class="keyword">local</span> count = <span class="number">0</span>
  <span class="keyword">local</span> i = <span class="number">1</span>

  <span class="comment">-- Use a loop to iterate through all sides of the polygon
</span>  <span class="keyword">repeat</span>
    <span class="keyword">local</span> <span class="global">next</span> = (i % n) + <span class="number">1</span>
    <span class="keyword">local</span> side = {p1 = Polygon[i], p2 = Polygon[<span class="global">next</span>]}

    <span class="comment">-- Check if the line segment formed by P and extreme intersects with the side of the polygon
</span>    <span class="keyword">if</span> SPECTRE.POLY.isIntersect(side, {p1 = P, p2 = extreme}) <span class="keyword">then</span>

      <span class="comment">-- If the point P is collinear with the side of the polygon, check if it lies on the segment
</span>      <span class="keyword">if</span> SPECTRE.POLY.direction(side.p1, P, side.p2) == <span class="number">0</span> <span class="keyword">then</span>
        <span class="keyword">return</span> SPECTRE.POLY.onLine(side, P)
      <span class="keyword">end</span>

      <span class="comment">-- Increment the count of intersections
</span>      count = count + <span class="number">1</span>
    <span class="keyword">end</span>

    i = <span class="global">next</span>
  <span class="keyword">until</span> i == <span class="number">1</span>

  <span class="comment">-- Return <code>true</code> if count is odd, <code>false</code> otherwise. If the count of intersections is odd, the point is inside.
</span>  <span class="keyword">return</span> (count % <span class="number">2</span>) == <span class="number">1</span>
<span class="keyword">end</span>

<span class="comment">--- Determine the Direction of Turn for Three Ordered Points.
</span><span class="comment">--
</span><span class="comment">-- Computes the direction of a turn for three ordered points. It can be clockwise, counterclockwise, or the points can be collinear.
</span><span class="comment">--
</span><span class="comment">-- @param a First point, a table with 'x' and 'y' attributes.
</span><span class="comment">-- @param b Second point, a table with 'x' and 'y' attributes.
</span><span class="comment">-- @param c Third point, a table with 'x' and 'y' attributes.
</span><span class="comment">-- @return 0 if the points are collinear
</span><span class="comment">-- @return 1 if the direction is clockwise
</span><span class="comment">-- @return 2 if the direction is counterclockwise
</span><a id="501"></a><span class="comment">-- @usage local dir = SPECTRE.POLY.direction({x=0, y=0}, {x=1, y=1}, {x=2, y=2}) -- Returns 0 as the points are collinear.
</span><span class="keyword">function</span> SPECTRE.POLY.direction(a, b, c)
  <span class="keyword">local</span> val = (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y)

  <span class="comment">-- Check if the points are collinear
</span>  <span class="keyword">if</span> val == <span class="number">0</span> <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="number">0</span>
      <span class="comment">-- Check if the direction is counterclockwise
</span>  <span class="keyword">elseif</span> val &lt; <span class="number">0</span> <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="number">2</span>
      <span class="comment">-- If not collinear and not counterclockwise, then it's clockwise
</span>  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="number">1</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Calculate the Dot Product of Two Vectors.
</span><span class="comment">--
</span><span class="comment">-- Computes the dot product of two vectors given their 'x' and 'y' components.
</span><span class="comment">--
</span><span class="comment">-- @param ax The 'x' component of the first vector.
</span><span class="comment">-- @param ay The 'y' component of the first vector.
</span><span class="comment">-- @param bx The 'x' component of the second vector.
</span><span class="comment">-- @param by The 'y' component of the second vector.
</span><span class="comment">-- @return number The dot product of the two vectors.
</span><a id="526"></a><span class="comment">-- @usage local product = SPECTRE.POLY.dot(1, 2, 3, 4) -- Calculates the dot product of vectors (1,2) and (3,4).
</span><span class="keyword">function</span> SPECTRE.POLY.dot(ax, ay, bx, by)
  <span class="comment">-- Return the dot product of the two vectors
</span>  <span class="keyword">return</span> ax * bx + ay * by
<span class="keyword">end</span>

<span class="comment">--- Shape.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with Closed Shape operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.POLY
</span>


<span class="comment">--- Convert a Polygonal Zone into a List of Line Segments.
</span><span class="comment">--
</span><span class="comment">-- Takes a zone represented as a list of points and converts it into a list of line segments.
</span><span class="comment">--
</span><span class="comment">-- @param zone A list of points representing the polygonal zone. Each point is a table with 'x' and 'y' attributes.
</span><span class="comment">-- @return lines A list of line segments. Each line segment is represented by two points (start and end).
</span><a id="548"></a><span class="comment">-- @usage local lines = SPECTRE.POLY.convertZoneToLines({{x=0, y=0}, {x=10, y=0}, {x=10, y=10}, {x=0, y=10}}) -- Converts a square zone into its four edges.
</span><span class="keyword">function</span> SPECTRE.POLY.convertZoneToLines(zone)
  <span class="keyword">local</span> lines = {}

  <span class="comment">-- Iterate through the points in the zone
</span>  <span class="keyword">for</span> i = <span class="number">1</span>, #zone <span class="keyword">do</span>
    <span class="comment">-- Determine the next point (if the current point is the last one, the next is the first)
</span>    <span class="keyword">local</span> nextIndex = (i == #zone) <span class="keyword">and</span> <span class="number">1</span> <span class="keyword">or</span> (i + <span class="number">1</span>)

    <span class="comment">-- Create a line segment between the current point and the next point
</span>    <span class="global">table</span>.insert(lines, {{x = zone[i].x, y = zone[i].y}, {x = zone[nextIndex].x, y = zone[nextIndex].y}})
  <span class="keyword">end</span>

  <span class="keyword">return</span> lines
<span class="keyword">end</span>

<span class="comment">--- Ensure a Quadrilateral is Convex.
</span><span class="comment">--
</span><span class="comment">-- Adjusts a quadrilateral to ensure that it is convex by checking the cross products of consecutive vertices. If necessary, it swaps the last two vertices.
</span><span class="comment">--
</span><span class="comment">-- @param zoneCoords A list of four points representing the quadrilateral. Each point is a table with 'x' and 'y' attributes.
</span><span class="comment">-- @return zoneCoords The possibly adjusted list of four points ensuring the quadrilateral is convex.
</span><a id="570"></a><span class="comment">-- @usage local convexZone = SPECTRE.POLY.ensureConvex({{x=0, y=0}, {x=10, y=0}, {x=10, y=10}, {x=0, y=10}}) -- Adjusts the zone to ensure it's convex.
</span><span class="keyword">function</span> SPECTRE.POLY.ensureConvex(zoneCoords)
  <span class="comment">-- Calculate the signs of the cross products of consecutive vertices
</span>  <span class="keyword">local</span> signs = {
    SPECTRE.POLY:crossProduct(zoneCoords[<span class="number">1</span>], zoneCoords[<span class="number">2</span>], zoneCoords[<span class="number">3</span>]) &gt;= <span class="number">0</span>,
    SPECTRE.POLY:crossProduct(zoneCoords[<span class="number">2</span>], zoneCoords[<span class="number">3</span>], zoneCoords[<span class="number">4</span>]) &gt;= <span class="number">0</span>,
    SPECTRE.POLY:crossProduct(zoneCoords[<span class="number">3</span>], zoneCoords[<span class="number">4</span>], zoneCoords[<span class="number">1</span>]) &gt;= <span class="number">0</span>,
    SPECTRE.POLY:crossProduct(zoneCoords[<span class="number">4</span>], zoneCoords[<span class="number">1</span>], zoneCoords[<span class="number">2</span>]) &gt;= <span class="number">0</span>
  }

  <span class="comment">-- If the signs are not consistent, swap the last two vertices
</span>  <span class="keyword">if</span> <span class="keyword">not</span> (signs[<span class="number">1</span>] == signs[<span class="number">2</span>] <span class="keyword">and</span> signs[<span class="number">2</span>] == signs[<span class="number">3</span>] <span class="keyword">and</span> signs[<span class="number">3</span>] == signs[<span class="number">4</span>]) <span class="keyword">then</span>
    zoneCoords[<span class="number">3</span>], zoneCoords[<span class="number">4</span>] = zoneCoords[<span class="number">4</span>], zoneCoords[<span class="number">3</span>]
  <span class="keyword">end</span>

  <span class="keyword">return</span> zoneCoords
<span class="keyword">end</span>

<span class="comment">--- Calculates the area of a polygon.
</span><span class="comment">-- @param coords ipairs vec2 table
</span><a id="590"></a><span class="comment">-- @return area
</span><span class="keyword">function</span> SPECTRE.POLY.polygonArea(coords)
  <span class="keyword">local</span> n = #coords
  <span class="keyword">local</span> area = <span class="number">0</span>
  <span class="keyword">for</span> i=<span class="number">1</span>, n-<span class="number">1</span> <span class="keyword">do</span>
    area = area + coords[i].x * coords[i+<span class="number">1</span>].y - coords[i+<span class="number">1</span>].x * coords[i].y
  <span class="keyword">end</span>
  area = area + coords[n].x * coords[<span class="number">1</span>].y - coords[<span class="number">1</span>].x * coords[n].y
  <span class="keyword">return</span> <span class="number">0.5</span> * <span class="global">math</span>.abs(area)
<span class="keyword">end</span>

<span class="comment">--- Triangulate a Quadrilateral into Two Triangles.
</span><span class="comment">--
</span><span class="comment">-- Takes a 4-point polygon (quadrilateral) and splits it into two triangles.
</span><span class="comment">--
</span><span class="comment">-- @param zoneCoords A list of four points representing the quadrilateral. Each point is a table with 'x' and 'y' attributes.
</span><span class="comment">-- @return table A list containing two triangles formed from the quadrilateral. {[1] = triangle1,[2] = triangle2,}
</span><span class="comment">-- @return error An error message if the input does not represent a 4-point polygon.
</span><a id="608"></a><span class="comment">-- @usage local triangles = SPECTRE.POLY.triangulateZone({{x=0, y=0}, {x=10, y=0}, {x=10, y=10}, {x=0, y=10}}) -- Splits the square into two triangles.
</span><span class="keyword">function</span> SPECTRE.POLY.triangulateZone(zoneCoords)
  <span class="comment">-- Ensure we have a 4-point zone
</span>  <span class="keyword">if</span> #zoneCoords ~= <span class="number">4</span> <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="keyword">nil</span>, <span class="string">"Expected a 4-point polygon"</span>
  <span class="keyword">end</span>
  <span class="comment">-- Create the first triangle using the first three points of the zone
</span>  <span class="keyword">local</span> triangle1 = {
    [<span class="number">1</span>] = zoneCoords[<span class="number">1</span>],
    [<span class="number">2</span>] = zoneCoords[<span class="number">2</span>],
    [<span class="number">3</span>] = zoneCoords[<span class="number">3</span>],
  }
  <span class="comment">-- Create the second triangle using the first, third, and fourth points of the zone
</span>  <span class="keyword">local</span> triangle2 = {
    [<span class="number">1</span>] = zoneCoords[<span class="number">1</span>],
    [<span class="number">2</span>] = zoneCoords[<span class="number">3</span>],
    [<span class="number">3</span>] = zoneCoords[<span class="number">4</span>],
  }
  <span class="comment">-- Return the two triangles
</span>  <span class="keyword">return</span> {
    [<span class="number">1</span>] = triangle1,
    [<span class="number">2</span>] = triangle2,
  }
<span class="keyword">end</span>

<span class="comment">--- Determine if a Point is Inside a Polygon using Crossings Multiply Test.
</span><span class="comment">--
</span><span class="comment">-- Uses the crossings or even-odd rule method to determine if a given point, specified by its 'x' and 'y' coordinates, lies inside the polygon 'pgon'.
</span><span class="comment">--
</span><span class="comment">-- @param pgon A list of points representing the polygon vertices in order. Each point is a table with 'x' and 'y' attributes.
</span><span class="comment">-- @param tx The 'x' coordinate of the point to check.
</span><span class="comment">-- @param ty The 'y' coordinate of the point to check.
</span><span class="comment">-- @return boolean 'true' if the point is inside the polygon, 'false' otherwise.
</span><a id="641"></a><span class="comment">-- @usage local insidePolygon = SPECTRE.POLY.CrossingsMultiplyTest({{x=0, y=0}, {x=10, y=0}, {x=10, y=10}, {x=0, y=10}}, 5, 5) -- Returns 'true' as the point is inside the square.
</span><span class="keyword">function</span> SPECTRE.POLY.CrossingsMultiplyTest(pgon, tx, ty)
  <span class="keyword">local</span> numverts = #pgon              <span class="comment">-- Get the number of vertices in the polygon
</span>  <span class="keyword">local</span> inside_flag = <span class="keyword">false</span>           <span class="comment">-- Initialize the flag for the point being inside the polygon
</span>  <span class="keyword">local</span> yflag0 = (pgon[numverts].y &gt;= ty)  <span class="comment">-- Determine if the last vertex is above the test point
</span>  <span class="comment">-- Loop through each vertex of the polygon
</span>  <span class="keyword">for</span> i = <span class="number">1</span>, numverts <span class="keyword">do</span>
    <span class="keyword">local</span> vtx0 = pgon[i]
    <span class="keyword">local</span> vtx1 = pgon[i % numverts + <span class="number">1</span>]
    <span class="keyword">local</span> yflag1 = (vtx1.y &gt;= ty)
    <span class="comment">-- Check if the edge from the current vertex to the next vertex crosses the horizontal line through the test point
</span>    <span class="keyword">if</span> yflag0 ~= yflag1 <span class="keyword">then</span>
      <span class="comment">-- Check if the test point is to the left of the edge
</span>      <span class="keyword">if</span> ((vtx1.y - ty) * (vtx0.x - vtx1.x) &gt;= (vtx1.x - tx) * (vtx0.y - vtx1.y)) == yflag1 <span class="keyword">then</span>
        inside_flag = <span class="keyword">not</span> inside_flag   <span class="comment">-- Toggle the inside flag
</span>      <span class="keyword">end</span>
    <span class="keyword">end</span>
    yflag0 = yflag1  <span class="comment">-- Update yflag0 for the next iteration
</span>  <span class="keyword">end</span>
  <span class="comment">-- Return the result
</span>  <span class="keyword">return</span> inside_flag
<span class="keyword">end</span>

<span class="comment">--- Generates a list of subcircles within a main circle while avoiding overlaps.
</span><span class="comment">--
</span><span class="comment">-- OLD FUNCTION. Kept for later updates. Good Version is built into <code>SPECTRE.SPAWNER.generateSubZoneCircles</code>
</span><span class="comment">--
</span><span class="comment">-- This function generates a list of subcircles within a main circle defined by <code>mainCircleSize</code> and <code>mainCircleVec2</code>. It aims to create <code>numSubCircles</code> subcircles with a minimum size of <code>subCircleMinSize</code>. The generated subcircles are guaranteed not to overlap with each other or extend beyond the boundaries of the main circle.
</span><span class="comment">--
</span><span class="comment">-- @param mainCircleSize The size (diameter) of the main circle.
</span><span class="comment">-- @param mainCircleVec2 The center coordinates of the main circle.
</span><span class="comment">-- @param numSubCircles The desired number of subcircles to generate.
</span><span class="comment">-- @param subCircleMinSize The minimum size (diameter) of each subcircle.
</span><a id="674"></a><span class="comment">-- @return table A table containing the generated subcircles, each represented as a table with <code>vec2</code> (center coordinates) and <code>diameter</code> (size) attributes.
</span><span class="keyword">function</span> SPECTRE.POLY.generateSubCircles(mainCircleSize, mainCircleVec2, numSubCircles, subCircleMinSize)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.generateSubCircles | ---------------------- |"</span>)
  <span class="keyword">local</span> generatedSubCircles = {}
  <span class="keyword">local</span> mainRadius = mainCircleSize / <span class="number">2</span>
  <span class="keyword">local</span> attempts = <span class="number">0</span> <span class="comment">-- to prevent infinite loops
</span>
  <span class="keyword">while</span> #generatedSubCircles &lt; numSubCircles <span class="keyword">and</span> attempts &lt; numSubCircles * <span class="number">100</span> <span class="keyword">do</span>
    <span class="keyword">local</span> subCircle = {}
    <span class="keyword">local</span> subRadius

    subRadius = <span class="global">math</span>.random(subCircleMinSize / <span class="number">2</span>, mainRadius) / <span class="number">2</span>
    <span class="keyword">local</span> angle = <span class="global">math</span>.random() * <span class="number">2</span> * <span class="global">math</span>.pi
    <span class="keyword">local</span> maxDistFromCenter = mainRadius - subRadius
    <span class="keyword">local</span> minDistFromCenter = subRadius
    <span class="keyword">local</span> distFromCenter = <span class="global">math</span>.random(minDistFromCenter, maxDistFromCenter)

    subCircle.vec2 = {
      x = mainCircleVec2.x + distFromCenter * <span class="global">math</span>.cos(angle),
      y = mainCircleVec2.y + distFromCenter * <span class="global">math</span>.sin(angle)
    }

    subCircle.diameter = subRadius * <span class="number">2</span>
    <span class="keyword">if</span> SPECTRE.POLY.isSubCircleValid(subCircle, generatedSubCircles, mainCircleVec2, mainRadius) <span class="keyword">then</span>
      <span class="global">table</span>.insert(generatedSubCircles, subCircle)
    <span class="keyword">end</span>
    attempts = attempts + <span class="number">1</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> generatedSubCircles
<span class="keyword">end</span>
<span class="comment">--- Checks if a subcircle is valid based on a threshold for overlapping with other subcircles and being within the main circle's boundaries.
</span><span class="comment">--
</span><span class="comment">-- This function determines the validity of a <code>subCircle</code> by considering whether it overlaps with any of the <code>generatedSubCircles</code> beyond the specified <code>threshold</code>. Additionally, it checks if the <code>subCircle</code> remains within the boundaries of the main circle defined by <code>mainCircleVec2</code> and <code>mainRadius</code>.
</span><span class="comment">--
</span><span class="comment">-- @param subCircle The subcircle to validate.
</span><span class="comment">-- @param generatedSubCircles A list of already generated subcircles to compare against.
</span><span class="comment">-- @param mainCircleVec2 The center coordinates of the main circle.
</span><span class="comment">-- @param mainRadius The radius of the main circle.
</span><span class="comment">-- @param threshold The allowed threshold for overlapping (0 to 1).
</span><a id="713"></a><span class="comment">-- @return boolean Returns true if the subcircle is valid; otherwise, false.
</span><span class="keyword">function</span> SPECTRE.POLY.isSubCircleValid(subCircle, generatedSubCircles, mainCircleVec2, mainRadius)
  <span class="keyword">for</span> _, existingSubCircle <span class="keyword">in</span> <span class="global">ipairs</span>(generatedSubCircles) <span class="keyword">do</span>
    <span class="keyword">if</span> SPECTRE.POLY.doesCircleOverlap(subCircle, existingSubCircle) <span class="keyword">then</span>
      <span class="keyword">return</span> <span class="keyword">false</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> SPECTRE.POLY.isWithinMainCircle(subCircle, mainCircleVec2, mainRadius)
<span class="keyword">end</span>
<span class="comment">--- Checks if a subcircle is completely within the boundaries of the main circle.
</span><span class="comment">--
</span><span class="comment">-- This function verifies whether the given <code>subCircle</code> is entirely contained within the main circle defined by <code>mainCircleVec2</code> and <code>mainRadius</code>.
</span><span class="comment">--
</span><span class="comment">-- @param subCircle The subcircle to check.
</span><span class="comment">-- @param mainCircleVec2 The center coordinates of the main circle.
</span><span class="comment">-- @param mainRadius The radius of the main circle.
</span><a id="729"></a><span class="comment">-- @return boolean Returns true if the subcircle is entirely within the main circle; otherwise, false.
</span><span class="keyword">function</span> SPECTRE.POLY.isSubCircleValidThreshold(subCircle, generatedSubCircles, mainCircleVec2, mainRadius, threshold)
  <span class="keyword">for</span> _, existingSubCircle <span class="keyword">in</span> <span class="global">ipairs</span>(generatedSubCircles) <span class="keyword">do</span>
    <span class="keyword">if</span> SPECTRE.POLY.doesCircleOverlapThreshold(subCircle, existingSubCircle, threshold) <span class="keyword">then</span>
      <span class="keyword">return</span> <span class="keyword">false</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> SPECTRE.POLY.isWithinMainCircleThreshold(subCircle, mainCircleVec2, mainRadius, threshold)
<span class="keyword">end</span>

<span class="comment">--- Checks if a subcircle is within the boundaries of the main circle with a specified threshold.
</span><span class="comment">--
</span><span class="comment">-- This function evaluates whether the <code>subCircle</code> remains within the main circle defined by <code>mainCircleVec2</code> and <code>mainRadius</code>, considering a specified <code>threshold</code>. The <code>threshold</code> allows for some degree of overlap with the main circle.
</span><span class="comment">--
</span><span class="comment">-- @param subCircle The subcircle to check.
</span><span class="comment">-- @param mainCircleVec2 The center coordinates of the main circle.
</span><span class="comment">-- @param mainRadius The radius of the main circle.
</span><span class="comment">-- @param threshold The threshold for allowed overlap (0 to 1).
</span><a id="747"></a><span class="comment">-- @return boolean Returns true if the subcircle is within the main circle with the given threshold; otherwise, false.
</span><span class="keyword">function</span> SPECTRE.POLY.isWithinMainCircle(subCircle, mainCircleVec2, mainRadius)
  <span class="keyword">local</span> dx = subCircle.vec2.x - mainCircleVec2.x
  <span class="keyword">local</span> dy = subCircle.vec2.y - mainCircleVec2.y
  <span class="keyword">local</span> distanceToCenter = <span class="global">math</span>.sqrt(dx * dx + dy * dy)
  <span class="keyword">return</span> distanceToCenter + subCircle.diameter / <span class="number">2</span> &lt;= mainRadius
<span class="keyword">end</span>
<span class="comment">--- Checks if two circles overlap.
</span><span class="comment">--
</span><span class="comment">-- This function determines whether two circles defined by <code>subCircle1</code> and <code>subCircle2</code> overlap with each other.
</span><span class="comment">--
</span><span class="comment">-- @param subCircle1 The first circle to check for overlap.
</span><span class="comment">-- @param subCircle2 The second circle to check for overlap.
</span><a id="760"></a><span class="comment">-- @return boolean Returns true if the circles overlap; otherwise, false.
</span><span class="keyword">function</span> SPECTRE.POLY.isWithinMainCircleThreshold(subCircle, mainCircleVec2, mainRadius, threshold)
  <span class="keyword">local</span> dx = subCircle.vec2.x - mainCircleVec2.x
  <span class="keyword">local</span> dy = subCircle.vec2.y - mainCircleVec2.y
  <span class="keyword">local</span> distanceToCenter = <span class="global">math</span>.sqrt(dx * dx + dy * dy)
  <span class="keyword">local</span> allowedOutside = subCircle.diameter / <span class="number">2</span> * threshold
  <span class="keyword">return</span> distanceToCenter + subCircle.diameter / <span class="number">2</span> - allowedOutside &lt;= mainRadius
<span class="keyword">end</span>
<span class="comment">--- Checks if two circles overlap.
</span><span class="comment">--
</span><span class="comment">-- This function determines whether two circles defined by <code>subCircle1</code> and <code>subCircle2</code> overlap with each other.
</span><span class="comment">--
</span><span class="comment">-- @param subCircle1 The first circle to check for overlap.
</span><span class="comment">-- @param subCircle2 The second circle to check for overlap.
</span><a id="774"></a><span class="comment">-- @return boolean Returns true if the circles overlap; otherwise, false.
</span><span class="keyword">function</span> SPECTRE.POLY.doesCircleOverlap(subCircle1, subCircle2)
  <span class="keyword">local</span> dx = subCircle1.vec2.x - subCircle2.vec2.x
  <span class="keyword">local</span> dy = subCircle1.vec2.y - subCircle2.vec2.y
  <span class="keyword">local</span> distanceBetweenCenters = <span class="global">math</span>.sqrt(dx * dx + dy * dy)
  <span class="keyword">return</span> distanceBetweenCenters &lt; (subCircle1.diameter / <span class="number">2</span> + subCircle2.diameter / <span class="number">2</span>)
<span class="keyword">end</span>
<span class="comment">--- Checks if two circles overlap with a specified threshold.
</span><span class="comment">--
</span><span class="comment">-- This function assesses whether two circles defined by <code>subCircle1</code> and <code>subCircle2</code> overlap with each other while considering a specified <code>threshold</code>. The <code>threshold</code> allows for some degree of non-overlapping.
</span><span class="comment">--
</span><span class="comment">-- @param subCircle1 The first circle to check for overlap.
</span><span class="comment">-- @param subCircle2 The second circle to check for overlap.
</span><span class="comment">-- @param threshold The threshold for allowed overlap (0 to 1).
</span><a id="788"></a><span class="comment">-- @return boolean Returns true if the circles overlap within the given threshold; otherwise, false.
</span><span class="keyword">function</span> SPECTRE.POLY.doesCircleOverlapThreshold(subCircle1, subCircle2, threshold)
  <span class="keyword">local</span> dx = subCircle1.vec2.x - subCircle2.vec2.x
  <span class="keyword">local</span> dy = subCircle1.vec2.y - subCircle2.vec2.y
  <span class="keyword">local</span> distanceBetweenCenters = <span class="global">math</span>.sqrt(dx * dx + dy * dy)
  <span class="keyword">local</span> allowedOverlap = (subCircle1.diameter / <span class="number">2</span> + subCircle2.diameter / <span class="number">2</span>) * (<span class="number">1</span> - threshold)
  <span class="keyword">return</span> distanceBetweenCenters &lt; allowedOverlap
<span class="keyword">end</span>

<span class="comment">--- Shrinks a polygon's boundaries by given distance.
</span><span class="comment">-- @param polygon vec2 ipair
</span><span class="comment">-- @param shrinkDistance
</span><a id="800"></a><span class="comment">-- @return shrunkenPolygon
</span><span class="keyword">function</span> SPECTRE.POLY.getShrunkenPolygon(polygon, shrinkDistance)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.getShrunkenPolygon | ------- "</span>, polygon)
  SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.getShrunkenPolygon | shrinkDistance "</span> ..  shrinkDistance)
  <span class="comment">-- This function will calculate the shrunken polygon vertices.
</span>  <span class="comment">-- For each edge, move the edge towards the inside of the polygon by shrinkDistance.
</span>  <span class="comment">-- This is a simplified version and does not handle cases where the polygon collapses.
</span>  <span class="keyword">local</span> shrunkenPolygon = {}
  <span class="keyword">for</span> i = <span class="number">1</span>, #polygon <span class="keyword">do</span>
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.getShrunkenPolygon | i "</span> ..  i)
    <span class="keyword">local</span> j = (i % #polygon) + <span class="number">1</span>
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.getShrunkenPolygon | j "</span> ..  j)
    <span class="comment">-- Calculate the direction vector for the edge.
</span>    <span class="keyword">local</span> dirVec = {x = polygon[j].y - polygon[i].y, y = polygon[i].x - polygon[j].x}
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.getShrunkenPolygon | dirVec.x "</span> ..  dirVec.x)
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.getShrunkenPolygon | dirVec.y "</span> ..  dirVec.y)
    <span class="comment">-- Normalize the direction vector.
</span>    <span class="keyword">local</span> length = <span class="global">math</span>.sqrt(dirVec.x * dirVec.x + dirVec.y * dirVec.y)
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.getShrunkenPolygon | length "</span> ..  length)
    dirVec.x = (dirVec.x / length) * shrinkDistance
    dirVec.y = (dirVec.y / length) * shrinkDistance
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.getShrunkenPolygon | NORM dirVec.x "</span> ..  dirVec.x)
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.getShrunkenPolygon | NORM dirVec.y "</span> ..  dirVec.y)
    <span class="comment">-- Move the vertices towards the inside of the polygon by the shrinkDistance.
</span>    shrunkenPolygon[i] = {x = polygon[i].x + dirVec.x, y = polygon[i].y + dirVec.y}
    shrunkenPolygon[j] = {x = polygon[j].x + dirVec.x, y = polygon[j].y + dirVec.y}
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.getShrunkenPolygon | shrunkenPolygon[i] "</span> ,  shrunkenPolygon[i])
    SPECTRE.UTILS.debugInfo(<span class="string">"SPECTRE.POLY.getShrunkenPolygon | shrunkenPolygon[j] "</span> ,  shrunkenPolygon[j])
  <span class="keyword">end</span>
  <span class="keyword">return</span> shrunkenPolygon
<span class="keyword">end</span>

<span class="comment">--- Gets min and max distance across a polygon.
</span><span class="comment">-- @param polygon vec2 ipair
</span><a id="834"></a><span class="comment">-- @return minDistance, maxDistance
</span><span class="keyword">function</span> SPECTRE.POLY.getMinMaxDistances(polygon)
  <span class="keyword">local</span> minDistance = <span class="global">math</span>.huge <span class="comment">-- Start with the largest possible value.
</span>  <span class="keyword">local</span> maxDistance = <span class="number">0</span> <span class="comment">-- Start with the smallest possible value.
</span>  <span class="keyword">local</span> <span class="keyword">function</span> distanceBetweenPoints(p1, p2)
    <span class="keyword">local</span> dx = p1.x - p2.x
    <span class="keyword">local</span> dy = p1.y - p2.y
    <span class="keyword">return</span> <span class="global">math</span>.sqrt(dx * dx + dy * dy)
  <span class="keyword">end</span>
  <span class="keyword">for</span> i = <span class="number">1</span>, #polygon <span class="keyword">do</span>
    <span class="keyword">for</span> j = i + <span class="number">2</span>, #polygon <span class="keyword">do</span> <span class="comment">-- i + 2 to skip adjacent vertices.
</span>      <span class="keyword">if</span> j ~= i <span class="keyword">and</span> (j ~= i + <span class="number">1</span>) <span class="keyword">and</span> (i ~= <span class="number">1</span> <span class="keyword">or</span> j ~= #polygon) <span class="keyword">then</span> <span class="comment">-- Exclude the edges of the polygon.
</span>        <span class="keyword">local</span> dist = distanceBetweenPoints(polygon[i], polygon[j])
        minDistance = <span class="global">math</span>.min(minDistance, dist)
        maxDistance = <span class="global">math</span>.max(maxDistance, dist)
    <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> minDistance, maxDistance
<span class="keyword">end</span></pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2023-11-20 11:04:26 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
