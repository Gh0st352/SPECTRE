<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>S.P.E.C.T.R.E.</h1>


<ul>
  <li><a href="../manual.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="nowrap">
  <li><strong>ai.lua</strong></li>
  <li><a href="../source/brain.lua.html">brain.lua</a></li>
  <li><a href="../source/handlers.lua.html">handlers.lua</a></li>
  <li><a href="../source/iads.lua.html">iads.lua</a></li>
  <li><a href="../source/io.lua.html">io.lua</a></li>
  <li><a href="../source/markers.lua.html">markers.lua</a></li>
  <li><a href="../source/menu.lua.html">menu.lua</a></li>
  <li><a href="../source/plyrmgr.lua.html">plyrmgr.lua</a></li>
  <li><a href="../source/poly.lua.html">poly.lua</a></li>
  <li><a href="../source/rewards.lua.html">rewards.lua</a></li>
  <li><a href="../source/spawner.lua.html">spawner.lua</a></li>
  <li><a href="../source/spectre.lua.html">spectre.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/world.lua.html">world.lua</a></li>
  <li><a href="../source/zonemgr.lua.html">zonemgr.lua</a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/AI.html">AI</a></li>
  <li><a href="../modules/BRAIN.html">BRAIN</a></li>
  <li><a href="../modules/HANDLERS.html">HANDLERS</a></li>
  <li><a href="../modules/IADS.html">IADS</a></li>
  <li><a href="../modules/IO.html">IO</a></li>
  <li><a href="../modules/MARKERS.html">MARKERS</a></li>
  <li><a href="../modules/MENU.html">MENU</a></li>
  <li><a href="../modules/PLYRMGR.html">PLYRMGR</a></li>
  <li><a href="../modules/POLY.html">POLY</a></li>
  <li><a href="../modules/REWARDS.html">REWARDS</a></li>
  <li><a href="../modules/SPAWNER.html">SPAWNER</a></li>
  <li><a href="../modules/SPECTRE.html">SPECTRE</a></li>
  <li><a href="../modules/UTILS.html">UTILS</a></li>
  <li><a href="../modules/WORLD.html">WORLD</a></li>
  <li><a href="../modules/ZONEMGR.html">ZONEMGR</a></li>
</ul>
<h2>Topics</h2>
<ul class="">
  <li><a href="../topics/readme.md.html">readme</a></li>
</ul>

</div>

<div id="content">

    <h2>ai.lua</h2>
<pre>
<span class="comment">--- **AI**
</span><span class="comment">--
</span><span class="comment">-- Automated AI Handling.
</span><span class="comment">--
</span><span class="comment">--  ***Dynamic AI Management for SPECTRE.***
</span><span class="comment">--
</span><span class="comment">--   * The AI Class.
</span><span class="comment">--
</span><span class="comment">--   * All aspects of the AI are accessed via this class.
</span><span class="comment">--
</span><span class="comment">--     -- Dynamic Management of DCS AI Units.
</span><span class="comment">--     -- Enables AI-driven operations within the SPECTRE framework.
</span><span class="comment">--     -- Provides functions for AI route planning, waypoint generation, and mission configurations.
</span><span class="comment">--     -- Ensures AI entities operate seamlessly within the SPECTRE environment.
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- @module AI
</span><span class="comment">-- @extends SPECTRE
</span>
<span class="comment">--- SPECTRE.AI.
</span><span class="comment">--
</span><span class="comment">-- Core module for handling AI-driven operations within the SPECTRE framework.
</span><span class="comment">--
</span><span class="comment">-- This module facilitates the generation and management of AI entities, ensuring they operate seamlessly within the SPECTRE environment. Functions include route planning, waypoint generation, and AI mission configurations, allowing for robust and dynamic AI behaviors on the battlefield.
</span><span class="comment">--
</span><span class="comment">-- @section AI
</span><span class="comment">-- @field #AI
</span>SPECTRE.AI = {}

<span class="comment">--- Common.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions commonly associated with AI operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.AI
</span>
<span class="comment">--- Configure Common Options for a Spawn Group.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Sets a series of common options for the given spawn group.
</span><span class="comment">-- The function configures the behavior of the spawn group in various combat scenarios, such as rules of engagement,
</span><span class="comment">-- weapon usage, evasion, fuel management, and communication systems.
</span><span class="comment">--
</span><span class="comment">-- @param spawnGroup_ The spawn group to be configured.
</span><span class="comment">-- @return #spawnGroup_ The configured spawn group.
</span><a id="50"></a><span class="comment">-- @usage local configuredGroup = SPECTRE.AI.configureCommonOptions(spawnGroup)
</span><span class="keyword">function</span> SPECTRE.AI.configureCommonOptions(spawnGroup_)
  <span class="comment">-- Set the group to open fire on sight
</span>  spawnGroup_:OptionROEOpenFire()

  <span class="comment">-- Set the group to evade when under fire
</span>  spawnGroup_:OptionROTEvadeFire()

  <span class="comment">-- Allow the group to jettison weapons when threatened
</span>  spawnGroup_:OptionAllowJettisonWeaponsOnThreat()

  <span class="comment">-- Do not force the group to return to base when low on fuel
</span>  spawnGroup_:OptionRTBBingoFuel(<span class="keyword">false</span>)

  <span class="comment">-- Do not restrict the use of afterburners
</span>  spawnGroup_:OptionRestrictBurner(<span class="keyword">false</span>)

  <span class="comment">-- Allow the group to freely engage targets if possible
</span>  spawnGroup_:OptionROEWeaponFreePossible(<span class="keyword">true</span>)

  <span class="comment">-- Enable EPLRS (Enhanced Position Location Reporting System) for the group
</span>  spawnGroup_:CommandEPLRS(<span class="keyword">true</span>)

  <span class="keyword">return</span> spawnGroup_
<span class="keyword">end</span>

<span class="comment">--- Set Common Event Handlers for a Spawn Group.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Configures common event handlers for the given spawn group, reacting to landing, crashing, and dying events.
</span><span class="comment">-- The function sets up event handlers for the spawn group to handle various scenarios such as landing, crashing, and dying.
</span><span class="comment">-- It also manages restocking through the provided manager and displays messages to the coalition when certain events occur.
</span><span class="comment">--
</span><span class="comment">-- @param spawnGroup_ The spawn group to set event handlers for.
</span><span class="comment">-- @param MANAGER The manager responsible for scheduling restocks.
</span><span class="comment">-- @param Packet Packet data containing the Marker ID.
</span><span class="comment">-- @param messageOnLand Message to display when the group lands.
</span><span class="comment">-- @param messageOnDead Message to display when the group is dead or crashes.
</span><span class="comment">-- @return #spawnGroup_ The spawn group with configured event handlers.
</span><a id="90"></a><span class="comment">-- @usage local eventConfiguredGroup = SPECTRE.AI.setCommonEventHandlers(spawnGroup, managerInstance, packetData, "Landed!", "Dead!")
</span><span class="keyword">function</span> SPECTRE.AI.setCommonEventHandlers(spawnGroup_, MANAGER, Packet, messageOnLand, messageOnDead)
  spawnGroup_.WIPE_ = <span class="keyword">false</span>

  <span class="comment">-- Common function to handle both landing and dead/crash events
</span>  <span class="keyword">local</span> <span class="keyword">function</span> handleEvent(_, eventData, message)
    <span class="keyword">local</span> coal = eventData.IniCoalition
    <span class="keyword">if</span> spawnGroup_:CountAliveUnits() == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> spawnGroup_.WIPE_ <span class="keyword">then</span>
      spawnGroup_.WIPE_ = <span class="keyword">true</span>
      MESSAGE:New(message, <span class="number">20</span>, <span class="string">"NOTICE"</span>):ToCoalition(coal)
      SPECTRE.MARKERS.World.RemoveByID(Packet.MarkerID)
      MANAGER:scheduleRestock(coal, Packet.Type)
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  spawnGroup_.onGroupLand = <span class="keyword">function</span>(_, eventData)
    handleEvent(_, eventData, messageOnLand)
  <span class="keyword">end</span>

  spawnGroup_.onGroupCrashOrDead = <span class="keyword">function</span>(_, eventData)
    handleEvent(_, eventData, messageOnDead)
  <span class="keyword">end</span>

  spawnGroup_:HandleEvent(EVENTS.Land, spawnGroup_.onGroupLand)
  spawnGroup_:HandleEvent(EVENTS.Crash, spawnGroup_.onGroupCrashOrDead)
  spawnGroup_:HandleEvent(EVENTS.Dead, spawnGroup_.onGroupCrashOrDead)

  <span class="keyword">return</span> spawnGroup_
<span class="keyword">end</span>


<span class="comment">--- Racetrack.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with Racetrack operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.AI
</span>
<span class="comment">--- Prepare Racetrack Coordinates.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- This function prepares the racetrack coordinates based on the given parameters.
</span><span class="comment">-- It calculates the starting and ending coordinates of a racetrack pattern using the reference coordinate,
</span><span class="comment">-- altitude, heading, distance, and an offset flag. The offset flag determines if the racetrack should be built using <code>SPECTRE.AI.BuildRacetrack</code>.
</span><span class="comment">--
</span><span class="comment">-- @param Coordinate_ The reference coordinate.
</span><span class="comment">-- @param Alt Altitude to be set for the racetrack coordinates.
</span><span class="comment">-- @param heading The heading direction.
</span><span class="comment">-- @param distance Distance for the racetrack translation.
</span><span class="comment">-- @param OFFSET A flag to determine if the racetrack should be built using <code>SPECTRE.AI.BuildRacetrack</code>.
</span><span class="comment">-- @return #RacetrackStart The starting coordinate of the racetrack.
</span><span class="comment">-- @return #RacetrackEnd The ending coordinate of the racetrack.
</span><a id="144"></a><span class="comment">-- @usage local startCoord, endCoord = SPECTRE.AI.prepareRacetrackCoords(referenceCoord, altitude, dir, dist, offsetFlag)
</span><span class="keyword">function</span> SPECTRE.AI.prepareRacetrackCoords(Coordinate_, Alt, heading, distance, OFFSET)
  <span class="comment">-- Create a new coordinate from the provided one and set its altitude
</span>  <span class="keyword">local</span> Cap_Marker_Coord = COORDINATE:NewFromCoordinate(Coordinate_)
  Cap_Marker_Coord.y = Alt

  <span class="keyword">local</span> RacetrackStart, RacetrackEnd
  <span class="keyword">if</span> heading <span class="keyword">and</span> distance <span class="keyword">then</span>
    <span class="comment">-- Calculate the translation distance once for optimization
</span>    <span class="keyword">local</span> translationDistance = UTILS.NMToMeters(distance)

    <span class="comment">-- Determine the start and end of the racetrack based on the heading and distance
</span>    RacetrackStart = Cap_Marker_Coord:Translate(translationDistance, heading, <span class="keyword">true</span>)
    RacetrackEnd = Cap_Marker_Coord:Translate(translationDistance, heading + <span class="number">180</span>, <span class="keyword">true</span>)
  <span class="keyword">else</span>
    <span class="comment">-- If heading or distance is not provided, use the original coordinate as the start
</span>    RacetrackStart = Cap_Marker_Coord
  <span class="keyword">end</span>

  <span class="comment">-- Set the altitude for the racetrack start
</span>  RacetrackStart.y = Alt

  <span class="comment">-- Build the racetrack if the OFFSET flag is set to 1
</span>  <span class="keyword">if</span> OFFSET == <span class="number">1</span> <span class="keyword">then</span>
    RacetrackStart, RacetrackEnd = SPECTRE.AI.BuildRacetrack(RacetrackStart, RacetrackEnd, heading)
  <span class="keyword">end</span>

  <span class="keyword">return</span> RacetrackStart, RacetrackEnd
<span class="keyword">end</span>

<span class="comment">--- Build Racetrack Coordinates.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Adjusts the racetrack's start and end coordinates based on a given heading.
</span><span class="comment">-- The function takes into account the heading direction and adjusts the start and end coordinates accordingly.
</span><span class="comment">--
</span><span class="comment">-- @param RacetrackStart The starting coordinate of the racetrack.
</span><span class="comment">-- @param RacetrackEnd The ending coordinate of the racetrack.
</span><span class="comment">-- @param heading The heading direction.
</span><span class="comment">-- @return #RacetrackStart The adjusted starting coordinate of the racetrack.
</span><span class="comment">-- @return #RacetrackEnd The adjusted ending coordinate of the racetrack.
</span><a id="186"></a><span class="comment">-- @usage local adjustedStart, adjustedEnd = SPECTRE.AI.BuildRacetrack(startCoord, endCoord, dir)
</span><span class="keyword">function</span> SPECTRE.AI.BuildRacetrack(RacetrackStart, RacetrackEnd, heading)
  <span class="keyword">if</span> RacetrackEnd <span class="keyword">then</span>
    <span class="keyword">local</span> offset = UTILS.NMToMeters(<span class="number">8</span>)
    <span class="keyword">local</span> sin_ = <span class="global">math</span>.sin(<span class="global">math</span>.rad(heading))
    <span class="keyword">local</span> cos_ = <span class="global">math</span>.cos(<span class="global">math</span>.rad(heading))
    <span class="keyword">local</span> offX = offset * sin_
    <span class="keyword">local</span> offZ = offset * cos_

    <span class="comment">-- Adjust offsets based on the heading
</span>    <span class="keyword">if</span> heading == <span class="number">0</span> <span class="keyword">or</span> heading == <span class="number">180</span> <span class="keyword">or</span> heading == <span class="number">360</span> <span class="keyword">then</span>
      offX = <span class="number">0</span>
    <span class="keyword">elseif</span> heading == <span class="number">90</span> <span class="keyword">or</span> heading == <span class="number">270</span> <span class="keyword">then</span>
      offZ = <span class="number">0</span>
    <span class="keyword">elseif</span> (heading &gt; <span class="number">0</span> <span class="keyword">and</span> heading &lt; <span class="number">90</span>) <span class="keyword">or</span> (heading &gt; <span class="number">180</span> <span class="keyword">and</span> heading &lt; <span class="number">270</span>) <span class="keyword">then</span>
      offZ = -offZ
    <span class="keyword">end</span>

    <span class="comment">-- Apply the offsets to the racetrack start and end coordinates
</span>    RacetrackStart.x = RacetrackStart.x + offX
    RacetrackStart.z = RacetrackStart.z + offZ
    RacetrackEnd.x = RacetrackEnd.x + offX
    RacetrackEnd.z = RacetrackEnd.z + offZ
  <span class="keyword">end</span>

  <span class="keyword">return</span> RacetrackStart, RacetrackEnd
<span class="keyword">end</span>

<span class="comment">--- Handlers.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Handler operations associated with Racetrack AI.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.AI
</span>
<span class="comment">--- Set Airdrop Event Handlers for a Spawn Group.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Configures event handlers for the given spawn group, reacting to dying events for airdrops.
</span><span class="comment">-- The function sets up an event handler for the spawn group to manage the scenario where an airdrop dies.
</span><span class="comment">-- It manages restocking through the provided manager and displays a message to the coalition when the airdrop is dead.
</span><span class="comment">--
</span><span class="comment">-- @param spawnGroup_ The spawn group to set the event handler for.
</span><span class="comment">-- @param MANAGER The manager responsible for scheduling restocks.
</span><span class="comment">-- @param Packet Packet data containing the Marker ID.
</span><span class="comment">-- @param messageOnDead Message to display when the group is dead.
</span><span class="comment">-- @return #spawnGroup_ The spawn group with the configured event handler.
</span><a id="235"></a><span class="comment">-- @usage local airdropConfiguredGroup = SPECTRE.AI.setAirdropEventHandlers(spawnGroup, managerInstance, packetData, "Dead!")
</span><span class="keyword">function</span> SPECTRE.AI.setAirdropEventHandlers(spawnGroup_, MANAGER, Packet, messageOnDead)
  spawnGroup_.WIPE_ = <span class="keyword">false</span>

  <span class="comment">-- Handle dead event for the spawn group
</span>  spawnGroup_.onGroupCrashOrDead = <span class="keyword">function</span>(_, eventData)
    <span class="keyword">local</span> coal = eventData.IniCoalition
    <span class="keyword">if</span> spawnGroup_:CountAliveUnits() == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> spawnGroup_.WIPE_ <span class="keyword">then</span>
      spawnGroup_.WIPE_ = <span class="keyword">true</span>
      MESSAGE:New(messageOnDead, <span class="number">20</span>, <span class="string">"NOTICE"</span>):ToCoalition(coal)

      <span class="comment">-- Remove marker if it exists
</span>      <span class="keyword">if</span> Packet.MarkerID <span class="keyword">then</span>
        SPECTRE.MARKERS.World.RemoveByID(Packet.MarkerID)
      <span class="keyword">end</span>

      <span class="comment">-- Schedule restock
</span>      MANAGER:scheduleRestock(coal, Packet.Type, Packet.subtype_)
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <span class="comment">-- Set the event handler for the dead event
</span>  spawnGroup_:HandleEvent(EVENTS.Dead, spawnGroup_.onGroupCrashOrDead)

  <span class="keyword">return</span> spawnGroup_
<span class="keyword">end</span>

<span class="comment">--- configureGroup.
</span><span class="comment">--
</span><span class="comment">-- <code>Handles the configuration and setup for AI groups within the SPECTRE framework</code>.
</span><span class="comment">--
</span><span class="comment">--  Manages the configuration, behavior, and settings of AI groups within the SPECTRE framework.
</span><span class="comment">--  This module ensures that AI entities operate according to predefined rules and can be adjusted dynamically.
</span><span class="comment">--
</span><span class="comment">--   * <code>Centralized configuration management for AI groups.</code>
</span><span class="comment">--
</span><span class="comment">--   * <code>Ensures consistent behavior and settings for AI entities.</code>
</span><span class="comment">--
</span><span class="comment">--   * <code>Provides utilities for dynamic AI group adjustments based on scenarios or player actions.</code>
</span><span class="comment">--
</span><span class="comment">-- @section SPECTRE.AI
</span><span class="comment">-- @field #configureGroup
</span>SPECTRE.AI.configureGroup = {}

<span class="comment">--- Configure a CAP Group.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Sets up a Combat Air Patrol (CAP) group by configuring common options, routing it, and adding event handlers.
</span><span class="comment">-- This function provides a comprehensive setup for a CAP group, ensuring that it operates according to desired parameters and behaviors.
</span><span class="comment">-- It combines the application of common configurations, route setting, and event handling for efficient group management.
</span><span class="comment">--
</span><span class="comment">-- @param MANAGER The manager responsible for various operations like restocking.
</span><span class="comment">-- @param spawnGroup_ The spawn group to be configured for CAP.
</span><span class="comment">-- @param route The route for the CAP.
</span><span class="comment">-- @param Packet Packet data containing information like Marker ID.
</span><span class="comment">-- @return #spawnGroup_ The configured spawn group for CAP.
</span><a id="292"></a><span class="comment">-- @usage local capConfiguredGroup = SPECTRE.AI.configureGroup.CAP(managerInstance, spawnGroup, capRoute, packetData)
</span><span class="keyword">function</span> SPECTRE.AI.configureGroup.CAP(MANAGER, spawnGroup_, route, Packet)
  <span class="comment">-- Set common options for the spawn group
</span>  spawnGroup_ = SPECTRE.AI.configureCommonOptions(spawnGroup_)

  <span class="comment">-- Set the route for the CAP group
</span>  spawnGroup_:Route(route, <span class="number">0</span>)

  <span class="comment">-- Define messages for landing and dead events
</span>  <span class="keyword">local</span> messageOnLand = <span class="string">"A custom CAP flight has returned to base! Prepping new assets."</span>
  <span class="keyword">local</span> messageOnDead = <span class="string">"A custom CAP flight has been lost! Prepping new assets."</span>

  <span class="comment">-- Set common event handlers for the CAP group
</span>  spawnGroup_ = SPECTRE.AI.setCommonEventHandlers(spawnGroup_, MANAGER, Packet, messageOnLand, messageOnDead)

  <span class="keyword">return</span> spawnGroup_
<span class="keyword">end</span>

<span class="comment">--- Configure a Bomber Group.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Sets up a bomber group by configuring common options, routing it, and adding event handlers, among other operations.
</span><span class="comment">-- This function provides a detailed setup for a bomber group, ensuring that it operates with desired behaviors.
</span><span class="comment">-- Key aspects of the setup include common configuration, route setting, waypoint tasks, periodic checks for ammunition,
</span><span class="comment">-- and event handling for efficient group management.
</span><span class="comment">--
</span><span class="comment">-- @param MANAGER The manager responsible for various operations like restocking.
</span><span class="comment">-- @param spawnGroup_ The bomber group to be configured.
</span><span class="comment">-- @param route The route for the bomber.
</span><span class="comment">-- @param Packet Packet data containing information like Marker ID.
</span><span class="comment">-- @return The configured bomber group.
</span><a id="324"></a><span class="comment">-- @usage local bomberConfiguredGroup = SPECTRE.AI.configureGroup.BOMBER(managerInstance, bomberGroup, bomberRoute, packetData)
</span><span class="keyword">function</span> SPECTRE.AI.configureGroup.BOMBER(MANAGER, spawnGroup_, route, Packet)
  <span class="comment">-- Set common options for the bomber group
</span>  spawnGroup_ = SPECTRE.AI.configureCommonOptions(spawnGroup_)

  <span class="comment">-- Define and set a task to delete the bomber group on reaching a waypoint
</span>  <span class="keyword">local</span> _DelTask = spawnGroup_:TaskFunction(<span class="string">"SPECTREDeleteOnWP_"</span>, spawnGroup_)
  spawnGroup_:SetTaskWaypoint(route[#route], _DelTask)

  <span class="comment">-- Set the route for the bomber group
</span>  spawnGroup_:Route(route, <span class="number">1</span>)

  <span class="comment">-- Schedule a periodic check for bomber ammunition
</span>  spawnGroup_.ammocheck_  = SCHEDULER:New({spawnGroup_}, <span class="keyword">function</span>()
    SPECTRE.UTILS.debugInfo(<span class="string">"spawnGroup_.ammocheck_"</span>)
 <span class="keyword">if</span> <span class="keyword">not</span> spawnGroup_.InitTime <span class="keyword">then</span> spawnGroup_.InitTime = <span class="global">os</span>.time() <span class="keyword">end</span>
    <span class="keyword">if</span> spawnGroup_ <span class="keyword">then</span>
      <span class="keyword">local</span> BomberAmmo = spawnGroup_:GetAmmunition()
      <span class="keyword">if</span> BomberAmmo == <span class="number">0</span> <span class="keyword">or</span> (<span class="global">os</span>.time - spawnGroup_.InitTime  &gt; <span class="number">600</span>) <span class="keyword">then</span>
        MESSAGE:New(<span class="string">"Bomber is Winchester. RTB for rearm and refuel."</span>, <span class="number">20</span>, <span class="string">"NOTICE"</span>):ToCoalition(Packet.coal)
        spawnGroup_:Destroy(<span class="keyword">false</span>)
        spawnGroup_.ammocheck_:Stop()
        spawnGroup_.ammocheck_ = <span class="keyword">nil</span>
        spawnGroup_ = <span class="keyword">nil</span>
        <span class="global">collectgarbage</span>()
        <span class="global">collectgarbage</span>()
        SPECTRE.MARKERS.World.RemoveByID(Packet.MarkerID)
        MANAGER:scheduleRestock(Packet.coal, Packet.Type)
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>, {}, <span class="number">0</span>, <span class="number">60</span>)

  <span class="comment">-- Define messages for landing and dead events
</span>  <span class="keyword">local</span> messageOnLand = <span class="string">"Custom Bomber flight has returned to base! Prepping new assets."</span>
  <span class="keyword">local</span> messageOnDead = <span class="string">"Custom Bomber flight has been lost! Prepping more assets."</span>

  <span class="comment">-- Set common event handlers for the bomber group
</span>  spawnGroup_ = SPECTRE.AI.setCommonEventHandlers(spawnGroup_, MANAGER, Packet, messageOnLand, messageOnDead)

  <span class="keyword">return</span> spawnGroup_
<span class="keyword">end</span>


<span class="comment">--- Configure a Strike Group.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Sets up a strike group by configuring common options, routing it, checking if it enters a specific zone, and adding event handlers.
</span><span class="comment">-- This function manages the configuration and behavior of a strike group for precise operations.
</span><span class="comment">-- Key aspects of the setup include common configuration, route setting, zone checks for target drops, and event handling.
</span><span class="comment">-- It ensures that the strike group operates effectively, detecting when it enters a designated drop zone, and spawning the designated units at that location.
</span><span class="comment">--
</span><span class="comment">-- @param MANAGER The manager responsible for various operations like restocking.
</span><span class="comment">-- @param spawnGroup_ The strike group to be configured.
</span><span class="comment">-- @param route The route for the strike group.
</span><span class="comment">-- @param Packet Packet data containing various information.
</span><span class="comment">-- @return The configured strike group.
</span><a id="381"></a><span class="comment">-- @usage local strikeConfiguredGroup = SPECTRE.AI.configureGroup.STRIKE(managerInstance, strikeGroup, strikeRoute, packetData)
</span><span class="keyword">function</span> SPECTRE.AI.configureGroup.STRIKE(MANAGER, spawnGroup_, route, Packet)
  <span class="comment">-- Set common options for the strike group
</span>  spawnGroup_ = SPECTRE.AI.configureCommonOptions(spawnGroup_)

  <span class="comment">-- Define and set a task to delete the strike group on reaching a waypoint
</span>  <span class="keyword">local</span> _DelTask = spawnGroup_:TaskFunction(<span class="string">"SPECTREDeleteOnWP_"</span>, spawnGroup_)
  spawnGroup_:SetTaskWaypoint(route[#route], _DelTask)
  spawnGroup_:Route(route, <span class="number">0</span>)

  <span class="comment">-- Create a zone around the target coordinate
</span>  <span class="keyword">local</span> ZoneDrop = ZONE_RADIUS:New(Packet.spawnGroupName, Packet.TargetCoord:GetVec2(), UTILS.NMToMeters(<span class="number">0.3</span>))

  <span class="comment">-- Schedule a periodic check to see if the strike group is inside the zone
</span>  spawnGroup_.zonecheck_ = SCHEDULER:New({ZoneDrop}, <span class="keyword">function</span>()
    <span class="keyword">if</span> spawnGroup_:IsAlive() <span class="keyword">then</span>
      <span class="keyword">if</span> ZoneDrop <span class="keyword">and</span> spawnGroup_:IsAnyInZone(ZoneDrop) <span class="keyword">then</span>
        ZoneDrop = <span class="keyword">nil</span>
        spawnGroup_.zonecheck_:Stop()
        spawnGroup_.zonecheck_ = <span class="keyword">nil</span>
        <span class="global">collectgarbage</span>()
        <span class="global">collectgarbage</span>()

        <span class="keyword">local</span> DroppedGroup = SPAWN:NewWithAlias(Packet.aliasDropped_, <span class="global">string</span>.format(SPECTRE.MENU.Settings[Packet.Type].Units.AliasPrefix, Packet.tempCode))
          :InitCoalition(Packet.coal_)
          :InitCountry(Packet.country_)
          :SpawnFromVec2(Packet.TargetCoord:GetVec2())

        spawnGroup_:Destroy(<span class="keyword">false</span>)
        MESSAGE:New(<span class="string">"Strike Team deployment at "</span> .. Packet.Coordinate_:ToStringMGRS() .. <span class="string">" successful! Resources replenished."</span>, <span class="number">20</span>, <span class="string">"NOTICE"</span>):ToCoalition(Packet.coal)
        SPECTRE.MARKERS.World.RemoveByID(Packet.MarkerID)
        MANAGER:scheduleRestock(Packet.coal, Packet.Type)
      <span class="keyword">end</span>
    <span class="keyword">else</span>
      spawnGroup_.zonecheck_:Stop()
      spawnGroup_.zonecheck_ = <span class="keyword">nil</span>
      <span class="global">collectgarbage</span>()
      <span class="global">collectgarbage</span>()
    <span class="keyword">end</span>
  <span class="keyword">end</span>, {}, <span class="number">0</span>, <span class="number">5</span>)

  <span class="comment">-- Define messages for landing and dead events
</span>  <span class="keyword">local</span> messageOnLand = <span class="string">"LZ too hot! Strike team transport RTB!"</span>
  <span class="keyword">local</span> messageOnDead = <span class="string">"Strike team transport shot down before drop! Prepping new assets."</span>

  <span class="comment">-- Set common event handlers for the strike group
</span>  spawnGroup_ = SPECTRE.AI.setCommonEventHandlers(spawnGroup_, MANAGER, Packet, messageOnLand, messageOnDead)

  <span class="keyword">return</span> spawnGroup_
<span class="keyword">end</span>

<span class="comment">--- Configure an Airdrop Group.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Sets up an airdrop group by configuring common options, routing it, checking if it enters a specific zone, and adding event handlers.
</span><span class="comment">-- This function is specifically tailored for airdrop groups, ensuring their successful deployment and subsequent behavior within the simulation.
</span><span class="comment">-- It incorporates zone checks to determine the precise drop location, ensuring accurate delivery of the intended cargo or units.
</span><span class="comment">--
</span><span class="comment">-- @param MANAGER The manager responsible for various operations like restocking.
</span><span class="comment">-- @param spawnGroup_ The airdrop group to be configured.
</span><span class="comment">-- @param route The route for the airdrop group.
</span><span class="comment">-- @param Packet Packet data containing various information.
</span><span class="comment">-- @return The configured airdrop group.
</span><a id="445"></a><span class="comment">-- @usage local airdropConfiguredGroup = SPECTRE.AI.configureGroup.AIRDROP(managerInstance, airdropGroup, airdropRoute, packetData)
</span><span class="keyword">function</span> SPECTRE.AI.configureGroup.AIRDROP(MANAGER, spawnGroup_, route, Packet)
  <span class="comment">-- Set common options for the airdrop group
</span>  spawnGroup_ = SPECTRE.AI.configureCommonOptions(spawnGroup_)

  <span class="comment">-- Define and set a task to delete the airdrop group on reaching a waypoint
</span>  <span class="keyword">local</span> _DelTask = spawnGroup_:TaskFunction(<span class="string">"SPECTREDeleteOnWP_"</span>, spawnGroup_)
  spawnGroup_:SetTaskWaypoint(route[#route], _DelTask)
  spawnGroup_:Route(route, <span class="number">0</span>)

  <span class="comment">-- Create a zone around the target coordinate
</span>  <span class="keyword">local</span> ZoneDrop = ZONE_RADIUS:New(Packet.spawnGroupName, Packet.TargetCoord:GetVec2(), UTILS.NMToMeters(<span class="number">0.3</span>))

  <span class="comment">-- Schedule a periodic check to see if the airdrop group is inside the zone
</span>  spawnGroup_.zonecheck_ = SCHEDULER:New({ZoneDrop}, <span class="keyword">function</span>()
    <span class="keyword">if</span> spawnGroup_:IsAlive() <span class="keyword">then</span>
      <span class="keyword">if</span> ZoneDrop <span class="keyword">and</span> spawnGroup_:IsAnyInZone(ZoneDrop) <span class="keyword">then</span>
        ZoneDrop = <span class="keyword">nil</span>
        spawnGroup_.zonecheck_:Stop()
        spawnGroup_.zonecheck_ = <span class="keyword">nil</span>
        <span class="global">collectgarbage</span>()
        <span class="global">collectgarbage</span>()

        <span class="keyword">local</span> DroppedGroup = SPAWN:NewWithAlias(Packet.aliasDropped_, <span class="global">string</span>.format(SPECTRE.MENU.Settings[Packet.Type].Types[Packet.subtype_].AliasPrefix, Packet.tempCode))
          :InitCoalition(Packet.coal_)
          :InitCountry(Packet.country_)
          :OnSpawnGroup(<span class="keyword">function</span>(DroppedGroup_)
            <span class="keyword">local</span> messageOnDead = Packet.subtype_ .. <span class="string">" group destroyed! Prepping new assets."</span>
            DroppedGroup_ = SPECTRE.AI.setAirdropEventHandlers(DroppedGroup_, MANAGER, Packet, messageOnDead)
          <span class="keyword">end</span>)

        DroppedGroup:SpawnFromVec2(Packet.TargetCoord:GetVec2())
        spawnGroup_:Destroy(<span class="keyword">false</span>)
        MESSAGE:New(Packet.subtype_ .. <span class="string">" airdrop at "</span> .. Packet.Coordinate_:ToStringMGRS() .. <span class="string">" successful! Prepping new transport."</span>, <span class="number">20</span>, <span class="string">"NOTICE"</span>):ToCoalition(Packet.coal)
        SPECTRE.MARKERS.World.RemoveByID(Packet.MarkerID)
      <span class="keyword">end</span>
    <span class="keyword">else</span>
      spawnGroup_.zonecheck_:Stop()
      spawnGroup_.zonecheck_ = <span class="keyword">nil</span>
      <span class="global">collectgarbage</span>()
      <span class="global">collectgarbage</span>()
    <span class="keyword">end</span>
  <span class="keyword">end</span>, {}, <span class="number">0</span>, <span class="number">5</span>)

  <span class="comment">-- Define messages for landing and dead events
</span>  <span class="keyword">local</span> messageOnLand = Packet.subtype_ .. <span class="string">" airdrop shot down before drop!"</span>
  <span class="keyword">local</span> messageOnDead = Packet.subtype_ .. <span class="string">" airdrop shot down before drop!"</span>

  <span class="comment">-- Set common event handlers for the airdrop group
</span>  spawnGroup_ = SPECTRE.AI.setCommonEventHandlers(spawnGroup_, MANAGER, Packet, messageOnLand, messageOnDead)

  <span class="keyword">return</span> spawnGroup_
<span class="keyword">end</span>

<span class="comment">--- buildWaypoints.
</span><span class="comment">--
</span><span class="comment">-- This namespace encompasses functions tailored to construct and define waypoints
</span><span class="comment">-- for various AI operations. Waypoints are critical in guiding AI units along desired
</span><span class="comment">-- paths or trajectories during their missions.
</span><span class="comment">--
</span><span class="comment">-- Key Features:
</span><span class="comment">--
</span><span class="comment">-- - Creates waypoints based on specific mission types and objectives.
</span><span class="comment">-- - Allows for dynamic pathing, ensuring AI units can adapt to changing conditions or objectives.
</span><span class="comment">-- - Ensures that AI units travel along optimal or strategic routes to their destinations.
</span><span class="comment">-- - Supports various mission types, such as Combat Air Patrols, bombings, airdrops, and more.
</span><span class="comment">-- - Integrates with other systems to gather context, ensuring waypoints are relevant and practical.
</span><span class="comment">--
</span><span class="comment">-- @section SPECTRE.buildWaypoints
</span><span class="comment">-- @field #buildWaypoints
</span>SPECTRE.AI.buildWaypoints = {}


<span class="comment">--- Build CAP Waypoints.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Constructs waypoints for a Combat Air Patrol (CAP) based on the data provided in the Packet.
</span><span class="comment">-- This function is essential for defining the trajectory and behavior of CAP units within the simulation.
</span><span class="comment">-- By specifying key parameters within the Packet, users can achieve desired CAP patterns and formations.
</span><span class="comment">--
</span><span class="comment">-- @param Packet Data packet containing various parameters needed for building waypoints.
</span><span class="comment">-- @return Packet The Packet updated with the constructed waypoints.
</span><a id="528"></a><span class="comment">-- @usage local updatedPacket = SPECTRE.AI.buildWaypoints.CAP(packetData)
</span><span class="keyword">function</span> SPECTRE.AI.buildWaypoints.CAP(Packet)
  <span class="comment">-- Set the CAP marker coordinate based on the provided coordinate and altitude
</span>  Packet.Cap_Marker_Coord = COORDINATE:NewFromCoordinate(Packet.Coordinate_)
  Packet.Cap_Marker_Coord.y = Packet.Alt

  <span class="comment">-- Prepare racetrack coordinates
</span>  Packet.RacetrackStart, Packet.RacetrackEnd = SPECTRE.AI.prepareRacetrackCoords(Packet.Coordinate_, Packet.Alt, Packet.heading, Packet.distance, Packet.OFFSET)

  <span class="comment">-- Generate a random spawn coordinate within a 5 NM radius from the airbase coordinate
</span>  Packet.spawnCoord = Packet.airbaseCoord:GetRandomCoordinateInRadius(UTILS.NMToMeters(<span class="number">5</span>))
  Packet.spawnCoord.y = Packet.Alt

  <span class="comment">-- Calculate the waypoint inbound to the destination
</span>  Packet.wptInboundToD = Packet.spawnCoord:Translate(UTILS.NMToMeters(<span class="number">5</span>), Packet.spawnCoord:HeadingTo(Packet.RacetrackStart), <span class="keyword">true</span>)
  Packet.wptInboundToD.y = Packet.Alt

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- Build Bomber Waypoints.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Constructs waypoints for a bomber based on the data provided in the Packet.
</span><span class="comment">-- This function is pivotal in defining the trajectory, altitude, and behavior of bomber units within the simulation.
</span><span class="comment">-- It facilitates random and strategic waypoint generation, ensuring unpredictable and effective bombing routes.
</span><span class="comment">--
</span><span class="comment">-- @param Packet Data packet containing various parameters needed for building waypoints.
</span><span class="comment">-- @return Packet The Packet updated with the constructed waypoints.
</span><a id="558"></a><span class="comment">-- @usage local updatedPacket = SPECTRE.AI.buildWaypoints.BOMBER(packetData)
</span><span class="keyword">function</span> SPECTRE.AI.buildWaypoints.BOMBER(Packet)


  <span class="comment">-- Define a random cruise altitude between 45,000 and 55,000 feet in meters
</span>  Packet.cruiseAlt = UTILS.FeetToMeters(<span class="global">math</span>.random(<span class="number">45</span>, <span class="number">55</span>) * <span class="number">1000</span>)

  <span class="comment">-- Generate a random spawn coordinate within a 5 NM radius from the airbase coordinate and set its altitude to cruise altitude
</span>  Packet.spawnCoord = Packet.airbaseCoord:GetRandomCoordinateInRadius(UTILS.NMToMeters(<span class="number">5</span>))
  Packet.spawnCoord.y = Packet.cruiseAlt

  <span class="comment">-- Set drop coordinate as the provided coordinate in the Packet and adjust its altitude to land height
</span>  Packet.dropCoord = Packet.Coordinate_
  Packet.dropCoord.y = Packet.dropCoord:GetLandHeight()

  <span class="comment">-- Define an initial point (IP) waypoint as the spawn coordinate and adjust its altitude
</span>  Packet.wptIP = Packet.spawnCoord
  Packet.wptIP.y = <span class="number">13716</span>

  <span class="comment">-- Calculate the 2D distance between the target and airbase
</span>  Packet.distTgtToAirbase = Packet.airbaseCoord:Get2DDistance(Packet.dropCoord)

  <span class="comment">-- Define an outbound waypoint to destination after the bomber drops its payload
</span>  Packet.wptOutboundToD = Packet.airbaseCoord:Translate(<span class="global">math</span>.min(UTILS.NMToMeters(<span class="number">40</span>), Packet.distTgtToAirbase * <span class="number">0.25</span>), Packet.airbaseCoord:HeadingTo(Packet.dropCoord) + <span class="number">10</span>, <span class="keyword">true</span>)
  Packet.wptOutboundToD.y = Packet.cruiseAlt

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- Build Bomber Waypoints.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Constructs waypoints for a bomber based on the data provided in the Packet.
</span><span class="comment">-- This function defines the trajectory, altitude, and behavior of bomber units within the simulation by generating waypoints.
</span><span class="comment">-- It uses the parameters within the Packet for waypoint generation to ensure accurate and intended bomber routes.
</span><span class="comment">--
</span><span class="comment">-- @param Packet Data packet containing various parameters needed for building waypoints.
</span><span class="comment">-- @return Packet The Packet updated with the constructed waypoints.
</span><a id="597"></a><span class="comment">-- @usage local updatedPacket = SPECTRE.AI.buildWaypoints.BOMBER(packetData)
</span><span class="keyword">function</span> SPECTRE.AI.buildWaypoints.STRIKE(Packet)


  <span class="comment">-- Define a random cruise altitude between 200 and 300 feet in meters
</span>  Packet.cruiseAlt = UTILS.FeetToMeters(<span class="global">math</span>.random(<span class="number">200</span>, <span class="number">300</span>))

  <span class="comment">-- Generate a random spawn coordinate within a 0.5 NM radius from the airbase coordinate and set its altitude to cruise altitude
</span>  Packet.spawnCoord = Packet.airbaseCoord:GetRandomCoordinateInRadius(UTILS.NMToMeters(<span class="number">0.5</span>))
  Packet.spawnCoord.y = Packet.cruiseAlt

  <span class="comment">-- Set the target coordinate as the provided coordinate in the Packet and adjust its altitude to a random value between 30 and 100 feet
</span>  Packet.TargetCoord = Packet.Coordinate_
  Packet.TargetCoord.y = UTILS.FeetToMeters(<span class="global">math</span>.random(<span class="number">30</span>, <span class="number">100</span>))

  <span class="comment">-- Define the coordinates for the first and second waypoints
</span>  Packet.WPT1_coord = Packet.spawnCoord:Translate(UTILS.NMToMeters(<span class="number">5</span>), Packet.spawnCoord:HeadingTo(Packet.TargetCoord), <span class="keyword">true</span>)
  Packet.WPT1_coord.y = Packet.cruiseAlt
  Packet.WPT2_coord = Packet.TargetCoord:Translate(UTILS.NMToMeters(<span class="number">10</span>), Packet.TargetCoord:HeadingTo(Packet.spawnCoord), <span class="keyword">true</span>)
  Packet.WPT2_coord.y = Packet.TargetCoord.y

  <span class="comment">-- Create the waypoints with the appropriate settings
</span>  Packet.WPT1 = Packet.WPT1_coord:WaypointAir(COORDINATE.WaypointAltType.RADIO, COORDINATE.WaypointType.TurningPoint, COORDINATE.WaypointAction.FlyoverPoint, UTILS.MpsToKmph(<span class="number">130</span>), <span class="keyword">false</span>)
  Packet.WPT_Target = Packet.TargetCoord:WaypointAir(COORDINATE.WaypointAltType.RADIO, COORDINATE.WaypointType.TurningPoint, COORDINATE.WaypointAction.FlyoverPoint, UTILS.MpsToKmph(<span class="number">130</span>), <span class="keyword">false</span>)
  Packet.WPT2 = Packet.WPT2_coord:WaypointAir(COORDINATE.WaypointAltType.RADIO, COORDINATE.WaypointType.TurningPoint, COORDINATE.WaypointAction.TurningPoint, UTILS.MpsToKmph(<span class="number">130</span>), <span class="keyword">false</span>)

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- Build Airdrop Waypoints.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Constructs waypoints for an airdrop mission based on the data provided in the Packet.
</span><span class="comment">-- This function uses the data in the Packet to define the trajectory, altitude, and sequence of waypoints for an airdrop mission.
</span><span class="comment">-- The waypoints ensure the airdrop group follows the intended path and performs airdrop operations at the designated locations.
</span><span class="comment">--
</span><span class="comment">-- @param Packet Data packet containing various parameters needed for building waypoints.
</span><span class="comment">-- @return Packet The Packet updated with the constructed waypoints.
</span><a id="636"></a><span class="comment">-- @usage local updatedPacket = SPECTRE.AI.buildWaypoints.AIRDROP(packetData)
</span><span class="keyword">function</span> SPECTRE.AI.buildWaypoints.AIRDROP(Packet)


  <span class="comment">-- Define a random cruise altitude between 15,000 and 25,000 feet in meters
</span>  Packet.cruiseAlt = UTILS.FeetToMeters(<span class="global">math</span>.random(<span class="number">15</span>, <span class="number">25</span>) * <span class="number">1000</span>)

  <span class="comment">-- Generate a random spawn coordinate within a 5 NM radius from the airbase coordinate and set its altitude to cruise altitude
</span>  Packet.spawnCoord = Packet.airbaseCoord:GetRandomCoordinateInRadius(UTILS.NMToMeters(<span class="number">5</span>))
  Packet.spawnCoord.y = Packet.cruiseAlt

  <span class="comment">-- Set the target coordinate as the provided coordinate in the Packet and adjust its altitude to a random value between 2,000 and 5,000 feet
</span>  Packet.TargetCoord = Packet.Coordinate_
  Packet.TargetCoord.y = UTILS.FeetToMeters(<span class="global">math</span>.random(<span class="number">2</span>, <span class="number">5</span>) * <span class="number">1000</span>)

  <span class="comment">-- Define the coordinates for the first and second waypoints
</span>  Packet.WPT1_coord = Packet.spawnCoord:Translate(UTILS.NMToMeters(<span class="number">5</span>), Packet.spawnCoord:HeadingTo(Packet.TargetCoord), <span class="keyword">true</span>)
  Packet.WPT1_coord.y = Packet.cruiseAlt
  Packet.WPT2_coord = Packet.TargetCoord:Translate(UTILS.NMToMeters(<span class="number">10</span>), Packet.TargetCoord:HeadingTo(Packet.spawnCoord), <span class="keyword">true</span>)
  Packet.WPT2_coord.y = Packet.TargetCoord.y

  <span class="comment">-- Create the waypoints with the appropriate settings
</span>  Packet.WPT1 = Packet.WPT1_coord:WaypointAir(COORDINATE.WaypointAltType.BARO, COORDINATE.WaypointType.TurningPoint, COORDINATE.WaypointAction.FlyoverPoint, UTILS.MpsToKmph(<span class="number">300</span>), <span class="keyword">false</span>)
  Packet.WPT_Target = Packet.TargetCoord:WaypointAir(COORDINATE.WaypointAltType.BARO, COORDINATE.WaypointType.TurningPoint, COORDINATE.WaypointAction.FlyoverPoint, UTILS.MpsToKmph(<span class="number">300</span>), <span class="keyword">false</span>)
  Packet.WPT2 = Packet.WPT2_coord:WaypointAir(COORDINATE.WaypointAltType.BARO, COORDINATE.WaypointType.TurningPoint, COORDINATE.WaypointAction.TurningPoint, UTILS.MpsToKmph(<span class="number">300</span>), <span class="keyword">false</span>)

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- buildPacket.
</span><span class="comment">--
</span><span class="comment">-- This namespace encompasses functions responsible for assembling data packets
</span><span class="comment">-- essential for AI operations. These packets contain vital information required
</span><span class="comment">-- by the AI to execute their missions accurately.
</span><span class="comment">--
</span><span class="comment">-- Key Features:
</span><span class="comment">--
</span><span class="comment">-- - Gathers and organizes data from various inputs, such as markers and player details.
</span><span class="comment">-- - Provides a standardized structure for data that AI operations can readily interpret.
</span><span class="comment">-- - Supports a wide range of operations, including Combat Air Patrols, bombings, and airdrops.
</span><span class="comment">-- - Ensures that AI units have all the necessary context for their tasks, such as target locations, routes, and potential threats.
</span><span class="comment">--
</span><span class="comment">-- @section SPECTRE.AI
</span><span class="comment">-- @field #buildPacket
</span>SPECTRE.AI.buildPacket = {}


<span class="comment">--- Determine Nearest Airbase Values for Packet.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Finds the closest airbase to the provided coordinate in the Packet and updates the Packet with the airbase's information.
</span><span class="comment">-- The function evaluates the available airbases based on the provided target coordinates and coalition information to determine the optimal airbase.
</span><span class="comment">-- This ensures effective deployment and routing of units based on their proximity to their intended operational area.
</span><span class="comment">--
</span><span class="comment">-- @param Packet Data packet containing various parameters including the target coordinate.
</span><span class="comment">-- @return Packet The Packet updated with the nearest airbase's information.
</span><a id="693"></a><span class="comment">-- @usage local updatedPacket = SPECTRE.AI.buildPacket.determineNearestAirbaseValues(packetData)
</span><span class="keyword">function</span> SPECTRE.AI.buildPacket.determineNearestAirbaseValues(Packet)
  <span class="comment">-- Extract the Vec2 representation of the target coordinate from the Packet
</span>  Packet.markerVec2 = Packet.Coordinate_:GetVec2()

  <span class="comment">-- Find the nearest airbase to the target coordinate for the specified coalition
</span>  Packet.NearestAirbase = SPECTRE.WORLD.ClosestAirfieldVec2(Packet.coal, Packet.markerVec2)

  <span class="comment">-- Extract the airbase's name and coordinate
</span>  Packet.airbaseName = Packet.NearestAirbase.Name
  Packet.airbaseCoord = COORDINATE:NewFromVec3(Packet.NearestAirbase.Vec3)

  <span class="comment">-- Debug information
</span>  SPECTRE.UTILS.debugInfo(<span class="string">"Packet"</span>, Packet)

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- Determine Marker Values for Packet.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Fetches details about a specific marker related to the provided Player and updates the Packet with relevant information.
</span><span class="comment">-- The function extracts marker details based on the specified player and marker index. This ensures accurate retrieval and utilization of marker information for further operational decisions.
</span><span class="comment">--
</span><span class="comment">-- @param Packet Data packet to be updated with marker details.
</span><span class="comment">-- @param Player Player object containing marker information.
</span><span class="comment">-- @param MarkerIndex Index of the marker in the Player's marker arrays.
</span><span class="comment">-- @return Packet The Packet updated with the marker's information.
</span><a id="722"></a><span class="comment">-- @usage local updatedPacket = SPECTRE.AI.buildPacket.determineMarkerValues(packetData, somePlayer, markerIdx)
</span><span class="keyword">function</span> SPECTRE.AI.buildPacket.determineMarkerValues(Packet, Player, MarkerIndex)
  <span class="comment">-- Fetch and store marker details from the Player's marker arrays using the provided index
</span>  Packet.markerArray = Player.Markers[Packet.Type].MarkerArrays[MarkerIndex]
  Packet.Coordinate_ = Packet.markerArray.MarkCoords
  Packet.descriptor = Packet.markerArray.descriptor
  Packet.RequestingUnit = Player.name
  Packet.code = Packet.markerArray.code
  Packet.coal = Player.side
  Packet.MarkerID = Packet.markerArray.PermMarkerID

  <span class="comment">-- Debug information
</span>  SPECTRE.UTILS.debugInfo(<span class="string">"Packet"</span>, Packet)

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- Determine AI Coalition Values for Packet.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- Determines AI's coalition, country, and alias based on the player's coalition and the type of operation.
</span><span class="comment">-- The function identifies the appropriate coalition, country, and template alias values for AI-controlled units. These determinations are based on the player's side and the specific type of operation, ensuring the AI behaves appropriately in context.
</span><span class="comment">--
</span><span class="comment">-- @param Packet Data packet containing the player's coalition and the operation type.
</span><span class="comment">-- @return Packet The Packet updated with the AI's coalition values.
</span><a id="748"></a><span class="comment">-- @usage local updatedPacket = SPECTRE.AI.buildPacket.determineAICoalitionValues(packetData)
</span><span class="keyword">function</span> SPECTRE.AI.buildPacket.determineAICoalitionValues(Packet)
  <span class="comment">-- Debug information
</span>  SPECTRE.UTILS.debugInfo(<span class="string">"Packet"</span>, Packet)
  SPECTRE.UTILS.debugInfo(<span class="string">"Packet.Type"</span>, Packet.Type)
  SPECTRE.UTILS.debugInfo(<span class="string">"Packet.subtype_"</span>, Packet.subtype_)

  <span class="keyword">local</span> PlayerSide = Packet.coal
  <span class="keyword">local</span> Type = Packet.Type
  <span class="keyword">local</span> coal_, country_, alias_, aliasDropped_

  <span class="comment">-- Define values based on player's coalition
</span>  <span class="keyword">if</span> PlayerSide == <span class="number">1</span> <span class="keyword">then</span>
    coal_ = SPECTRE.Coalitions.Red
    country_ = SPECTRE.Countries.Red
    alias_ = SPECTRE.MENU.Settings[Type].TemplateName.Red
  <span class="keyword">else</span>
    coal_ = SPECTRE.Coalitions.Blue
    country_ = SPECTRE.Countries.Blue
    alias_ = SPECTRE.MENU.Settings[Type].TemplateName.Blue
  <span class="keyword">end</span>

  <span class="comment">-- Define specific alias values for STRIKE and AIRDROP types
</span>  <span class="keyword">if</span> Type == <span class="string">"STRIKE"</span> <span class="keyword">then</span>
    alias_ = PlayerSide == <span class="number">1</span> <span class="keyword">and</span> SPECTRE.MENU.Settings[Type].Transport.TemplateName.Red <span class="keyword">or</span> SPECTRE.MENU.Settings[Type].Transport.TemplateName.Blue
    aliasDropped_ = PlayerSide == <span class="number">1</span> <span class="keyword">and</span> SPECTRE.MENU.Settings[Type].Units.TemplateName.Red <span class="keyword">or</span> SPECTRE.MENU.Settings[Type].Units.TemplateName.Blue
  <span class="keyword">elseif</span> Type == <span class="string">"AIRDROP"</span> <span class="keyword">then</span>
    aliasDropped_ = PlayerSide == <span class="number">1</span> <span class="keyword">and</span> SPECTRE.MENU.Settings[Type].Types[Packet.subtype_].TemplateName.Red <span class="keyword">or</span> SPECTRE.MENU.Settings[Type].Types[Packet.subtype_].TemplateName.Blue
  <span class="keyword">end</span>

  <span class="comment">-- Update the Packet with the determined values
</span>  Packet.coal_ = coal_
  Packet.country_ = country_
  Packet.alias_ = alias_
  Packet.aliasDropped_ = aliasDropped_

  <span class="comment">-- Debug information
</span>  SPECTRE.UTILS.debugInfo(<span class="string">"Packet"</span>, Packet)

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- Build CAP Packet.
</span><span class="comment">--
</span><span class="comment">-- Constructs a data packet for the Combat Air Patrol (CAP) scenario based on the provided player and marker index.
</span><span class="comment">-- The function gathers and organizes information necessary for setting up a CAP mission. This includes determining the nearest airbase to the target, the coalition details for the AI units, and the appropriate waypoints for the mission.
</span><span class="comment">--
</span><span class="comment">-- @param Player The player object.
</span><span class="comment">-- @param MarkerIndex Index of the marker for which the CAP packet is to be built.
</span><span class="comment">-- @return route The constructed CAP data packet.
</span><a id="798"></a><span class="comment">-- @usage local capPacket = SPECTRE.AI.buildPacket.CAP(somePlayer, markerIdx)
</span><span class="keyword">function</span> SPECTRE.AI.buildPacket.CAP(Player, MarkerIndex)
  <span class="comment">-- Initial default values for the Packet
</span>  <span class="keyword">local</span> Packet = {
    Type = <span class="string">"CAP"</span>,
    OFFSET = <span class="number">1</span>,
    Zone_Engage = <span class="number">92600</span>
  }

  <span class="comment">-- Local function to calculate distance based on provided initial distance.
</span>  <span class="keyword">local</span> <span class="keyword">function</span> calculateDistance(initialDistance)
    <span class="keyword">if</span> initialDistance <span class="keyword">and</span> initialDistance &gt; <span class="number">20</span> <span class="keyword">then</span>
      <span class="keyword">return</span> (initialDistance - <span class="number">14</span>) / <span class="number">2</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> initialDistance <span class="keyword">and</span> (initialDistance / <span class="number">2</span>) <span class="keyword">or</span> <span class="keyword">nil</span>
  <span class="keyword">end</span>

  <span class="comment">-- Fetch and store marker details
</span>  Packet = SPECTRE.AI.buildPacket.determineMarkerValues(Packet, Player, MarkerIndex)

  <span class="comment">-- Determine the nearest airbase and update the Packet
</span>  Packet = SPECTRE.AI.buildPacket.determineNearestAirbaseValues(Packet)

  <span class="comment">-- Determine AI coalition values and update the Packet
</span>  Packet = SPECTRE.AI.buildPacket.determineAICoalitionValues(Packet)

  <span class="comment">-- Calculate heading and distance based on the marker's values
</span>  Packet.heading = Packet.markerArray.heading <span class="keyword">and</span> (((Packet.markerArray.heading % <span class="number">360</span>) + <span class="number">360</span>) % <span class="number">360</span>) <span class="keyword">or</span> <span class="keyword">nil</span>
  Packet.distance = calculateDistance(Packet.markerArray.distance)

  <span class="comment">-- Define altitude and speed for the CAP
</span>  Packet.Alt = UTILS.FeetToMeters(UTILS.Randomize(<span class="number">30000</span>, <span class="number">0.15</span>))
  Packet.speed = UTILS.KnotsToMps(<span class="number">485</span>)

  <span class="comment">-- Build waypoints for the CAP and update the Packet
</span>  Packet = SPECTRE.AI.buildWaypoints.CAP(Packet)

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- Build TOMAHAWK Packet.
</span><span class="comment">--
</span><span class="comment">-- Constructs a data packet for the Tomahawk missile scenario based on the provided player and marker index.
</span><span class="comment">-- This function gathers and organizes information necessary for setting up a Tomahawk missile launch. This includes extracting marker details from the player's data and determining coalition details for the AI units.
</span><span class="comment">--
</span><span class="comment">-- @param Player The player object.
</span><span class="comment">-- @param MarkerIndex Index of the marker for which the TOMAHAWK packet is to be built.
</span><span class="comment">-- @return route The constructed TOMAHAWK data packet.
</span><a id="846"></a><span class="comment">-- @usage local tomahawkPacket = SPECTRE.AI.buildPacket.TOMAHAWK(somePlayer, markerIdx)
</span><span class="keyword">function</span> SPECTRE.AI.buildPacket.TOMAHAWK(Player, MarkerIndex)
  <span class="comment">-- Initial default value for the Packet
</span>  <span class="keyword">local</span> Packet = {
    Type = <span class="string">"TOMAHAWK"</span>
  }

  <span class="comment">-- Fetch and store marker details
</span>  Packet = SPECTRE.AI.buildPacket.determineMarkerValues(Packet, Player, MarkerIndex)

  <span class="comment">-- Determine AI coalition values and update the Packet
</span>  Packet = SPECTRE.AI.buildPacket.determineAICoalitionValues(Packet)

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- Build BOMBER Packet.
</span><span class="comment">--
</span><span class="comment">-- Constructs a data packet for the bomber scenario based on the provided player and marker index.
</span><span class="comment">-- This function aggregates and arranges information necessary for configuring a bomber mission. It gathers marker details from the player's data, determines the nearest airbase, specifies coalition details for the AI units, and prepares the bombing task details.
</span><span class="comment">--
</span><span class="comment">-- @param Player The player object.
</span><span class="comment">-- @param MarkerIndex Index of the marker for which the BOMBER packet is to be built.
</span><span class="comment">-- @return route The constructed BOMBER data packet.
</span><a id="870"></a><span class="comment">-- @usage local bomberPacket = SPECTRE.AI.buildPacket.BOMBER(somePlayer, markerIdx)
</span><span class="keyword">function</span> SPECTRE.AI.buildPacket.BOMBER(Player, MarkerIndex)


  <span class="comment">-- Initial default value for the Packet
</span>  <span class="keyword">local</span> Packet = {
    Type = <span class="string">"BOMBER"</span>
  }

  <span class="comment">-- Local function to calculate distance based on provided initial distance.
</span>  <span class="keyword">local</span> <span class="keyword">function</span> calculateDistance(initialDistance)
    <span class="keyword">if</span> initialDistance <span class="keyword">and</span> initialDistance &gt; <span class="number">20</span> <span class="keyword">then</span>
      <span class="keyword">return</span> (initialDistance - <span class="number">14</span>) / <span class="number">2</span>
    <span class="keyword">end</span>
    <span class="keyword">return</span> initialDistance <span class="keyword">and</span> (initialDistance / <span class="number">2</span>) <span class="keyword">or</span> <span class="keyword">nil</span>
  <span class="keyword">end</span>

  <span class="comment">-- Fetch and store marker details
</span>  Packet = SPECTRE.AI.buildPacket.determineMarkerValues(Packet, Player, MarkerIndex)

  <span class="comment">-- Determine the nearest airbase and update the Packet
</span>  Packet = SPECTRE.AI.buildPacket.determineNearestAirbaseValues(Packet)

  <span class="comment">-- Determine AI coalition values and update the Packet
</span>  Packet = SPECTRE.AI.buildPacket.determineAICoalitionValues(Packet)

  <span class="comment">-- Build waypoints for the bomber and update the Packet
</span>  Packet = SPECTRE.AI.buildWaypoints.BOMBER(Packet)

  <span class="comment">-- Define bombing task for the bomber
</span>  Packet.bombTask = {
    id = <span class="string">'CarpetBombing'</span>,
    params = {
      point            = Packet.dropCoord:GetVec2(),
      x                = Packet.dropCoord:GetVec2().x,
      y                = Packet.dropCoord:GetVec2().y,
      groupAttack      = <span class="keyword">true</span>,
      expend           = AI.Task.WeaponExpend.ALL,
      attackQtyLimit   = <span class="keyword">false</span>,
      attackQty        = <span class="number">1</span>,
      directionEnabled = <span class="keyword">true</span>,
      direction        = <span class="global">math</span>.rad(<span class="global">math</span>.random(<span class="number">360</span>)),
      altitudeEnabled  = <span class="keyword">true</span>,
      altitude         = UTILS.FeetToMeters(<span class="number">40000</span>),
      weaponType       = <span class="number">2147485680</span>,
      attackType       = <span class="string">"Carpet"</span>,
      carpetLength     = <span class="number">200</span>, <span class="comment">-- 100 meters if precise strike, otherwise 500 meters
</span>    },
  }

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- Build STRIKE Packet.
</span><span class="comment">--
</span><span class="comment">-- Constructs a data packet for the strike scenario based on the provided player and marker index.
</span><span class="comment">-- This function gathers necessary information for creating a strike mission. It fetches marker details from the player's data, determines the nearest airbase, sets coalition details for the AI units, and configures the waypoints for the strike mission.
</span><span class="comment">--
</span><span class="comment">-- @param Player The player object.
</span><span class="comment">-- @param MarkerIndex Index of the marker for which the STRIKE packet is to be built.
</span><span class="comment">-- @return route The constructed STRIKE data packet.
</span><a id="931"></a><span class="comment">-- @usage local strikePacket = SPECTRE.AI.buildPacket.STRIKE(somePlayer, markerIdx)
</span><span class="keyword">function</span> SPECTRE.AI.buildPacket.STRIKE(Player, MarkerIndex)
  <span class="comment">-- Initial default value for the Packet
</span>  <span class="keyword">local</span> Packet = {
    Type = <span class="string">"STRIKE"</span>
  }

  <span class="comment">-- Fetch and store marker details
</span>  Packet = SPECTRE.AI.buildPacket.determineMarkerValues(Packet, Player, MarkerIndex)

  <span class="comment">-- Determine the nearest airbase and update the Packet
</span>  Packet = SPECTRE.AI.buildPacket.determineNearestAirbaseValues(Packet)

  <span class="comment">-- Determine AI coalition values and update the Packet
</span>  Packet = SPECTRE.AI.buildPacket.determineAICoalitionValues(Packet)

  <span class="comment">-- Store the code as a temporary variable
</span>  Packet.tempCode = Packet.code

  <span class="comment">-- Ensure the generated group name is unique
</span>  <span class="keyword">local</span> FoundGroup
  <span class="keyword">repeat</span>
    FoundGroup = GROUP:FindByName(SPECTRE.MENU.Settings[Packet.Type].Units.AliasPrefix .. Packet.tempCode .. <span class="string">"#001"</span>)
    <span class="keyword">if</span> FoundGroup <span class="keyword">then</span>
      Packet.tempCode = Packet.tempCode + <span class="number">1</span>
    <span class="keyword">else</span>
      FoundGroup = <span class="keyword">false</span>
    <span class="keyword">end</span>
  <span class="keyword">until</span> (FoundGroup == <span class="keyword">false</span>)

  <span class="comment">-- Build waypoints for the strike and update the Packet
</span>  Packet = SPECTRE.AI.buildWaypoints.STRIKE(Packet)

  <span class="comment">-- Set the group name for spawning
</span>  Packet.spawnGroupName = <span class="global">string</span>.format(SPECTRE.MENU.Settings[Packet.Type].Transport.AliasPrefix, Packet.code)

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- Build AIRDROP Packet.
</span><span class="comment">--
</span><span class="comment">-- Constructs a data packet for the airdrop scenario based on the given player and marker index.
</span><span class="comment">-- This function compiles essential information to initiate an airdrop mission. It extracts marker details from the player's data, identifies the nearest airbase, sets the AI units' coalition details, and designs the waypoints for the airdrop mission.
</span><span class="comment">--
</span><span class="comment">-- @param Player The player object.
</span><span class="comment">-- @param MarkerIndex Index of the marker for which the AIRDROP packet is to be constructed.
</span><span class="comment">-- @return route The constructed AIRDROP data packet.
</span><a id="978"></a><span class="comment">-- @usage local airdropPacket = SPECTRE.AI.buildPacket.AIRDROP(somePlayer, markerIdx)
</span><span class="keyword">function</span> SPECTRE.AI.buildPacket.AIRDROP(Player, MarkerIndex)
  <span class="comment">-- Initialize default values for the Packet
</span>  <span class="keyword">local</span> Packet = {
    Type = <span class="string">"AIRDROP"</span>
  }

  <span class="comment">-- Retrieve and store marker details
</span>  Packet = SPECTRE.AI.buildPacket.determineMarkerValues(Packet, Player, MarkerIndex)

  <span class="comment">-- Extract the subtype from the marker array
</span>  Packet.subtype_ = Packet.markerArray.Packet.MarkerType[<span class="number">2</span>]

  <span class="comment">-- Determine the closest airbase and update the Packet
</span>  Packet = SPECTRE.AI.buildPacket.determineNearestAirbaseValues(Packet)

  <span class="comment">-- Define AI coalition values and update the Packet
</span>  Packet = SPECTRE.AI.buildPacket.determineAICoalitionValues(Packet)

  <span class="comment">-- Store the code in a temporary variable
</span>  Packet.tempCode = Packet.code

  <span class="comment">-- Ensure the group name is unique
</span>  <span class="keyword">local</span> FoundGroup
  <span class="keyword">repeat</span>
    FoundGroup = GROUP:FindByName(SPECTRE.MENU.Settings[Packet.Type].Types[Packet.subtype_].AliasPrefix .. Packet.tempCode .. <span class="string">"#001"</span>)
    <span class="keyword">if</span> FoundGroup <span class="keyword">then</span>
      Packet.tempCode = Packet.tempCode + <span class="number">1</span>
    <span class="keyword">else</span>
      FoundGroup = <span class="keyword">false</span>
    <span class="keyword">end</span>
  <span class="keyword">until</span> (FoundGroup == <span class="keyword">false</span>)

  <span class="comment">-- Construct waypoints for the airdrop and update the Packet
</span>  Packet = SPECTRE.AI.buildWaypoints.AIRDROP(Packet)

  <span class="comment">-- Define the group name for spawning
</span>  Packet.spawnGroupName = <span class="global">string</span>.format(SPECTRE.MENU.Settings.AIRDROP.AliasPrefix, Packet.code)

  <span class="keyword">return</span> Packet
<span class="keyword">end</span>

<span class="comment">--- buildRoute.
</span><span class="comment">--
</span><span class="comment">-- This namespace houses functions dedicated to the construction of routes
</span><span class="comment">-- for various AI operations. The primary purpose is to generate waypoints
</span><span class="comment">-- and define specific paths that AI units will follow during their missions.
</span><span class="comment">--
</span><span class="comment">-- Key Characteristics:
</span><span class="comment">--
</span><span class="comment">-- - Handles a range of paths from simple direct routes to complex mission patterns.
</span><span class="comment">-- - Supports operations such as CAP orbits, bombing runs, and airdrop missions.
</span><span class="comment">-- - Utilizes parameters like mission type, target location, and potential threats.
</span><span class="comment">-- - Ensures AI units can efficiently and safely execute their designated tasks.
</span><span class="comment">--
</span><span class="comment">-- @section SPECTRE.buildRoute
</span><span class="comment">-- @field #buildRoute
</span>SPECTRE.AI.buildRoute = {}


<span class="comment">--- Build CAP Route.
</span><span class="comment">--
</span><span class="comment">-- Constructs a route for Combat Air Patrol (CAP) operations based on the given group and packet.
</span><span class="comment">-- This function defines the waypoints and tasks for a CAP operation.
</span><span class="comment">-- It sets the aircraft to orbit a specified racetrack while being ready to engage targets within a designated zone.
</span><span class="comment">--
</span><span class="comment">-- @param spawnGroup_ The group for which the CAP route is to be constructed.
</span><span class="comment">-- @param Packet The data packet containing details for route construction.
</span><span class="comment">-- @return route The constructed CAP route.
</span><a id="1047"></a><span class="comment">-- @usage local capRoute = SPECTRE.AI.buildRoute.CAP(someGroup, somePacket)
</span><span class="keyword">function</span> SPECTRE.AI.buildRoute.CAP(spawnGroup_, Packet)

  <span class="comment">-- Define altitude based on the inbound waypoint's altitude
</span>  <span class="keyword">local</span> Alt = Packet.wptInboundToD.y

  <span class="comment">-- Create enroute tasks to engage targets in the specified zone
</span>  <span class="keyword">local</span> enroutetasks = {
    spawnGroup_:EnRouteTaskEngageTargetsInZone(Packet.Cap_Marker_Coord:GetVec2(), Packet.Zone_Engage, {<span class="string">"Air"</span>})
  }

  <span class="comment">-- Define the waypoints for the route
</span>  <span class="keyword">local</span> route = {
    <span class="comment">-- Inbound waypoint to the designated area
</span>    Packet.wptInboundToD:WaypointAir(COORDINATE.WaypointAltType.BARO, COORDINATE.WaypointType.TurningPoint, COORDINATE.WaypointAction.FlyoverPoint, UTILS.MpsToKmph(Packet.speed), <span class="keyword">false</span>),
    <span class="comment">-- Start of the racetrack orbit
</span>    Packet.RacetrackStart:WaypointAir(COORDINATE.WaypointAltType.BARO, COORDINATE.WaypointType.TurningPoint, COORDINATE.WaypointAction.TurningPoint, UTILS.MpsToKmph(Packet.speed), <span class="keyword">false</span>)
  }

  <span class="comment">-- Assign the enroute tasks to each waypoint in the route
</span>  <span class="keyword">for</span> _, r <span class="keyword">in</span> <span class="global">ipairs</span>(route) <span class="keyword">do</span>
    r.task = spawnGroup_:TaskCombo(enroutetasks)
  <span class="keyword">end</span>

  <span class="comment">-- Define tasks for the aircraft to orbit the racetrack and engage targets in the zone
</span>  <span class="keyword">local</span> tasks = {
    spawnGroup_:TaskOrbit(Packet.RacetrackStart, Alt, Packet.speed, Packet.RacetrackEnd),
    spawnGroup_:EnRouteTaskEngageTargetsInZone(Packet.Cap_Marker_Coord:GetVec2(), Packet.Zone_Engage, {<span class="string">"Air"</span>})
  }

  <span class="comment">-- Assign the combined tasks to the last waypoint in the route
</span>  route[#route].task = spawnGroup_:TaskCombo(tasks)

  <span class="keyword">return</span> route
<span class="keyword">end</span>

<span class="comment">--- Build Bomber Route.
</span><span class="comment">--
</span><span class="comment">-- Constructs a route for bomber operations based on the given group and packet.
</span><span class="comment">-- This function defines the waypoints for the bomber, including the ingress and egress points of its bombing run.
</span><span class="comment">--
</span><span class="comment">-- @param spawnGroup_ The group for which the bomber route is to be constructed.
</span><span class="comment">-- @param Packet The data packet containing details for route construction.
</span><span class="comment">-- @return route The constructed bomber route.
</span><a id="1091"></a><span class="comment">-- @usage local bomberRoute = SPECTRE.AI.buildRoute.BOMBER(someGroup, somePacket)
</span><span class="keyword">function</span> SPECTRE.AI.buildRoute.BOMBER(spawnGroup_, Packet)

  <span class="comment">-- Define the waypoints for the route
</span>  <span class="keyword">local</span> route = {
    <span class="comment">-- Initial Point (IP) or ingress point for the bomber to begin its attack run
</span>    Packet.wptIP:WaypointAirTurningPoint(COORDINATE.WaypointAltType.BARO, UTILS.KnotsToKmph(<span class="number">550</span>), {Packet.bombTask}, <span class="string">"Attack Ingress"</span>),
    <span class="comment">-- Outbound waypoint or end point after the attack is completed
</span>    Packet.wptOutboundToD:WaypointAirTurningPoint(COORDINATE.WaypointAltType.BARO, UTILS.KnotsToKmph(<span class="number">550</span>), {}, <span class="string">"End Mission"</span>)
  }

  <span class="keyword">return</span> route
<span class="keyword">end</span>

<span class="comment">--- Build Strike Route.
</span><span class="comment">--
</span><span class="comment">-- Constructs a simple route for strike operations based on the information provided in the <code>Packet</code> parameter.
</span><span class="comment">--
</span><span class="comment">-- @param spawnGroup_ The group for which the strike route is to be constructed.
</span><span class="comment">-- @param Packet The data packet containing details for route construction.
</span><span class="comment">-- @return route The constructed strike route.
</span><a id="1112"></a><span class="comment">-- @usage local strikeRoute = SPECTRE.AI.buildRoute.STRIKE(someGroup, somePacket)
</span><span class="keyword">function</span> SPECTRE.AI.buildRoute.STRIKE(spawnGroup_, Packet)

  <span class="comment">-- Define the waypoints for the strike route
</span>  <span class="keyword">local</span> route = {
    <span class="comment">-- Initial waypoint for the strike group
</span>    Packet.WPT1,
    <span class="comment">-- Waypoint at the target location
</span>    Packet.WPT_Target,
    <span class="comment">-- Waypoint after the target location
</span>    Packet.WPT2
  }

  <span class="keyword">return</span> route
<span class="keyword">end</span>

<span class="comment">--- Build Airdrop Route.
</span><span class="comment">--
</span><span class="comment">-- Constructs a simple route for airdrop operations based on the information provided in the <code>Packet</code> parameter.
</span><span class="comment">--
</span><span class="comment">-- @param spawnGroup_ The group that will execute the airdrop operation.
</span><span class="comment">-- @param Packet The data packet containing details for route construction.
</span><span class="comment">-- @return route The constructed airdrop route.
</span><a id="1135"></a><span class="comment">-- @usage local airdropRoute = SPECTRE.AI.buildRoute.AIRDROP(someGroup, somePacket)
</span><span class="keyword">function</span> SPECTRE.AI.buildRoute.AIRDROP(spawnGroup_, Packet)

  <span class="comment">-- Define the waypoints for the airdrop route
</span>  <span class="keyword">local</span> route = {
    <span class="comment">-- Initial waypoint for the airdrop group
</span>    Packet.WPT1,
    <span class="comment">-- Waypoint at the airdrop target location
</span>    Packet.WPT_Target,
    <span class="comment">-- Waypoint after the airdrop target location
</span>    Packet.WPT2
  }

  <span class="keyword">return</span> route
<span class="keyword">end</span></pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2023-11-26 07:35:37 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
