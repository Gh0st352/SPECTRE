<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>S.P.E.C.T.R.E.</h1>


<ul>
  <li><a href="../manual.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="nowrap">
  <li><a href="../source/ai.lua.html">ai.lua</a></li>
  <li><a href="../source/brain.lua.html">brain.lua</a></li>
  <li><a href="../source/handlers.lua.html">handlers.lua</a></li>
  <li><a href="../source/iads.lua.html">iads.lua</a></li>
  <li><strong>io.lua</strong></li>
  <li><a href="../source/markers.lua.html">markers.lua</a></li>
  <li><a href="../source/menu.lua.html">menu.lua</a></li>
  <li><a href="../source/plyrmgr.lua.html">plyrmgr.lua</a></li>
  <li><a href="../source/poly.lua.html">poly.lua</a></li>
  <li><a href="../source/rewards.lua.html">rewards.lua</a></li>
  <li><a href="../source/spawner.lua.html">spawner.lua</a></li>
  <li><a href="../source/spectre.lua.html">spectre.lua</a></li>
  <li><a href="../source/utils.lua.html">utils.lua</a></li>
  <li><a href="../source/world.lua.html">world.lua</a></li>
  <li><a href="../source/zonemgr.lua.html">zonemgr.lua</a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/AI.html">AI</a></li>
  <li><a href="../modules/BRAIN.html">BRAIN</a></li>
  <li><a href="../modules/HANDLERS.html">HANDLERS</a></li>
  <li><a href="../modules/IADS.html">IADS</a></li>
  <li><a href="../modules/IO.html">IO</a></li>
  <li><a href="../modules/MARKERS.html">MARKERS</a></li>
  <li><a href="../modules/MENU.html">MENU</a></li>
  <li><a href="../modules/PLYRMGR.html">PLYRMGR</a></li>
  <li><a href="../modules/POLY.html">POLY</a></li>
  <li><a href="../modules/REWARDS.html">REWARDS</a></li>
  <li><a href="../modules/SPAWNER.html">SPAWNER</a></li>
  <li><a href="../modules/SPECTRE.html">SPECTRE</a></li>
  <li><a href="../modules/UTILS.html">UTILS</a></li>
  <li><a href="../modules/WORLD.html">WORLD</a></li>
  <li><a href="../modules/ZONEMGR.html">ZONEMGR</a></li>
</ul>
<h2>Topics</h2>
<ul class="">
  <li><a href="../topics/readme.md.html">readme</a></li>
</ul>

</div>

<div id="content">

    <h2>io.lua</h2>
<pre>
<span class="comment">--- **IO**
</span><span class="comment">--
</span><span class="comment">-- File and Object Management Utilities for SPECTRE.
</span><span class="comment">--
</span><span class="comment">--   * Provides functionality to read, write, and manage files.
</span><span class="comment">--
</span><span class="comment">--   * Enables object serialization to and from persistent storage.
</span><span class="comment">--
</span><span class="comment">--   * Offers utilities to check and ensure directory and file existence.
</span><span class="comment">--
</span><span class="comment">--      For example, you can easily serialize game state data, save it to a file, and load it back when needed.
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- @module IO
</span><span class="comment">-- @extends SPECTRE
</span>
<span class="comment">--- IO.
</span><span class="comment">--
</span><span class="comment">-- This module encompasses utilities and methods related to input/output operations, particularly those concerning file handling and object persistence.
</span><span class="comment">-- With these functionalities, developers can perform tasks like saving game states, loading configurations, or managing in-game databases more efficiently.
</span><span class="comment">--
</span><span class="comment">-- @section SPECTRE.IO
</span><span class="comment">-- @field #IO
</span>SPECTRE.IO = {}


<span class="comment">--- Files &amp; Folders.
</span><span class="comment">-- ===
</span><span class="comment">--
</span><span class="comment">-- *All Functions associated with Files &amp; Folders operations.*
</span><span class="comment">--
</span><span class="comment">-- ===
</span><span class="comment">-- @section SPECTRE.IO
</span>
<span class="comment">--- Checks if a directory exists and creates it if not.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- This function checks for the existence of a specified directory.
</span><span class="comment">-- If the directory does not exist, it will be created.
</span><span class="comment">--
</span><span class="comment">-- @param Dir The path of the directory to check.
</span><a id="45"></a><span class="comment">-- @usage SPECTRE.IO.DirExists("path/to/directory") -- Checks and possibly creates the directory at the specified path.
</span><span class="keyword">function</span> SPECTRE.IO.DirExists(Dir)
  <span class="comment">-- If the directory does not exist, create it
</span>  <span class="keyword">if</span> <span class="keyword">not</span> lfs.attributes(Dir) <span class="keyword">then</span>
    lfs.mkdir(Dir)
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Checks if a file exists and creates it if not.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- This function checks for the existence of a specified file.
</span><span class="comment">-- If the file does not exist, an empty file will be created.
</span><span class="comment">-- Any errors encountered during file creation are currently not handled.
</span><span class="comment">--
</span><span class="comment">-- @param File The path of the file to check.
</span><a id="62"></a><span class="comment">-- @usage SPECTRE.IO.FileExists("path/to/file.txt") -- Checks and possibly creates the file at the specified path.
</span><span class="keyword">function</span> SPECTRE.IO.FileExists(File)
  <span class="comment">-- If the file does not exist, create it
</span>  <span class="keyword">if</span> <span class="keyword">not</span> lfs.attributes(File) <span class="keyword">then</span>
    <span class="keyword">local</span> file = <span class="global">io</span>.open(File, <span class="string">"w"</span>)
    <span class="keyword">if</span> file <span class="keyword">then</span>
      file:close()
    <span class="keyword">else</span>
    <span class="comment">-- TODO: Error handling?
</span>    <span class="keyword">end</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">--- Extracts the filename and path from a full filepath.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- This function breaks a given full filepath into its constituent filename and path.
</span><span class="comment">--
</span><span class="comment">-- @param filepath The full filepath to process.
</span><span class="comment">-- @return filePath_ The path without the filename.
</span><span class="comment">-- @return filename The extracted filename from the filepath.
</span><a id="84"></a><span class="comment">-- @usage local path, name = SPECTRE.IO.extractFilenameAndPath("path/to/myFile.txt") -- Extracts "/path/to/" as path and "myFile.txt" as name.
</span><span class="keyword">function</span> SPECTRE.IO.extractFilenameAndPath(filepath)
  <span class="comment">-- Use the string.match function with a pattern to extract the filename.
</span>  <span class="keyword">local</span> filename = <span class="global">string</span>.match(filepath, <span class="string">"[^/\\]+$"</span>)
  <span class="comment">-- Use string.sub to extract the part of the filepath before the filename.
</span>  <span class="keyword">local</span> filePath_ = <span class="global">string</span>.sub(filepath, <span class="number">1</span>, -(<span class="global">string</span>.len(filename) + <span class="number">1</span>))

  <span class="comment">-- If the filepath uses backslashes as separators on Windows, you can modify the pattern like this:
</span>  filePath_ = SPECTRE.IO.removeLastSlashOrBackslash(filePath_)
  <span class="keyword">return</span> filePath_, filename
<span class="keyword">end</span>

<span class="comment">--- Loads an object from a specified filepath.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- This function takes a full filepath as input and extracts the directory path and filename using the <code>SPECTRE.IO.extractFilenameAndPath</code> method.
</span><span class="comment">-- It then constructs the absolute path to the file and attempts to load an object from it using the <code>SPECTRE.IO.persistence.load</code> method.
</span><span class="comment">--
</span><span class="comment">-- @param filepath The full filepath from which to load the object.
</span><span class="comment">-- @return Object The object loaded from the file, or nil if the file does not contain a valid object.
</span><a id="105"></a><span class="comment">-- @usage local myObject = SPECTRE.IO.PersistenceFromFile("path/to/myFile.txt") -- Loads the object from the specified filepath.
</span><span class="keyword">function</span> SPECTRE.IO.PersistenceFromFile(filepath)
  <span class="keyword">local</span> filepath_, filename = SPECTRE.IO.extractFilenameAndPath(filepath)
  <span class="comment">-- Construct the full path to the file
</span>  <span class="keyword">local</span> _Path  = lfs.writedir() .. filepath_
  <span class="keyword">local</span> _File = _Path .. <span class="string">"/"</span> .. filename
  <span class="comment">-- Load the object from the file
</span>  <span class="keyword">local</span> Object = SPECTRE.IO.persistence.<span class="global">load</span>(_File)

  <span class="keyword">return</span> Object
<span class="keyword">end</span>

<span class="comment">--- Removes the trailing slash or backslash from a string.
</span><span class="comment">--
</span><span class="comment">--  ???
</span><span class="comment">--
</span><span class="comment">-- This function examines the last character of an input string. If the last character is either a slash ('/') or a backslash ('\\'),
</span><span class="comment">-- the function removes it and returns the modified string. If the last character is not a slash or backslash, the function returns the input string unmodified.
</span><span class="comment">--
</span><span class="comment">-- @param inputString The string from which to potentially remove a trailing slash or backslash.
</span><span class="comment">-- @return string The modified string without a trailing slash or backslash, or the original string if no modification was made.
</span><a id="126"></a><span class="comment">-- @usage local newPath = SPECTRE.IO.removeLastSlashOrBackslash("path/to/directory/") -- Returns "/path/to/directory".
</span><span class="keyword">function</span> SPECTRE.IO.removeLastSlashOrBackslash(inputString)
  <span class="keyword">local</span> lastChar = inputString:sub(-<span class="number">1</span>)

  <span class="keyword">if</span> lastChar == <span class="string">'/'</span> <span class="keyword">or</span> lastChar == <span class="string">'\\' then
    return inputString:sub(1, -2) -- Remove the last character
  else
    return inputString -- Return the input string as is
  end
end

--- Saves an object to a specified file within the SPECTRE directory.
--
--  @{SPECTRE.IO.PersistenceToFile}
--
-- This function takes an object and a filepath as arguments. It constructs a full path to the file,
-- ensures the directory and file exist (creating them if necessary), and then saves the object to the file.
-- The object is saved using the `SPECTRE.IO.persistence.store` method.
--
-- @param filepath The path to the file where the object should be saved.
-- @param Object The object to be saved to the file.
-- @param noFunc (Optional, if true does not export functions)
-- @usage SPECTRE.IO.PersistenceToFile("path/to/file.txt", myObject) -- Saves the `myObject` to "file.txt" within the specified path in the SPECTRE directory.
function SPECTRE.IO.PersistenceToFile(filepath, Object, noFunc)
  noFunc = noFunc or false
  local filepath_, filename = SPECTRE.IO.extractFilenameAndPath(filepath)
  -- Construct the full path to the file
  local _Path  = lfs.writedir() .. filepath_
  --  SPECTRE.UTILS.debugInfo("_Path",_Path)
  local _File = _Path .. "/" .. filename

  -- Ensure the directory and file exist
  SPECTRE.IO.DirExists(_Path)
  SPECTRE.IO.FileExists(_File)

  if noFunc then
    SPECTRE.IO.persistence.storeNoFunc(_File, Object)
  else
    -- Store the object in the file
    SPECTRE.IO.persistence.store(_File, Object)
  end
end

--- Determines the existence of a file at a specified path.
--
--  @{SPECTRE.IO.file_exists}
--
-- A utility function designed to check the existence of a file at a given path. It tries to open the file for reading.
-- If the file is accessible, it confirms its existence by returning true. If the file cannot be accessed or does not exist, it returns false.
--
-- @param filePath The absolute or relative path of the file to be verified.
-- @return true Indicates the file exists.
-- @return false Indicates the file does not exist.
-- @usage local fileExists = SPECTRE.IO.file_exists("data/files/file.txt") -- Verifies the existence of "file.txt" in the "data/files" directory.
function SPECTRE.IO.file_exists(filePath)

  -- Attempt to open the file for reading
  local file = io.open(lfs.writedir() .. filePath, "r")

  if (file) then
    file:close()  -- Close the file if it was successfully opened
    return true   -- File exists
  else
    return false  -- File does not exist
  end
end

do
  local write, writeNoFunc, writeSerialString, writeIndent, writeIndentSerial, writers, writersNoFunc, writersSerialString, refCount;

  --- Internal Methods.
  --
  -- Not meant to be used directly, but can be.
  --
  --  *Stores persistence generation functions.*
  --
  -- Houses methods for interacting with files outside of the game.
  --
  -- ===
  --
  --     -Exports table of data from MissionScripting environment to text file
  --     -Imports table of data from text file to MissionScripting environment
  --     -Dumps table to string format
  --
  -- @section IO.persistence
  -- @field #persistence
  SPECTRE.IO.persistence = {}

  --- Transforms a table or value into its string representation.
  --
  --  @{SPECTRE.IO.persistence.dump}
  --
  -- A utility function crafted to convert a table into its string representation recursively.
  -- For any non-table values, the function will directly convert them into strings.
  --
  -- @param o The table or value that needs conversion.
  -- @return #string A string that represents the serialized form of the given table or value.
  -- @usage local serializedString = SPECTRE.IO.persistence.dump(dataTable) -- Retrieves the string format of `dataTable`.
  function SPECTRE.IO.persistence.dump(o)
    if type(o) == '</span><span class="global">table</span><span class="string">' then
      local s = '</span>{ <span class="string">'
      for k,v in pairs(o) do
        if type(k) ~= '</span>number<span class="string">' then k = '</span><span class="string">"'..k..'"</span><span class="string">' end
        s = s .. '</span>[<span class="string">'..k..'</span>] = <span class="string">' .. SPECTRE.IO.persistence.dump(v) .. '</span>,<span class="string">'
      end
      return s .. '</span>} <span class="string">'
    else
      return tostring(o)
    end
  end

  --- Persists multiple Lua values by serializing and saving them to a file.
  --
  --  @{SPECTRE.IO.persistence.store}
  --
  -- A utility function designed to serialize multiple Lua values, including tables, into a string format.
  -- It then writes the serialized string into a specified file. This method ensures efficient storage by
  -- avoiding redundant storage of duplicate table references.
  --
  -- @param path The path where the serialized values should be written.
  -- @param ... Lua values that need to be serialized and persisted.
  -- @usage SPECTRE.IO.persistence.store("destination/file.txt", dataTable1, dataTable2) -- Serializes and saves `dataTable1` and `dataTable2` to the defined file.
  function SPECTRE.IO.persistence.store(path, ...)
    local file, e = io.open(path, "w")
    if not file then
      return error(e)
    end

    local n = select("#", ...)
    -- Count references
    local objRefCount = {} -- Stores references that will be exported
    for i = 1, n do
      refCount(objRefCount, (select(i,...)))
    end

    -- Export Objects with more than one ref and assign name
    local objRefNames = {}
    local objRefIdx = 0
    file:write("-- Persistent Data\n")
    file:write("local multiRefObjects = {\n")
    for obj, count in pairs(objRefCount) do
      if count &gt; 1 then
        objRefIdx = objRefIdx + 1
        objRefNames[obj] = objRefIdx
        file:write("{};") -- table objRefIdx
      end
    end
    file:write("\n} -- multiRefObjects\n")

    -- Fill the multi-reference objects
    for obj, idx in pairs(objRefNames) do
      for k, v in pairs(obj) do
        file:write("multiRefObjects["..idx.."][")
        write(file, k, 0, objRefNames)
        file:write("] = ")
        write(file, v, 0, objRefNames)
        file:write(";\n")
      end
    end

    -- Create the remaining objects
    for i = 1, n do
      file:write("local obj"..i.." = ")
      write(file, (select(i,...)), 0, objRefNames)
      file:write("\n")
    end

    -- Return the serialized values
    if n &gt; 0 then
      file:write("return obj1")
      for i = 2, n do
        file:write(", obj"..i)
      end
      file:write("\n")
    else
      file:write("return\n")
    end

    if type(path) == "string" then
      file:close()
    end
  end

  ---  NO FUNCTION OUTPUT VERSION.
  -- @param path The path where the serialized values should be written.
  -- @param ... Lua values that need to be serialized and persisted.
  -- @usage SPECTRE.IO.persistence.store("destination/file.txt", dataTable1, dataTable2) -- Serializes and saves `dataTable1` and `dataTable2` to the defined file.
  function SPECTRE.IO.persistence.storeNoFunc(path, ...)
    local file, e = io.open(path, "w")
    if not file then
      return error(e)
    end

    local n = select("#", ...)
    -- Count references
    local objRefCount = {} -- Stores references that will be exported
    for i = 1, n do
      refCount(objRefCount, (select(i,...)))
    end

    -- Export Objects with more than one ref and assign name
    local objRefNames = {}
    local objRefIdx = 0
    file:write("-- Persistent Data\n")
    file:write("local multiRefObjects = {\n")
    for obj, count in pairs(objRefCount) do
      if count &gt; 1 then
        objRefIdx = objRefIdx + 1
        objRefNames[obj] = objRefIdx
        file:write("{};") -- table objRefIdx
      end
    end
    file:write("\n} -- multiRefObjects\n")

    -- Fill the multi-reference objects
    for obj, idx in pairs(objRefNames) do
      for k, v in pairs(obj) do
        file:write("multiRefObjects["..idx.."][")
        writeNoFunc(file, k, 0, objRefNames)
        file:write("] = ")
        writeNoFunc(file, v, 0, objRefNames)
        file:write(";\n")
      end
    end

    -- Create the remaining objects
    for i = 1, n do
      file:write("local obj"..i.." = ")
      writeNoFunc(file, (select(i,...)), 0, objRefNames)
      file:write("\n")
    end

    -- Return the serialized values
    if n &gt; 0 then
      file:write("return obj1")
      for i = 2, n do
        file:write(", obj"..i)
      end
      file:write("\n")
    else
      file:write("return\n")
    end

    if type(path) == "string" then
      file:close()
    end
  end

  function SPECTRE.IO.persistence.serializeNoFunc(...)
    --SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | ------------------------- ")
    local serialString_ = ""

    local n = select("#", ...)

    --SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | Count references ~~~~~ ")
    -- Count references
    local objRefCount = {} -- Stores references that will be exported
    for i = 1, n do
      refCount(objRefCount, (select(i,...)))
    end

    --SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | Export Objects with more than one ref and assign name ~~~~~ ")
    -- Export Objects with more than one ref and assign name
    local objRefNames = {}
    local objRefIdx = 0
    serialString_ = serialString_ .. ("-- Persistent Data\n")
    serialString_ = serialString_ .. ("local multiRefObjects = {\n")
    for obj, count in pairs(objRefCount) do
      if count &gt; 1 then
        objRefIdx = objRefIdx + 1
        objRefNames[obj] = objRefIdx
        serialString_ = serialString_ .. ("{};") -- table objRefIdx
      end
    end
    serialString_ = serialString_ .. ("\n} -- multiRefObjects\n")

    --SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | serialString_ : " .. serialString_)
    --SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | Fill the multi-reference objects ~~~~~ ")
    -- Fill the multi-reference objects
    for obj, idx in pairs(objRefNames) do
      for k, v in pairs(obj) do
        serialString_ = serialString_ .. ("multiRefObjects["..idx.."][")
        serialString_ = writeSerialString(serialString_, k, 0, objRefNames)
        serialString_ = serialString_ .. ("] = ")
        serialString_ = writeSerialString(serialString_, v, 0, objRefNames)
        serialString_ = serialString_ .. (";\n")
      end
    end
    --SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | serialString_ : " .. serialString_)
    --SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | Create the remaining objects ~~~~~ ")
    -- Create the remaining objects
    for i = 1, n do
      serialString_ = serialString_ .. ("local obj"..i.." = ")
      serialString_ = writeSerialString(serialString_, (select(i,...)), 0, objRefNames)
      serialString_ = serialString_ .. ("\n")
    end
    --SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | serialString_ : " .. serialString_)
    --SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | Return the serialized values ~~~~~ ")
    -- Return the serialized values
    if n &gt; 0 then
      serialString_ = serialString_ .. ("return obj1")
      for i = 2, n do
        serialString_ = serialString_ .. (", obj"..i)
      end
      serialString_ = serialString_ .. ("\n")
    else
      serialString_ = serialString_ .. ("return\n")
    end
    --SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | serialString_ : " .. serialString_)
    return serialString_
  end


  --- Loads and executes Lua content from the specified path or file object.
  --
  --  @{SPECTRE.IO.persistence.load}
  --
  -- This utility function reads, loads, and executes Lua content from a given file path or a file-like object.
  -- If the content is successfully loaded and executed, the result of the execution is returned.
  -- In case of an error during loading, it returns `nil` alongside an error message.
  --
  -- @param serialString_
  -- @return e The result of the Lua content execution, or `nil` and an associated error message if an error occurs.
  -- @usage local executionResult = SPECTRE.IO.persistence.load("directory/luaScript.lua") -- Loads and executes the Lua script at the defined path.
  function SPECTRE.IO.persistence.deSerialize(serialString_)
    -- Attempt to load the serialized data string as a Lua chunk
    local f, e = loadstring(serialString_)
    if f then
      -- Execute the chunk to deserialize it into Lua objects
      return f()
    else
      -- Return nil and the error if the chunk cannot be loaded
      return nil, e
    end
  end

  --- Loads and executes Lua content from the specified path or file object.
  --
  --  @{SPECTRE.IO.persistence.load}
  --
  -- This utility function reads, loads, and executes Lua content from a given file path or a file-like object.
  -- If the content is successfully loaded and executed, the result of the execution is returned.
  -- In case of an error during loading, it returns `nil` alongside an error message.
  --
  -- @param path The path to the Lua file, or a file-like object containing Lua content.
  -- @return e The result of the Lua content execution, or `nil` and an associated error message if an error occurs.
  -- @usage local executionResult = SPECTRE.IO.persistence.load("directory/luaScript.lua") -- Loads and executes the Lua script at the defined path.
  function SPECTRE.IO.persistence.load(path)
    local f, e
    if type(path) == "string" then
      f, e = loadfile(path)
    else
      f, e = path:read('</span>*a<span class="string">')
    end
    if f then
      return f()
    else
      return nil, e
    end
  end

  -- Private methods

  --- Writes the provided item to the file using the appropriate writer based on the item'</span>s <span class="global">type</span>.
  <span class="comment">--
</span>  <span class="comment">-- This function selects a writer function based on the type of the provided item and then invokes it.
</span>  <span class="comment">-- The writer functions are expected to be stored in the <code>writers</code> table, indexed by the item type.
</span>  <span class="comment">--
</span>  <span class="comment">-- @param file The file object to write to.
</span>  <span class="comment">-- @param item The item to be written.
</span>  <span class="comment">-- @param level The current nesting level (used for recursive calls).
</span>  <span class="comment">-- @param objRefNames A table of object reference names (used for recursive calls).
</span>  <span class="comment">-- @param skipFunctions (optional, default false)if true will insert placeholder text for func instead of data.
</span>  <span class="comment">-- @usage write(myFile, myItem, 0, {}) -- Writes <code>myItem</code> to <code>myFile</code> using the appropriate writer.
</span>  write = <span class="keyword">function</span> (file, item, level, objRefNames)
    writers[<span class="global">type</span>(item)](file, item, level, objRefNames)
  <span class="keyword">end</span>

  <span class="comment">--- NO FUNCTION OUTPUT VERSION.
</span>  <span class="comment">--
</span>  <span class="comment">-- @param file The file object to write to.
</span>  <a id="148"></a><span class="comment">-- @param item The item to be written.
</span>  <span class="comment">-- @param level The current nesting level (used for recursive calls).
</span>  <span class="comment">-- @param objRefNames A table of object reference names (used for recursive calls).
</span>  <span class="comment">-- @param skipFunctions (optional, default false)if true will insert placeholder text for func instead of data.
</span>  <span class="comment">-- @usage write(myFile, myItem, 0, {}) -- Writes <code>myItem</code> to <code>myFile</code> using the appropriate writer.
</span>  writeNoFunc = <span class="keyword">function</span> (file, item, level, objRefNames)
    writersNoFunc[<span class="global">type</span>(item)](file, item, level, objRefNames)
  <span class="keyword">end</span>

  <span class="comment">---  serial OUTPUT VERSION.
</span>  <span class="comment">--
</span>  <span class="comment">-- @param serialString_ The file object to write to.
</span>  <span class="comment">-- @param item The item to be written.
</span>  <span class="comment">-- @param level The current nesting level (used for recursive calls).
</span>  <span class="comment">-- @param objRefNames A table of object reference names (used for recursive calls).
</span>  <span class="comment">-- @param skipFunctions (optional, default false)if true will insert placeholder text for func instead of data.
</span>  <span class="comment">-- @usage write(myFile, myItem, 0, {}) -- Writes <code>myItem</code> to <code>myFile</code> using the appropriate writer.
</span>  writeSerialString = <span class="keyword">function</span> (serialString_, item, level, objRefNames)
<span class="comment">--    SPECTRE.UTILS.debugInfo("SPECTRE.IO.serializeNoFunc | START writeSerialString | ------------------")
</span><span class="comment">--    SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | pre serialString_ : " .. serialString_)
</span><span class="comment">--    SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | item : " , item)
</span><span class="comment">--    SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | level : " .. level)
</span><span class="comment">--    SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | objRefNames : " , objRefNames)
</span>    <span class="keyword">return</span> writersSerialString[<span class="global">type</span>(item)](serialString_, item, level, objRefNames)
  <span class="keyword">end</span>

  <span class="comment">--- Writes indentation to the provided file.
</span>  <span class="comment">--
</span>  <span class="comment">-- This function writes a specified number of tab characters to the given file, creating an indentation effect.
</span>  <span class="comment">--
</span>  <span class="comment">-- @param file The file object to write to.
</span>  <a id="179"></a><span class="comment">-- @param level The number of tab characters to write.
</span>  <span class="comment">-- @usage writeIndent(myFile, 3) -- Writes 3 tab characters to <code>myFile</code> for indentation.
</span>  writeIndent = <span class="keyword">function</span> (file, level)
    <span class="keyword">for</span> i = <span class="number">1</span>, level <span class="keyword">do</span>
      file:write(<span class="string">"\t"</span>)
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  writeIndentSerial = <span class="keyword">function</span> (serialString_, level)
<span class="comment">--    SPECTRE.UTILS.debugInfo("SPECTRE.IO.serializeNoFunc | writeIndentSerial | ------------------")
</span><span class="comment">--    SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | serialString_ : " .. serialString_)
</span><span class="comment">--    SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | level : " .. level)
</span>    <span class="keyword">for</span> i = <span class="number">1</span>, level <span class="keyword">do</span>
      serialString_ = serialString_ .. (<span class="string">"  "</span>)
    <span class="keyword">end</span>
    <span class="keyword">return</span> serialString_
  <span class="keyword">end</span>

  <span class="comment">--- Counts references for tables recursively.
</span>  <span class="comment">--
</span>  <span class="comment">-- This function increases the reference count for tables. When encountering a table for the first time,
</span>  <span class="comment">-- it counts its references and then recursively counts the references of its keys and values.
</span>  <span class="comment">--
</span>  <span class="comment">-- @param objRefCount A table that stores reference counts for other tables.
</span>  <span class="comment">-- @param item The item (potentially a table) whose references are to be counted.
</span>  <span class="comment">-- @usage refCount(objRefCountTable, myTable) -- Counts references for <code>myTable</code> and updates <code>objRefCountTable</code>.
</span>  refCount = <span class="keyword">function</span> (objRefCount, item)
    <span class="comment">--SPECTRE.UTILS.debugInfo("SPECTRE.IO:refCount | ~~~~~ ")
</span>    <span class="comment">-- only count reference types (tables)
</span>    <span class="keyword">if</span> <span class="global">type</span>(item) == <span class="string">"table"</span> <span class="keyword">then</span>
      <span class="comment">-- Increase ref count
</span>      <span class="keyword">if</span> objRefCount[item] <span class="keyword">then</span>
        objRefCount[item] = objRefCount[item] + <span class="number">1</span>
      <span class="keyword">else</span>
        objRefCount[item] = <span class="number">1</span>
        <span class="comment">-- If first encounter, traverse
</span>        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="global">pairs</span>(item) <span class="keyword">do</span>
          refCount(objRefCount, k)
          refCount(objRefCount, v)
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
  <span class="keyword">end</span>

  <a id="223"></a><span class="comment">--- Table of writer functions for serializing various types of Lua data.
</span>  <span class="comment">--
</span>  <span class="comment">-- Each function in this table converts a Lua value of a specific type into a string representation suitable for storing in a file.
</span>  writers = {
    [<span class="string">"nil"</span>] = <span class="keyword">function</span>(file)
      file:write(<span class="string">"nil"</span>)
    <span class="keyword">end</span>,

    [<span class="string">"number"</span>] = <span class="keyword">function</span>(file, item)
      file:write(<span class="global">tostring</span>(item))
    <span class="keyword">end</span>,

    [<span class="string">"string"</span>] = <span class="keyword">function</span>(file, item)
      file:write(<span class="global">string</span>.format(<span class="string">"%q"</span>, item))
    <span class="keyword">end</span>,

    [<span class="string">"boolean"</span>] = <span class="keyword">function</span>(file, item)
      <span class="keyword">if</span> item <span class="keyword">then</span>
        file:write(<span class="string">"true"</span>)
      <span class="keyword">else</span>
        file:write(<span class="string">"false"</span>)
      <span class="keyword">end</span>
    <span class="keyword">end</span>,

    [<span class="string">"table"</span>] = <span class="keyword">function</span>(file, item, level, objRefNames)<a id="247"></a>
      <span class="keyword">local</span> refIdx = objRefNames[item]
      <span class="keyword">if</span> refIdx <span class="keyword">then</span>
        file:write(<span class="string">"multiRefObjects["</span>..refIdx..<span class="string">"]"</span>)
      <span class="keyword">else</span>
        file:write(<span class="string">"{\n"</span>)
        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="global">pairs</span>(item) <span class="keyword">do</span>
          writeIndent(file, level+<span class="number">1</span>)
          file:write(<span class="string">"["</span>)
          write(file, k, level+<span class="number">1</span>, objRefNames)
          file:write(<span class="string">"] = "</span>)
          write(file, v, level+<span class="number">1</span>, objRefNames)
          file:write(<span class="string">";\n"</span>)
        <span class="keyword">end</span>
        writeIndent(file, level)
        file:write(<span class="string">"}"</span>)
      <span class="keyword">end</span>
    <span class="keyword">end</span>,

    [<span class="string">"function"</span>] = <span class="keyword">function</span>(file, item)
      <span class="keyword">local</span> dInfo = <span class="global">debug</span>.getinfo(item, <span class="string">"uS"</span>)
      <span class="keyword">if</span> dInfo.nups &gt; <span class="number">0</span> <span class="keyword">then</span>
        file:write(<span class="string">"nil --[[functions with upvalue not supported]]"</span>)
      <span class="keyword">elseif</span> dInfo.what ~= <span class="string">"Lua"</span> <span class="keyword">then</span>
        file:write(<span class="string">"nil --[[non-lua function not supported]]"</span>)
      <span class="keyword">else</span>
        <span class="keyword">local</span> r, s = <span class="global">pcall</span>(<span class="global">string</span>.dump,item)
        <span class="keyword">if</span> r <span class="keyword">then</span>
          file:write(<span class="global">string</span>.format(<span class="string">"loadstring(%q)"</span>, s))
        <span class="keyword">else</span>
          file:write(<span class="string">"nil --[[function could not be dumped]]"</span>)
        <span class="keyword">end</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>,

    [<span class="string">"thread"</span>] = <span class="keyword">function</span>(file)
      file:write(<span class="string">"nil --[[thread]]"</span>)
    <span class="keyword">end</span>,

    [<span class="string">"userdata"</span>] = <span class="keyword">function</span>(file)
      file:write(<span class="string">"nil --[[userdata]]"</span>)
    <span class="keyword">end</span>
  }

  <span class="comment">--- NO FUNCTION OUTPUT VERSION.
</span>  writersNoFunc = {
    [<span class="string">"nil"</span>] = <span class="keyword">function</span>(file)
      file:write(<span class="string">"nil"</span>)
    <span class="keyword">end</span>,

    [<span class="string">"number"</span>] = <span class="keyword">function</span>(file, item)
      file:write(<span class="global">tostring</span>(item))
    <span class="keyword">end</span>,

    [<span class="string">"string"</span>] = <span class="keyword">function</span>(file, item)
      file:write(<span class="global">string</span>.format(<span class="string">"%q"</span>, item))
    <span class="keyword">end</span>,

    [<span class="string">"boolean"</span>] = <span class="keyword">function</span>(file, item)
      <span class="keyword">if</span> item <span class="keyword">then</span>
        file:write(<span class="string">"true"</span>)
      <span class="keyword">else</span>
        file:write(<span class="string">"false"</span>)
      <span class="keyword">end</span>
    <span class="keyword">end</span>,<a id="312"></a>

    [<span class="string">"table"</span>] = <span class="keyword">function</span>(file, item, level, objRefNames)
      <span class="keyword">local</span> refIdx = objRefNames[item]
      <span class="keyword">if</span> refIdx <span class="keyword">then</span>
        file:write(<span class="string">"multiRefObjects["</span>..refIdx..<span class="string">"]"</span>)
      <span class="keyword">else</span>
        file:write(<span class="string">"{\n"</span>)
        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="global">pairs</span>(item) <span class="keyword">do</span>
          writeIndent(file, level+<span class="number">1</span>)
          file:write(<span class="string">"["</span>)
          writeNoFunc(file, k, level+<span class="number">1</span>, objRefNames)
          file:write(<span class="string">"] = "</span>)
          writeNoFunc(file, v, level+<span class="number">1</span>, objRefNames)
          file:write(<span class="string">";\n"</span>)
        <span class="keyword">end</span>
        writeIndent(file, level)
        file:write(<span class="string">"}"</span>)
      <span class="keyword">end</span>
    <span class="keyword">end</span>,

    [<span class="string">"function"</span>] = <span class="keyword">function</span>(file, item)
      file:write(<span class="string">"nil --[[INTENDEDSKIP]]"</span>)
    <span class="keyword">end</span>,

    [<span class="string">"thread"</span>] = <span class="keyword">function</span>(file)
      file:write(<span class="string">"nil --[[thread]]"</span>)
    <span class="keyword">end</span>,

    [<span class="string">"userdata"</span>] = <span class="keyword">function</span>(file)
      file:write(<span class="string">"nil --[[userdata]]"</span>)
    <span class="keyword">end</span>
  }
  <span class="comment">--- SERIAL OUTPUT VERSION.
</span>  <span class="comment">--
</span>  <span class="comment">--
</span>  <span class="comment">-- ---------------------------------------------
</span>  <span class="comment">--
</span>  <span class="comment">--
</span>  writersSerialString = {
    [<span class="string">"nil"</span>] = <span class="keyword">function</span>(serialString_)
      <span class="keyword">return</span> serialString_ .. (<span class="string">"nil"</span>)
    <span class="keyword">end</span>,

    [<span class="string">"number"</span>] = <span class="keyword">function</span>(serialString_, item)
      <span class="keyword">return</span> serialString_ .. (<span class="global">tostring</span>(item))
    <span class="keyword">end</span>,

    [<span class="string">"string"</span>] = <span class="keyword">function</span>(serialString_, item)
      <span class="keyword">return</span> serialString_ .. (<span class="global">string</span>.format(<span class="string">"%q"</span>, item))
    <span class="keyword">end</span>,

    [<span class="string">"boolean"</span>] = <span class="keyword">function</span>(serialString_, item)
      <span class="keyword">if</span> item <span class="keyword">then</span>
        <span class="keyword">return</span> serialString_ .. (<span class="string">"true"</span>)
      <span class="keyword">else</span>
        <span class="keyword">return</span> serialString_ .. (<span class="string">"false"</span>)
      <span class="keyword">end</span>
    <span class="keyword">end</span>,

    [<span class="string">"table"</span>] = <span class="keyword">function</span>(serialString_, item, level, objRefNames)
<span class="comment">--      SPECTRE.UTILS.debugInfo("SPECTRE.IO.serializeNoFunc | START writersSerialString | ------------------")
</span><span class="comment">--      SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | pre serialString_ : " .. serialString_)
</span><span class="comment">--      SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | item : " , item)
</span><span class="comment">--      SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | level : " .. level)
</span><span class="comment">--      SPECTRE.UTILS.debugInfo("SPECTRE.IO:serializeNoFunc | objRefNames : " , objRefNames)
</span>
      <span class="keyword">local</span> refIdx = objRefNames[item]
      <span class="keyword">if</span> refIdx <span class="keyword">then</span>
        serialString_ = serialString_ .. (<span class="string">"multiRefObjects["</span>..refIdx..<span class="string">"]"</span>)
      <span class="keyword">else</span>
        serialString_ = serialString_ .. (<span class="string">"{\n"</span>)
        <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="global">pairs</span>(item) <span class="keyword">do</span>

          serialString_ = writeIndentSerial(serialString_, level+<span class="number">1</span>)
          serialString_ = serialString_ .. (<span class="string">"["</span>)
          serialString_ = writeSerialString(serialString_, k, level+<span class="number">1</span>, objRefNames)
          serialString_ = serialString_ .. (<span class="string">"] = "</span>)
          serialString_ = writeSerialString(serialString_, v, level+<span class="number">1</span>, objRefNames)
          serialString_ = serialString_ .. (<span class="string">";\n"</span>)
        <span class="keyword">end</span>
        serialString_ = writeIndentSerial(serialString_, level)
        serialString_ = serialString_ .. (<span class="string">"}"</span>)
      <span class="keyword">end</span>
      <span class="keyword">return</span> serialString_
    <span class="keyword">end</span>,

    [<span class="string">"function"</span>] = <span class="keyword">function</span>(serialString_, item)
      <span class="keyword">return</span> serialString_ .. (<span class="string">"nil --[[INTENDEDSKIP]]"</span>)
    <span class="keyword">end</span>,

    [<span class="string">"thread"</span>] = <span class="keyword">function</span>(serialString_)
      <span class="keyword">return</span> serialString_ .. (<span class="string">"nil --[[thread]]"</span>)
    <span class="keyword">end</span>,

    [<span class="string">"userdata"</span>] = <span class="keyword">function</span>(serialString_)
      <span class="keyword">return</span> serialString_ .. (<span class="string">"nil --[[userdata]]"</span>)
    <span class="keyword">end</span>
  }
<span class="keyword">end</span></pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2023-11-26 07:35:37 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
